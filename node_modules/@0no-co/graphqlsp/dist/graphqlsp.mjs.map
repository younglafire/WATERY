{"version":3,"file":"graphqlsp.mjs","sources":["../src/graphql/getSchema.ts","../../../node_modules/.pnpm/graphql-language-service@5.2.0_graphql@16.8.1/node_modules/graphql-language-service/esm/interface/autocompleteUtils.js","../../../node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/esm/main.js","../../../node_modules/.pnpm/graphql-language-service@5.2.0_graphql@16.8.1/node_modules/graphql-language-service/esm/types.js","../../../node_modules/.pnpm/graphql-language-service@5.2.0_graphql@16.8.1/node_modules/graphql-language-service/esm/parser/types.js","../../../node_modules/.pnpm/graphql-language-service@5.2.0_graphql@16.8.1/node_modules/graphql-language-service/esm/interface/getAutocompleteSuggestions.js","../../../node_modules/.pnpm/graphql-language-service@5.2.0_graphql@16.8.1/node_modules/graphql-language-service/esm/interface/getHoverInformation.js","../src/ast/cursor.ts","../src/ast/token.ts","../src/graphql/getFragmentSpreadSuggestions.ts","../src/autoComplete.ts","../src/index.ts","../src/quickInfo.ts"],"sourcesContent":["import type { Stats, PathLike } from 'node:fs';\nimport fs from 'node:fs/promises';\nimport path from 'path';\n\nimport type { IntrospectionQuery } from 'graphql';\n\nimport {\n  type SchemaLoaderResult,\n  type SchemaRef as _SchemaRef,\n  type GraphQLSPConfig,\n  loadRef,\n  minifyIntrospection,\n  outputIntrospectionFile,\n  resolveTypeScriptRootDir,\n} from '@gql.tada/internal';\n\nimport { ts } from '../ts';\nimport { Logger } from '../index';\n\nconst statFile = (\n  file: PathLike,\n  predicate: (stat: Stats) => boolean\n): Promise<boolean> => {\n  return fs\n    .stat(file)\n    .then(predicate)\n    .catch(() => false);\n};\n\nconst touchFile = async (file: PathLike): Promise<void> => {\n  try {\n    const now = new Date();\n    await fs.utimes(file, now, now);\n  } catch (_error) {}\n};\n\n/** Writes a file to a swapfile then moves it into place to prevent excess change events. */\nexport const swapWrite = async (\n  target: PathLike,\n  contents: string\n): Promise<void> => {\n  if (!(await statFile(target, stat => stat.isFile()))) {\n    // If the file doesn't exist, we can write directly, and not\n    // try-catch so the error falls through\n    await fs.writeFile(target, contents);\n  } else {\n    // If the file exists, we write to a swap-file, then rename (i.e. move)\n    // the file into place. No try-catch around `writeFile` for proper\n    // directory/permission errors\n    const tempTarget = target + '.tmp';\n    await fs.writeFile(tempTarget, contents);\n    try {\n      await fs.rename(tempTarget, target);\n    } catch (error) {\n      await fs.unlink(tempTarget);\n      throw error;\n    } finally {\n      // When we move the file into place, we also update its access and\n      // modification time manually, in case the rename doesn't trigger\n      // a change event\n      await touchFile(target);\n    }\n  }\n};\n\nasync function saveTadaIntrospection(\n  introspection: IntrospectionQuery,\n  tadaOutputLocation: string,\n  disablePreprocessing: boolean,\n  logger: Logger\n) {\n  const minified = minifyIntrospection(introspection);\n  const contents = outputIntrospectionFile(minified, {\n    fileType: tadaOutputLocation,\n    shouldPreprocess: !disablePreprocessing,\n  });\n\n  let output = tadaOutputLocation;\n  if (await statFile(output, stat => stat.isDirectory())) {\n    output = path.join(output, 'introspection.d.ts');\n  } else if (!(await statFile(output, p => !!p))) {\n    await fs.mkdir(path.dirname(output), { recursive: true });\n    if (await statFile(output, stat => stat.isDirectory())) {\n      output = path.join(output, 'introspection.d.ts');\n    }\n  }\n\n  try {\n    await swapWrite(output, contents);\n    logger(`Introspection saved to path @ ${output}`);\n  } catch (error) {\n    logger(`Failed to write introspection @ ${error}`);\n  }\n}\n\nexport type SchemaRef = _SchemaRef<SchemaLoaderResult | null>;\n\nexport const loadSchema = (\n  // TODO: abstract info away\n  info: ts.server.PluginCreateInfo,\n  origin: GraphQLSPConfig,\n  logger: Logger\n): _SchemaRef<SchemaLoaderResult | null> => {\n  const ref = loadRef(origin);\n\n  (async () => {\n    const rootPath =\n      (await resolveTypeScriptRootDir(info.project.getProjectName())) ||\n      path.dirname(info.project.getProjectName());\n\n    const tadaDisablePreprocessing =\n      info.config.tadaDisablePreprocessing ?? false;\n    const tadaOutputLocation =\n      info.config.tadaOutputLocation &&\n      path.resolve(rootPath, info.config.tadaOutputLocation);\n\n    logger('Got root-directory to resolve schema from: ' + rootPath);\n    logger('Resolving schema from \"schema\" config: ' + JSON.stringify(origin));\n\n    try {\n      logger(`Loading schema...`);\n      await ref.load({ rootPath });\n    } catch (error) {\n      logger(`Failed to load schema: ${error}`);\n    }\n\n    if (ref.current) {\n      if (ref.current && ref.current.tadaOutputLocation !== undefined) {\n        saveTadaIntrospection(\n          ref.current.introspection,\n          tadaOutputLocation,\n          tadaDisablePreprocessing,\n          logger\n        );\n      }\n    } else if (ref.multi) {\n      Object.values(ref.multi).forEach(value => {\n        if (!value) return;\n\n        if (value.tadaOutputLocation) {\n          saveTadaIntrospection(\n            value.introspection,\n            path.resolve(rootPath, value.tadaOutputLocation),\n            tadaDisablePreprocessing,\n            logger\n          );\n        }\n      });\n    }\n\n    ref.autoupdate({ rootPath }, (schemaRef, value) => {\n      if (!value) return;\n\n      if (value.tadaOutputLocation) {\n        const found = schemaRef.multi\n          ? schemaRef.multi[value.name as string]\n          : schemaRef.current;\n        if (!found) return;\n        saveTadaIntrospection(\n          found.introspection,\n          path.resolve(rootPath, value.tadaOutputLocation),\n          tadaDisablePreprocessing,\n          logger\n        );\n      }\n    });\n  })();\n\n  return ref as any;\n};\n","import { isCompositeType, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, } from 'graphql';\nexport function getDefinitionState(tokenState) {\n    let definitionState;\n    forEachState(tokenState, (state) => {\n        switch (state.kind) {\n            case 'Query':\n            case 'ShortQuery':\n            case 'Mutation':\n            case 'Subscription':\n            case 'FragmentDefinition':\n                definitionState = state;\n                break;\n        }\n    });\n    return definitionState;\n}\nexport function getFieldDef(schema, type, fieldName) {\n    if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type) {\n        return SchemaMetaFieldDef;\n    }\n    if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type) {\n        return TypeMetaFieldDef;\n    }\n    if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type)) {\n        return TypeNameMetaFieldDef;\n    }\n    if ('getFields' in type) {\n        return type.getFields()[fieldName];\n    }\n    return null;\n}\nexport function forEachState(stack, fn) {\n    const reverseStateStack = [];\n    let state = stack;\n    while (state === null || state === void 0 ? void 0 : state.kind) {\n        reverseStateStack.push(state);\n        state = state.prevState;\n    }\n    for (let i = reverseStateStack.length - 1; i >= 0; i--) {\n        fn(reverseStateStack[i]);\n    }\n}\nexport function objectValues(object) {\n    const keys = Object.keys(object);\n    const len = keys.length;\n    const values = new Array(len);\n    for (let i = 0; i < len; ++i) {\n        values[i] = object[keys[i]];\n    }\n    return values;\n}\nexport function hintList(token, list) {\n    return filterAndSortList(list, normalizeText(token.string));\n}\nfunction filterAndSortList(list, text) {\n    if (!text) {\n        return filterNonEmpty(list, entry => !entry.isDeprecated);\n    }\n    const byProximity = list.map(entry => ({\n        proximity: getProximity(normalizeText(entry.label), text),\n        entry,\n    }));\n    return filterNonEmpty(filterNonEmpty(byProximity, pair => pair.proximity <= 2), pair => !pair.entry.isDeprecated)\n        .sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) ||\n        a.proximity - b.proximity ||\n        a.entry.label.length - b.entry.label.length)\n        .map(pair => pair.entry);\n}\nfunction filterNonEmpty(array, predicate) {\n    const filtered = array.filter(predicate);\n    return filtered.length === 0 ? array : filtered;\n}\nfunction normalizeText(text) {\n    return text.toLowerCase().replaceAll(/\\W/g, '');\n}\nfunction getProximity(suggestion, text) {\n    let proximity = lexicalDistance(text, suggestion);\n    if (suggestion.length > text.length) {\n        proximity -= suggestion.length - text.length - 1;\n        proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n    }\n    return proximity;\n}\nfunction lexicalDistance(a, b) {\n    let i;\n    let j;\n    const d = [];\n    const aLength = a.length;\n    const bLength = b.length;\n    for (i = 0; i <= aLength; i++) {\n        d[i] = [i];\n    }\n    for (j = 1; j <= bLength; j++) {\n        d[0][j] = j;\n    }\n    for (i = 1; i <= aLength; i++) {\n        for (j = 1; j <= bLength; j++) {\n            const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n            d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n                d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n            }\n        }\n    }\n    return d[aLength][bLength];\n}\n//# sourceMappingURL=autocompleteUtils.js.map","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nexport var DocumentUri;\n(function (DocumentUri) {\n    function is(value) {\n        return typeof value === 'string';\n    }\n    DocumentUri.is = is;\n})(DocumentUri || (DocumentUri = {}));\nexport var URI;\n(function (URI) {\n    function is(value) {\n        return typeof value === 'string';\n    }\n    URI.is = is;\n})(URI || (URI = {}));\nexport var integer;\n(function (integer) {\n    integer.MIN_VALUE = -2147483648;\n    integer.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n    }\n    integer.is = is;\n})(integer || (integer = {}));\nexport var uinteger;\n(function (uinteger) {\n    uinteger.MIN_VALUE = 0;\n    uinteger.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n    }\n    uinteger.is = is;\n})(uinteger || (uinteger = {}));\n/**\n * The Position namespace provides helper functions to work with\n * {@link Position} literals.\n */\nexport var Position;\n(function (Position) {\n    /**\n     * Creates a new Position literal from the given line and character.\n     * @param line The position's line.\n     * @param character The position's character.\n     */\n    function create(line, character) {\n        if (line === Number.MAX_VALUE) {\n            line = uinteger.MAX_VALUE;\n        }\n        if (character === Number.MAX_VALUE) {\n            character = uinteger.MAX_VALUE;\n        }\n        return { line, character };\n    }\n    Position.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Position} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n    }\n    Position.is = is;\n})(Position || (Position = {}));\n/**\n * The Range namespace provides helper functions to work with\n * {@link Range} literals.\n */\nexport var Range;\n(function (Range) {\n    function create(one, two, three, four) {\n        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n            return { start: Position.create(one, two), end: Position.create(three, four) };\n        }\n        else if (Position.is(one) && Position.is(two)) {\n            return { start: one, end: two };\n        }\n        else {\n            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);\n        }\n    }\n    Range.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Range} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n    }\n    Range.is = is;\n})(Range || (Range = {}));\n/**\n * The Location namespace provides helper functions to work with\n * {@link Location} literals.\n */\nexport var Location;\n(function (Location) {\n    /**\n     * Creates a Location literal.\n     * @param uri The location's uri.\n     * @param range The location's range.\n     */\n    function create(uri, range) {\n        return { uri, range };\n    }\n    Location.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Location} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n    }\n    Location.is = is;\n})(Location || (Location = {}));\n/**\n * The LocationLink namespace provides helper functions to work with\n * {@link LocationLink} literals.\n */\nexport var LocationLink;\n(function (LocationLink) {\n    /**\n     * Creates a LocationLink literal.\n     * @param targetUri The definition's uri.\n     * @param targetRange The full range of the definition.\n     * @param targetSelectionRange The span of the symbol definition at the target.\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\n     */\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };\n    }\n    LocationLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link LocationLink} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n            && Range.is(candidate.targetSelectionRange)\n            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n    }\n    LocationLink.is = is;\n})(LocationLink || (LocationLink = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link Color} literals.\n */\nexport var Color;\n(function (Color) {\n    /**\n     * Creates a new Color literal.\n     */\n    function create(red, green, blue, alpha) {\n        return {\n            red,\n            green,\n            blue,\n            alpha,\n        };\n    }\n    Color.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Color} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\n            && Is.numberRange(candidate.green, 0, 1)\n            && Is.numberRange(candidate.blue, 0, 1)\n            && Is.numberRange(candidate.alpha, 0, 1);\n    }\n    Color.is = is;\n})(Color || (Color = {}));\n/**\n * The ColorInformation namespace provides helper functions to work with\n * {@link ColorInformation} literals.\n */\nexport var ColorInformation;\n(function (ColorInformation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(range, color) {\n        return {\n            range,\n            color,\n        };\n    }\n    ColorInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n    }\n    ColorInformation.is = is;\n})(ColorInformation || (ColorInformation = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link ColorPresentation} literals.\n */\nexport var ColorPresentation;\n(function (ColorPresentation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(label, textEdit, additionalTextEdits) {\n        return {\n            label,\n            textEdit,\n            additionalTextEdits,\n        };\n    }\n    ColorPresentation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label)\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n    }\n    ColorPresentation.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\n/**\n * A set of predefined range kinds.\n */\nexport var FoldingRangeKind;\n(function (FoldingRangeKind) {\n    /**\n     * Folding range for a comment\n     */\n    FoldingRangeKind.Comment = 'comment';\n    /**\n     * Folding range for an import or include\n     */\n    FoldingRangeKind.Imports = 'imports';\n    /**\n     * Folding range for a region (e.g. `#region`)\n     */\n    FoldingRangeKind.Region = 'region';\n})(FoldingRangeKind || (FoldingRangeKind = {}));\n/**\n * The folding range namespace provides helper functions to work with\n * {@link FoldingRange} literals.\n */\nexport var FoldingRange;\n(function (FoldingRange) {\n    /**\n     * Creates a new FoldingRange literal.\n     */\n    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n        const result = {\n            startLine,\n            endLine\n        };\n        if (Is.defined(startCharacter)) {\n            result.startCharacter = startCharacter;\n        }\n        if (Is.defined(endCharacter)) {\n            result.endCharacter = endCharacter;\n        }\n        if (Is.defined(kind)) {\n            result.kind = kind;\n        }\n        if (Is.defined(collapsedText)) {\n            result.collapsedText = collapsedText;\n        }\n        return result;\n    }\n    FoldingRange.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n    }\n    FoldingRange.is = is;\n})(FoldingRange || (FoldingRange = {}));\n/**\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\n * {@link DiagnosticRelatedInformation} literals.\n */\nexport var DiagnosticRelatedInformation;\n(function (DiagnosticRelatedInformation) {\n    /**\n     * Creates a new DiagnosticRelatedInformation literal.\n     */\n    function create(location, message) {\n        return {\n            location,\n            message\n        };\n    }\n    DiagnosticRelatedInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n    }\n    DiagnosticRelatedInformation.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\n/**\n * The diagnostic's severity.\n */\nexport var DiagnosticSeverity;\n(function (DiagnosticSeverity) {\n    /**\n     * Reports an error.\n     */\n    DiagnosticSeverity.Error = 1;\n    /**\n     * Reports a warning.\n     */\n    DiagnosticSeverity.Warning = 2;\n    /**\n     * Reports an information.\n     */\n    DiagnosticSeverity.Information = 3;\n    /**\n     * Reports a hint.\n     */\n    DiagnosticSeverity.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\n/**\n * The diagnostic tags.\n *\n * @since 3.15.0\n */\nexport var DiagnosticTag;\n(function (DiagnosticTag) {\n    /**\n     * Unused or unnecessary code.\n     *\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\n     * an error squiggle.\n     */\n    DiagnosticTag.Unnecessary = 1;\n    /**\n     * Deprecated or obsolete code.\n     *\n     * Clients are allowed to rendered diagnostics with this tag strike through.\n     */\n    DiagnosticTag.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\n/**\n * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n *\n * @since 3.16.0\n */\nexport var CodeDescription;\n(function (CodeDescription) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.href);\n    }\n    CodeDescription.is = is;\n})(CodeDescription || (CodeDescription = {}));\n/**\n * The Diagnostic namespace provides helper functions to work with\n * {@link Diagnostic} literals.\n */\nexport var Diagnostic;\n(function (Diagnostic) {\n    /**\n     * Creates a new Diagnostic literal.\n     */\n    function create(range, message, severity, code, source, relatedInformation) {\n        let result = { range, message };\n        if (Is.defined(severity)) {\n            result.severity = severity;\n        }\n        if (Is.defined(code)) {\n            result.code = code;\n        }\n        if (Is.defined(source)) {\n            result.source = source;\n        }\n        if (Is.defined(relatedInformation)) {\n            result.relatedInformation = relatedInformation;\n        }\n        return result;\n    }\n    Diagnostic.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n     */\n    function is(value) {\n        var _a;\n        let candidate = value;\n        return Is.defined(candidate)\n            && Range.is(candidate.range)\n            && Is.string(candidate.message)\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n    }\n    Diagnostic.is = is;\n})(Diagnostic || (Diagnostic = {}));\n/**\n * The Command namespace provides helper functions to work with\n * {@link Command} literals.\n */\nexport var Command;\n(function (Command) {\n    /**\n     * Creates a new Command literal.\n     */\n    function create(title, command, ...args) {\n        let result = { title, command };\n        if (Is.defined(args) && args.length > 0) {\n            result.arguments = args;\n        }\n        return result;\n    }\n    Command.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Command} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n    }\n    Command.is = is;\n})(Command || (Command = {}));\n/**\n * The TextEdit namespace provides helper function to create replace,\n * insert and delete edits more easily.\n */\nexport var TextEdit;\n(function (TextEdit) {\n    /**\n     * Creates a replace text edit.\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     */\n    function replace(range, newText) {\n        return { range, newText };\n    }\n    TextEdit.replace = replace;\n    /**\n     * Creates an insert text edit.\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     */\n    function insert(position, newText) {\n        return { range: { start: position, end: position }, newText };\n    }\n    TextEdit.insert = insert;\n    /**\n     * Creates a delete text edit.\n     * @param range The range of text to be deleted.\n     */\n    function del(range) {\n        return { range, newText: '' };\n    }\n    TextEdit.del = del;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate)\n            && Is.string(candidate.newText)\n            && Range.is(candidate.range);\n    }\n    TextEdit.is = is;\n})(TextEdit || (TextEdit = {}));\nexport var ChangeAnnotation;\n(function (ChangeAnnotation) {\n    function create(label, needsConfirmation, description) {\n        const result = { label };\n        if (needsConfirmation !== undefined) {\n            result.needsConfirmation = needsConfirmation;\n        }\n        if (description !== undefined) {\n            result.description = description;\n        }\n        return result;\n    }\n    ChangeAnnotation.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    ChangeAnnotation.is = is;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nexport var ChangeAnnotationIdentifier;\n(function (ChangeAnnotationIdentifier) {\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate);\n    }\n    ChangeAnnotationIdentifier.is = is;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nexport var AnnotatedTextEdit;\n(function (AnnotatedTextEdit) {\n    /**\n     * Creates an annotated replace text edit.\n     *\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     * @param annotation The annotation.\n     */\n    function replace(range, newText, annotation) {\n        return { range, newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.replace = replace;\n    /**\n     * Creates an annotated insert text edit.\n     *\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     * @param annotation The annotation.\n     */\n    function insert(position, newText, annotation) {\n        return { range: { start: position, end: position }, newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.insert = insert;\n    /**\n     * Creates an annotated delete text edit.\n     *\n     * @param range The range of text to be deleted.\n     * @param annotation The annotation.\n     */\n    function del(range, annotation) {\n        return { range, newText: '', annotationId: annotation };\n    }\n    AnnotatedTextEdit.del = del;\n    function is(value) {\n        const candidate = value;\n        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    AnnotatedTextEdit.is = is;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\n/**\n * The TextDocumentEdit namespace provides helper function to create\n * an edit that manipulates a text document.\n */\nexport var TextDocumentEdit;\n(function (TextDocumentEdit) {\n    /**\n     * Creates a new `TextDocumentEdit`\n     */\n    function create(textDocument, edits) {\n        return { textDocument, edits };\n    }\n    TextDocumentEdit.create = create;\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate)\n            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n            && Array.isArray(candidate.edits);\n    }\n    TextDocumentEdit.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nexport var CreateFile;\n(function (CreateFile) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: 'create',\n            uri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    CreateFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    CreateFile.is = is;\n})(CreateFile || (CreateFile = {}));\nexport var RenameFile;\n(function (RenameFile) {\n    function create(oldUri, newUri, options, annotation) {\n        let result = {\n            kind: 'rename',\n            oldUri,\n            newUri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    RenameFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    RenameFile.is = is;\n})(RenameFile || (RenameFile = {}));\nexport var DeleteFile;\n(function (DeleteFile) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: 'delete',\n            uri\n        };\n        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    DeleteFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    DeleteFile.is = is;\n})(DeleteFile || (DeleteFile = {}));\nexport var WorkspaceEdit;\n(function (WorkspaceEdit) {\n    function is(value) {\n        let candidate = value;\n        return candidate &&\n            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n            (candidate.documentChanges === undefined || candidate.documentChanges.every((change) => {\n                if (Is.string(change.kind)) {\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                }\n                else {\n                    return TextDocumentEdit.is(change);\n                }\n            }));\n    }\n    WorkspaceEdit.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nclass TextEditChangeImpl {\n    constructor(edits, changeAnnotations) {\n        this.edits = edits;\n        this.changeAnnotations = changeAnnotations;\n    }\n    insert(position, newText, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.insert(position, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.insert(position, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.insert(position, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    replace(range, newText, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.replace(range, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.replace(range, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.replace(range, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    delete(range, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.del(range);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.del(range, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.del(range, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    add(edit) {\n        this.edits.push(edit);\n    }\n    all() {\n        return this.edits;\n    }\n    clear() {\n        this.edits.splice(0, this.edits.length);\n    }\n    assertChangeAnnotations(value) {\n        if (value === undefined) {\n            throw new Error(`Text edit change is not configured to manage change annotations.`);\n        }\n    }\n}\n/**\n * A helper class\n */\nclass ChangeAnnotations {\n    constructor(annotations) {\n        this._annotations = annotations === undefined ? Object.create(null) : annotations;\n        this._counter = 0;\n        this._size = 0;\n    }\n    all() {\n        return this._annotations;\n    }\n    get size() {\n        return this._size;\n    }\n    manage(idOrAnnotation, annotation) {\n        let id;\n        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n            id = idOrAnnotation;\n        }\n        else {\n            id = this.nextId();\n            annotation = idOrAnnotation;\n        }\n        if (this._annotations[id] !== undefined) {\n            throw new Error(`Id ${id} is already in use.`);\n        }\n        if (annotation === undefined) {\n            throw new Error(`No annotation provided for id ${id}`);\n        }\n        this._annotations[id] = annotation;\n        this._size++;\n        return id;\n    }\n    nextId() {\n        this._counter++;\n        return this._counter.toString();\n    }\n}\n/**\n * A workspace change helps constructing changes to a workspace.\n */\nexport class WorkspaceChange {\n    constructor(workspaceEdit) {\n        this._textEditChanges = Object.create(null);\n        if (workspaceEdit !== undefined) {\n            this._workspaceEdit = workspaceEdit;\n            if (workspaceEdit.documentChanges) {\n                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                workspaceEdit.documentChanges.forEach((change) => {\n                    if (TextDocumentEdit.is(change)) {\n                        const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);\n                        this._textEditChanges[change.textDocument.uri] = textEditChange;\n                    }\n                });\n            }\n            else if (workspaceEdit.changes) {\n                Object.keys(workspaceEdit.changes).forEach((key) => {\n                    const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    this._textEditChanges[key] = textEditChange;\n                });\n            }\n        }\n        else {\n            this._workspaceEdit = {};\n        }\n    }\n    /**\n     * Returns the underlying {@link WorkspaceEdit} literal\n     * use to be returned from a workspace edit operation like rename.\n     */\n    get edit() {\n        this.initDocumentChanges();\n        if (this._changeAnnotations !== undefined) {\n            if (this._changeAnnotations.size === 0) {\n                this._workspaceEdit.changeAnnotations = undefined;\n            }\n            else {\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n            }\n        }\n        return this._workspaceEdit;\n    }\n    getTextEditChange(key) {\n        if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            const textDocument = { uri: key.uri, version: key.version };\n            let result = this._textEditChanges[textDocument.uri];\n            if (!result) {\n                const edits = [];\n                const textDocumentEdit = {\n                    textDocument,\n                    edits\n                };\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                this._textEditChanges[textDocument.uri] = result;\n            }\n            return result;\n        }\n        else {\n            this.initChanges();\n            if (this._workspaceEdit.changes === undefined) {\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\n            }\n            let result = this._textEditChanges[key];\n            if (!result) {\n                let edits = [];\n                this._workspaceEdit.changes[key] = edits;\n                result = new TextEditChangeImpl(edits);\n                this._textEditChanges[key] = result;\n            }\n            return result;\n        }\n    }\n    initDocumentChanges() {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._changeAnnotations = new ChangeAnnotations();\n            this._workspaceEdit.documentChanges = [];\n            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        }\n    }\n    initChanges() {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._workspaceEdit.changes = Object.create(null);\n        }\n    }\n    createFile(uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = CreateFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = CreateFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    renameFile(oldUri, newUri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = RenameFile.create(oldUri, newUri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = RenameFile.create(oldUri, newUri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    deleteFile(uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = DeleteFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = DeleteFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n}\n/**\n * The TextDocumentIdentifier namespace provides helper functions to work with\n * {@link TextDocumentIdentifier} literals.\n */\nexport var TextDocumentIdentifier;\n(function (TextDocumentIdentifier) {\n    /**\n     * Creates a new TextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     */\n    function create(uri) {\n        return { uri };\n    }\n    TextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri);\n    }\n    TextDocumentIdentifier.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\n/**\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link VersionedTextDocumentIdentifier} literals.\n */\nexport var VersionedTextDocumentIdentifier;\n(function (VersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new VersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */\n    function create(uri, version) {\n        return { uri, version };\n    }\n    VersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n    }\n    VersionedTextDocumentIdentifier.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\n/**\n * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link OptionalVersionedTextDocumentIdentifier} literals.\n */\nexport var OptionalVersionedTextDocumentIdentifier;\n(function (OptionalVersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */\n    function create(uri, version) {\n        return { uri, version };\n    }\n    OptionalVersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n    }\n    OptionalVersionedTextDocumentIdentifier.is = is;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\n/**\n * The TextDocumentItem namespace provides helper functions to work with\n * {@link TextDocumentItem} literals.\n */\nexport var TextDocumentItem;\n(function (TextDocumentItem) {\n    /**\n     * Creates a new TextDocumentItem literal.\n     * @param uri The document's uri.\n     * @param languageId The document's language identifier.\n     * @param version The document's version number.\n     * @param text The document's text.\n     */\n    function create(uri, languageId, version, text) {\n        return { uri, languageId, version, text };\n    }\n    TextDocumentItem.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n    }\n    TextDocumentItem.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\n/**\n * Describes the content type that a client supports in various\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n *\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\n * are reserved for internal usage.\n */\nexport var MarkupKind;\n(function (MarkupKind) {\n    /**\n     * Plain text is supported as a content format\n     */\n    MarkupKind.PlainText = 'plaintext';\n    /**\n     * Markdown is supported as a content format\n     */\n    MarkupKind.Markdown = 'markdown';\n    /**\n     * Checks whether the given value is a value of the {@link MarkupKind} type.\n     */\n    function is(value) {\n        const candidate = value;\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n    }\n    MarkupKind.is = is;\n})(MarkupKind || (MarkupKind = {}));\nexport var MarkupContent;\n(function (MarkupContent) {\n    /**\n     * Checks whether the given value conforms to the {@link MarkupContent} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n    }\n    MarkupContent.is = is;\n})(MarkupContent || (MarkupContent = {}));\n/**\n * The kind of a completion entry.\n */\nexport var CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind.Text = 1;\n    CompletionItemKind.Method = 2;\n    CompletionItemKind.Function = 3;\n    CompletionItemKind.Constructor = 4;\n    CompletionItemKind.Field = 5;\n    CompletionItemKind.Variable = 6;\n    CompletionItemKind.Class = 7;\n    CompletionItemKind.Interface = 8;\n    CompletionItemKind.Module = 9;\n    CompletionItemKind.Property = 10;\n    CompletionItemKind.Unit = 11;\n    CompletionItemKind.Value = 12;\n    CompletionItemKind.Enum = 13;\n    CompletionItemKind.Keyword = 14;\n    CompletionItemKind.Snippet = 15;\n    CompletionItemKind.Color = 16;\n    CompletionItemKind.File = 17;\n    CompletionItemKind.Reference = 18;\n    CompletionItemKind.Folder = 19;\n    CompletionItemKind.EnumMember = 20;\n    CompletionItemKind.Constant = 21;\n    CompletionItemKind.Struct = 22;\n    CompletionItemKind.Event = 23;\n    CompletionItemKind.Operator = 24;\n    CompletionItemKind.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\n/**\n * Defines whether the insert text in a completion item should be interpreted as\n * plain text or a snippet.\n */\nexport var InsertTextFormat;\n(function (InsertTextFormat) {\n    /**\n     * The primary text to be inserted is treated as a plain string.\n     */\n    InsertTextFormat.PlainText = 1;\n    /**\n     * The primary text to be inserted is treated as a snippet.\n     *\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n     * the end of the snippet. Placeholders with equal identifiers are linked,\n     * that is typing in one will update others too.\n     *\n     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n     */\n    InsertTextFormat.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\n/**\n * Completion item tags are extra annotations that tweak the rendering of a completion\n * item.\n *\n * @since 3.15.0\n */\nexport var CompletionItemTag;\n(function (CompletionItemTag) {\n    /**\n     * Render a completion as obsolete, usually using a strike-out.\n     */\n    CompletionItemTag.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\n/**\n * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n *\n * @since 3.16.0\n */\nexport var InsertReplaceEdit;\n(function (InsertReplaceEdit) {\n    /**\n     * Creates a new insert / replace edit\n     */\n    function create(newText, insert, replace) {\n        return { newText, insert, replace };\n    }\n    InsertReplaceEdit.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n    }\n    InsertReplaceEdit.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\n/**\n * How whitespace and indentation is handled during completion\n * item insertion.\n *\n * @since 3.16.0\n */\nexport var InsertTextMode;\n(function (InsertTextMode) {\n    /**\n     * The insertion or replace strings is taken as it is. If the\n     * value is multi line the lines below the cursor will be\n     * inserted using the indentation defined in the string value.\n     * The client will not apply any kind of adjustments to the\n     * string.\n     */\n    InsertTextMode.asIs = 1;\n    /**\n     * The editor adjusts leading whitespace of new lines so that\n     * they match the indentation up to the cursor of the line for\n     * which the item is accepted.\n     *\n     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n     * multi line completion item is indented using 2 tabs and all\n     * following lines inserted will be indented using 2 tabs as well.\n     */\n    InsertTextMode.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\nexport var CompletionItemLabelDetails;\n(function (CompletionItemLabelDetails) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    CompletionItemLabelDetails.is = is;\n})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));\n/**\n * The CompletionItem namespace provides functions to deal with\n * completion items.\n */\nexport var CompletionItem;\n(function (CompletionItem) {\n    /**\n     * Create a completion item and seed it with a label.\n     * @param label The completion item's label\n     */\n    function create(label) {\n        return { label };\n    }\n    CompletionItem.create = create;\n})(CompletionItem || (CompletionItem = {}));\n/**\n * The CompletionList namespace provides functions to deal with\n * completion lists.\n */\nexport var CompletionList;\n(function (CompletionList) {\n    /**\n     * Creates a new completion list.\n     *\n     * @param items The completion items.\n     * @param isIncomplete The list is not complete.\n     */\n    function create(items, isIncomplete) {\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\n    }\n    CompletionList.create = create;\n})(CompletionList || (CompletionList = {}));\nexport var MarkedString;\n(function (MarkedString) {\n    /**\n     * Creates a marked string from plain text.\n     *\n     * @param plainText The plain text.\n     */\n    function fromPlainText(plainText) {\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    MarkedString.fromPlainText = fromPlainText;\n    /**\n     * Checks whether the given value conforms to the {@link MarkedString} type.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n    }\n    MarkedString.is = is;\n})(MarkedString || (MarkedString = {}));\nexport var Hover;\n(function (Hover) {\n    /**\n     * Checks whether the given value conforms to the {@link Hover} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n            MarkedString.is(candidate.contents) ||\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n    }\n    Hover.is = is;\n})(Hover || (Hover = {}));\n/**\n * The ParameterInformation namespace provides helper functions to work with\n * {@link ParameterInformation} literals.\n */\nexport var ParameterInformation;\n(function (ParameterInformation) {\n    /**\n     * Creates a new parameter information literal.\n     *\n     * @param label A label string.\n     * @param documentation A doc string.\n     */\n    function create(label, documentation) {\n        return documentation ? { label, documentation } : { label };\n    }\n    ParameterInformation.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\n/**\n * The SignatureInformation namespace provides helper functions to work with\n * {@link SignatureInformation} literals.\n */\nexport var SignatureInformation;\n(function (SignatureInformation) {\n    function create(label, documentation, ...parameters) {\n        let result = { label };\n        if (Is.defined(documentation)) {\n            result.documentation = documentation;\n        }\n        if (Is.defined(parameters)) {\n            result.parameters = parameters;\n        }\n        else {\n            result.parameters = [];\n        }\n        return result;\n    }\n    SignatureInformation.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind.Text = 1;\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind.Read = 2;\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * DocumentHighlight namespace to provide helper functions to work with\n * {@link DocumentHighlight} literals.\n */\nexport var DocumentHighlight;\n(function (DocumentHighlight) {\n    /**\n     * Create a DocumentHighlight object.\n     * @param range The range the highlight applies to.\n     * @param kind The highlight kind\n     */\n    function create(range, kind) {\n        let result = { range };\n        if (Is.number(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    DocumentHighlight.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\n/**\n * A symbol kind.\n */\nexport var SymbolKind;\n(function (SymbolKind) {\n    SymbolKind.File = 1;\n    SymbolKind.Module = 2;\n    SymbolKind.Namespace = 3;\n    SymbolKind.Package = 4;\n    SymbolKind.Class = 5;\n    SymbolKind.Method = 6;\n    SymbolKind.Property = 7;\n    SymbolKind.Field = 8;\n    SymbolKind.Constructor = 9;\n    SymbolKind.Enum = 10;\n    SymbolKind.Interface = 11;\n    SymbolKind.Function = 12;\n    SymbolKind.Variable = 13;\n    SymbolKind.Constant = 14;\n    SymbolKind.String = 15;\n    SymbolKind.Number = 16;\n    SymbolKind.Boolean = 17;\n    SymbolKind.Array = 18;\n    SymbolKind.Object = 19;\n    SymbolKind.Key = 20;\n    SymbolKind.Null = 21;\n    SymbolKind.EnumMember = 22;\n    SymbolKind.Struct = 23;\n    SymbolKind.Event = 24;\n    SymbolKind.Operator = 25;\n    SymbolKind.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\n/**\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\n *\n * @since 3.16\n */\nexport var SymbolTag;\n(function (SymbolTag) {\n    /**\n     * Render a symbol as obsolete, usually using a strike-out.\n     */\n    SymbolTag.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nexport var SymbolInformation;\n(function (SymbolInformation) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the location of the symbol.\n     * @param uri The resource of the location of symbol.\n     * @param containerName The name of the symbol containing the symbol.\n     */\n    function create(name, kind, range, uri, containerName) {\n        let result = {\n            name,\n            kind,\n            location: { uri, range }\n        };\n        if (containerName) {\n            result.containerName = containerName;\n        }\n        return result;\n    }\n    SymbolInformation.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nexport var WorkspaceSymbol;\n(function (WorkspaceSymbol) {\n    /**\n     * Create a new workspace symbol.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param uri The resource of the location of the symbol.\n     * @param range An options range of the location.\n     * @returns A WorkspaceSymbol.\n     */\n    function create(name, kind, uri, range) {\n        return range !== undefined\n            ? { name, kind, location: { uri, range } }\n            : { name, kind, location: { uri } };\n    }\n    WorkspaceSymbol.create = create;\n})(WorkspaceSymbol || (WorkspaceSymbol = {}));\nexport var DocumentSymbol;\n(function (DocumentSymbol) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param detail The detail of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the symbol.\n     * @param selectionRange The selectionRange of the symbol.\n     * @param children Children of the symbol.\n     */\n    function create(name, detail, kind, range, selectionRange, children) {\n        let result = {\n            name,\n            detail,\n            kind,\n            range,\n            selectionRange\n        };\n        if (children !== undefined) {\n            result.children = children;\n        }\n        return result;\n    }\n    DocumentSymbol.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return candidate &&\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\n            (candidate.detail === undefined || Is.string(candidate.detail)) &&\n            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n            (candidate.children === undefined || Array.isArray(candidate.children)) &&\n            (candidate.tags === undefined || Array.isArray(candidate.tags));\n    }\n    DocumentSymbol.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\n/**\n * A set of predefined code action kinds\n */\nexport var CodeActionKind;\n(function (CodeActionKind) {\n    /**\n     * Empty kind.\n     */\n    CodeActionKind.Empty = '';\n    /**\n     * Base kind for quickfix actions: 'quickfix'\n     */\n    CodeActionKind.QuickFix = 'quickfix';\n    /**\n     * Base kind for refactoring actions: 'refactor'\n     */\n    CodeActionKind.Refactor = 'refactor';\n    /**\n     * Base kind for refactoring extraction actions: 'refactor.extract'\n     *\n     * Example extract actions:\n     *\n     * - Extract method\n     * - Extract function\n     * - Extract variable\n     * - Extract interface from class\n     * - ...\n     */\n    CodeActionKind.RefactorExtract = 'refactor.extract';\n    /**\n     * Base kind for refactoring inline actions: 'refactor.inline'\n     *\n     * Example inline actions:\n     *\n     * - Inline function\n     * - Inline variable\n     * - Inline constant\n     * - ...\n     */\n    CodeActionKind.RefactorInline = 'refactor.inline';\n    /**\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n     *\n     * Example rewrite actions:\n     *\n     * - Convert JavaScript function to class\n     * - Add or remove parameter\n     * - Encapsulate field\n     * - Make method static\n     * - Move method to base class\n     * - ...\n     */\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n    /**\n     * Base kind for source actions: `source`\n     *\n     * Source code actions apply to the entire file.\n     */\n    CodeActionKind.Source = 'source';\n    /**\n     * Base kind for an organize imports source action: `source.organizeImports`\n     */\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n    /**\n     * Base kind for auto-fix source actions: `source.fixAll`.\n     *\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n     *\n     * @since 3.15.0\n     */\n    CodeActionKind.SourceFixAll = 'source.fixAll';\n})(CodeActionKind || (CodeActionKind = {}));\n/**\n * The reason why code actions were requested.\n *\n * @since 3.17.0\n */\nexport var CodeActionTriggerKind;\n(function (CodeActionTriggerKind) {\n    /**\n     * Code actions were explicitly requested by the user or by an extension.\n     */\n    CodeActionTriggerKind.Invoked = 1;\n    /**\n     * Code actions were requested automatically.\n     *\n     * This typically happens when current selection in a file changes, but can\n     * also be triggered when file content changes.\n     */\n    CodeActionTriggerKind.Automatic = 2;\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));\n/**\n * The CodeActionContext namespace provides helper functions to work with\n * {@link CodeActionContext} literals.\n */\nexport var CodeActionContext;\n(function (CodeActionContext) {\n    /**\n     * Creates a new CodeActionContext literal.\n     */\n    function create(diagnostics, only, triggerKind) {\n        let result = { diagnostics };\n        if (only !== undefined && only !== null) {\n            result.only = only;\n        }\n        if (triggerKind !== undefined && triggerKind !== null) {\n            result.triggerKind = triggerKind;\n        }\n        return result;\n    }\n    CodeActionContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\n            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\n            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n    }\n    CodeActionContext.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nexport var CodeAction;\n(function (CodeAction) {\n    function create(title, kindOrCommandOrEdit, kind) {\n        let result = { title };\n        let checkKind = true;\n        if (typeof kindOrCommandOrEdit === 'string') {\n            checkKind = false;\n            result.kind = kindOrCommandOrEdit;\n        }\n        else if (Command.is(kindOrCommandOrEdit)) {\n            result.command = kindOrCommandOrEdit;\n        }\n        else {\n            result.edit = kindOrCommandOrEdit;\n        }\n        if (checkKind && kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    CodeAction.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.string(candidate.title) &&\n            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n            (candidate.kind === undefined || Is.string(candidate.kind)) &&\n            (candidate.edit !== undefined || candidate.command !== undefined) &&\n            (candidate.command === undefined || Command.is(candidate.command)) &&\n            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n    }\n    CodeAction.is = is;\n})(CodeAction || (CodeAction = {}));\n/**\n * The CodeLens namespace provides helper functions to work with\n * {@link CodeLens} literals.\n */\nexport var CodeLens;\n(function (CodeLens) {\n    /**\n     * Creates a new CodeLens literal.\n     */\n    function create(range, data) {\n        let result = { range };\n        if (Is.defined(data)) {\n            result.data = data;\n        }\n        return result;\n    }\n    CodeLens.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeLens} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n    }\n    CodeLens.is = is;\n})(CodeLens || (CodeLens = {}));\n/**\n * The FormattingOptions namespace provides helper functions to work with\n * {@link FormattingOptions} literals.\n */\nexport var FormattingOptions;\n(function (FormattingOptions) {\n    /**\n     * Creates a new FormattingOptions literal.\n     */\n    function create(tabSize, insertSpaces) {\n        return { tabSize, insertSpaces };\n    }\n    FormattingOptions.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n    }\n    FormattingOptions.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\n/**\n * The DocumentLink namespace provides helper functions to work with\n * {@link DocumentLink} literals.\n */\nexport var DocumentLink;\n(function (DocumentLink) {\n    /**\n     * Creates a new DocumentLink literal.\n     */\n    function create(range, target, data) {\n        return { range, target, data };\n    }\n    DocumentLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n    }\n    DocumentLink.is = is;\n})(DocumentLink || (DocumentLink = {}));\n/**\n * The SelectionRange namespace provides helper function to work with\n * SelectionRange literals.\n */\nexport var SelectionRange;\n(function (SelectionRange) {\n    /**\n     * Creates a new SelectionRange\n     * @param range the range.\n     * @param parent an optional parent.\n     */\n    function create(range, parent) {\n        return { range, parent };\n    }\n    SelectionRange.create = create;\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n    }\n    SelectionRange.is = is;\n})(SelectionRange || (SelectionRange = {}));\n/**\n * A set of predefined token types. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenTypes;\n(function (SemanticTokenTypes) {\n    SemanticTokenTypes[\"namespace\"] = \"namespace\";\n    /**\n     * Represents a generic type. Acts as a fallback for types which can't be mapped to\n     * a specific type like class or enum.\n     */\n    SemanticTokenTypes[\"type\"] = \"type\";\n    SemanticTokenTypes[\"class\"] = \"class\";\n    SemanticTokenTypes[\"enum\"] = \"enum\";\n    SemanticTokenTypes[\"interface\"] = \"interface\";\n    SemanticTokenTypes[\"struct\"] = \"struct\";\n    SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n    SemanticTokenTypes[\"parameter\"] = \"parameter\";\n    SemanticTokenTypes[\"variable\"] = \"variable\";\n    SemanticTokenTypes[\"property\"] = \"property\";\n    SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n    SemanticTokenTypes[\"event\"] = \"event\";\n    SemanticTokenTypes[\"function\"] = \"function\";\n    SemanticTokenTypes[\"method\"] = \"method\";\n    SemanticTokenTypes[\"macro\"] = \"macro\";\n    SemanticTokenTypes[\"keyword\"] = \"keyword\";\n    SemanticTokenTypes[\"modifier\"] = \"modifier\";\n    SemanticTokenTypes[\"comment\"] = \"comment\";\n    SemanticTokenTypes[\"string\"] = \"string\";\n    SemanticTokenTypes[\"number\"] = \"number\";\n    SemanticTokenTypes[\"regexp\"] = \"regexp\";\n    SemanticTokenTypes[\"operator\"] = \"operator\";\n    /**\n     * @since 3.17.0\n     */\n    SemanticTokenTypes[\"decorator\"] = \"decorator\";\n})(SemanticTokenTypes || (SemanticTokenTypes = {}));\n/**\n * A set of predefined token modifiers. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenModifiers;\n(function (SemanticTokenModifiers) {\n    SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n    SemanticTokenModifiers[\"definition\"] = \"definition\";\n    SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n    SemanticTokenModifiers[\"static\"] = \"static\";\n    SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n    SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n    SemanticTokenModifiers[\"async\"] = \"async\";\n    SemanticTokenModifiers[\"modification\"] = \"modification\";\n    SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n    SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));\n/**\n * @since 3.16.0\n */\nexport var SemanticTokens;\n(function (SemanticTokens) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\n            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\n    }\n    SemanticTokens.is = is;\n})(SemanticTokens || (SemanticTokens = {}));\n/**\n * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n *\n * @since 3.17.0\n */\nexport var InlineValueText;\n(function (InlineValueText) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, text) {\n        return { range, text };\n    }\n    InlineValueText.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n    }\n    InlineValueText.is = is;\n})(InlineValueText || (InlineValueText = {}));\n/**\n * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n *\n * @since 3.17.0\n */\nexport var InlineValueVariableLookup;\n(function (InlineValueVariableLookup) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, variableName, caseSensitiveLookup) {\n        return { range, variableName, caseSensitiveLookup };\n    }\n    InlineValueVariableLookup.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\n            && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n    }\n    InlineValueVariableLookup.is = is;\n})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));\n/**\n * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n *\n * @since 3.17.0\n */\nexport var InlineValueEvaluatableExpression;\n(function (InlineValueEvaluatableExpression) {\n    /**\n     * Creates a new InlineValueEvaluatableExpression literal.\n     */\n    function create(range, expression) {\n        return { range, expression };\n    }\n    InlineValueEvaluatableExpression.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range)\n            && (Is.string(candidate.expression) || candidate.expression === undefined);\n    }\n    InlineValueEvaluatableExpression.is = is;\n})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));\n/**\n * The InlineValueContext namespace provides helper functions to work with\n * {@link InlineValueContext} literals.\n *\n * @since 3.17.0\n */\nexport var InlineValueContext;\n(function (InlineValueContext) {\n    /**\n     * Creates a new InlineValueContext literal.\n     */\n    function create(frameId, stoppedLocation) {\n        return { frameId, stoppedLocation };\n    }\n    InlineValueContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.defined(candidate) && Range.is(value.stoppedLocation);\n    }\n    InlineValueContext.is = is;\n})(InlineValueContext || (InlineValueContext = {}));\n/**\n * Inlay hint kinds.\n *\n * @since 3.17.0\n */\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    /**\n     * An inlay hint that for a type annotation.\n     */\n    InlayHintKind.Type = 1;\n    /**\n     * An inlay hint that is for a parameter.\n     */\n    InlayHintKind.Parameter = 2;\n    function is(value) {\n        return value === 1 || value === 2;\n    }\n    InlayHintKind.is = is;\n})(InlayHintKind || (InlayHintKind = {}));\nexport var InlayHintLabelPart;\n(function (InlayHintLabelPart) {\n    function create(value) {\n        return { value };\n    }\n    InlayHintLabelPart.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.location === undefined || Location.is(candidate.location))\n            && (candidate.command === undefined || Command.is(candidate.command));\n    }\n    InlayHintLabelPart.is = is;\n})(InlayHintLabelPart || (InlayHintLabelPart = {}));\nexport var InlayHint;\n(function (InlayHint) {\n    function create(position, label, kind) {\n        const result = { position, label };\n        if (kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    InlayHint.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.position)\n            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\n            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\n            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\n            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n    }\n    InlayHint.is = is;\n})(InlayHint || (InlayHint = {}));\nexport var StringValue;\n(function (StringValue) {\n    function createSnippet(value) {\n        return { kind: 'snippet', value };\n    }\n    StringValue.createSnippet = createSnippet;\n})(StringValue || (StringValue = {}));\nexport var InlineCompletionItem;\n(function (InlineCompletionItem) {\n    function create(insertText, filterText, range, command) {\n        return { insertText, filterText, range, command };\n    }\n    InlineCompletionItem.create = create;\n})(InlineCompletionItem || (InlineCompletionItem = {}));\nexport var InlineCompletionList;\n(function (InlineCompletionList) {\n    function create(items) {\n        return { items };\n    }\n    InlineCompletionList.create = create;\n})(InlineCompletionList || (InlineCompletionList = {}));\n/**\n * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\n *\n * @since 3.18.0\n * @proposed\n */\nexport var InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     */\n    InlineCompletionTriggerKind.Invoked = 0;\n    /**\n     * Completion was triggered automatically while editing.\n     */\n    InlineCompletionTriggerKind.Automatic = 1;\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nexport var SelectedCompletionInfo;\n(function (SelectedCompletionInfo) {\n    function create(range, text) {\n        return { range, text };\n    }\n    SelectedCompletionInfo.create = create;\n})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));\nexport var InlineCompletionContext;\n(function (InlineCompletionContext) {\n    function create(triggerKind, selectedCompletionInfo) {\n        return { triggerKind, selectedCompletionInfo };\n    }\n    InlineCompletionContext.create = create;\n})(InlineCompletionContext || (InlineCompletionContext = {}));\nexport var WorkspaceFolder;\n(function (WorkspaceFolder) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n    }\n    WorkspaceFolder.is = is;\n})(WorkspaceFolder || (WorkspaceFolder = {}));\nexport const EOL = ['\\n', '\\r\\n', '\\r'];\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new ITextDocument literal from the given uri and content.\n     * @param uri The document's uri.\n     * @param languageId The document's language Id.\n     * @param version The document's version.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n    }\n    TextDocument.is = is;\n    function applyEdits(document, edits) {\n        let text = document.getText();\n        let sortedEdits = mergeSort(edits, (a, b) => {\n            let diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        let lastModifiedOffset = text.length;\n        for (let i = sortedEdits.length - 1; i >= 0; i--) {\n            let e = sortedEdits[i];\n            let startOffset = document.offsetAt(e.range.start);\n            let endOffset = document.offsetAt(e.range.end);\n            if (endOffset <= lastModifiedOffset) {\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n            }\n            else {\n                throw new Error('Overlapping edit');\n            }\n            lastModifiedOffset = startOffset;\n        }\n        return text;\n    }\n    TextDocument.applyEdits = applyEdits;\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        const p = (data.length / 2) | 0;\n        const left = data.slice(0, p);\n        const right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        let leftIdx = 0;\n        let rightIdx = 0;\n        let i = 0;\n        while (leftIdx < left.length && rightIdx < right.length) {\n            let ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            }\n            else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while (leftIdx < left.length) {\n            data[i++] = left[leftIdx++];\n        }\n        while (rightIdx < right.length) {\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n})(TextDocument || (TextDocument = {}));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nclass FullTextDocument {\n    constructor(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            let start = this.offsetAt(range.start);\n            let end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(event, version) {\n        this._content = event.text;\n        this._version = version;\n        this._lineOffsets = undefined;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            let lineOffsets = [];\n            let text = this._content;\n            let isLineStart = true;\n            for (let i = 0; i < text.length; i++) {\n                if (isLineStart) {\n                    lineOffsets.push(i);\n                    isLineStart = false;\n                }\n                let ch = text.charAt(i);\n                isLineStart = (ch === '\\r' || ch === '\\n');\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                    i++;\n                }\n            }\n            if (isLineStart && text.length > 0) {\n                lineOffsets.push(text.length);\n            }\n            this._lineOffsets = lineOffsets;\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        let lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return Position.create(0, offset);\n        }\n        while (low < high) {\n            let mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        let line = low - 1;\n        return Position.create(line, offset - lineOffsets[line]);\n    }\n    offsetAt(position) {\n        let lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        let lineOffset = lineOffsets[position.line];\n        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n}\nvar Is;\n(function (Is) {\n    const toString = Object.prototype.toString;\n    function defined(value) {\n        return typeof value !== 'undefined';\n    }\n    Is.defined = defined;\n    function undefined(value) {\n        return typeof value === 'undefined';\n    }\n    Is.undefined = undefined;\n    function boolean(value) {\n        return value === true || value === false;\n    }\n    Is.boolean = boolean;\n    function string(value) {\n        return toString.call(value) === '[object String]';\n    }\n    Is.string = string;\n    function number(value) {\n        return toString.call(value) === '[object Number]';\n    }\n    Is.number = number;\n    function numberRange(value, min, max) {\n        return toString.call(value) === '[object Number]' && min <= value && value <= max;\n    }\n    Is.numberRange = numberRange;\n    function integer(value) {\n        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n    }\n    Is.integer = integer;\n    function uinteger(value) {\n        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n    }\n    Is.uinteger = uinteger;\n    function func(value) {\n        return toString.call(value) === '[object Function]';\n    }\n    Is.func = func;\n    function objectLiteral(value) {\n        // Strictly speaking class instances pass this check as well. Since the LSP\n        // doesn't use classes we ignore this for now. If we do we need to add something\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n        return value !== null && typeof value === 'object';\n    }\n    Is.objectLiteral = objectLiteral;\n    function typedArray(value, check) {\n        return Array.isArray(value) && value.every(check);\n    }\n    Is.typedArray = typedArray;\n})(Is || (Is = {}));\n","export { InsertTextFormat } from 'vscode-languageserver-types';\nexport const FileChangeTypeKind = {\n    Created: 1,\n    Changed: 2,\n    Deleted: 3,\n};\nexport var CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind.Text = 1;\n    CompletionItemKind.Method = 2;\n    CompletionItemKind.Function = 3;\n    CompletionItemKind.Constructor = 4;\n    CompletionItemKind.Field = 5;\n    CompletionItemKind.Variable = 6;\n    CompletionItemKind.Class = 7;\n    CompletionItemKind.Interface = 8;\n    CompletionItemKind.Module = 9;\n    CompletionItemKind.Property = 10;\n    CompletionItemKind.Unit = 11;\n    CompletionItemKind.Value = 12;\n    CompletionItemKind.Enum = 13;\n    CompletionItemKind.Keyword = 14;\n    CompletionItemKind.Snippet = 15;\n    CompletionItemKind.Color = 16;\n    CompletionItemKind.File = 17;\n    CompletionItemKind.Reference = 18;\n    CompletionItemKind.Folder = 19;\n    CompletionItemKind.EnumMember = 20;\n    CompletionItemKind.Constant = 21;\n    CompletionItemKind.Struct = 22;\n    CompletionItemKind.Event = 23;\n    CompletionItemKind.Operator = 24;\n    CompletionItemKind.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\n//# sourceMappingURL=types.js.map","import { Kind } from 'graphql';\nexport const AdditionalRuleKinds = {\n    ALIASED_FIELD: 'AliasedField',\n    ARGUMENTS: 'Arguments',\n    SHORT_QUERY: 'ShortQuery',\n    QUERY: 'Query',\n    MUTATION: 'Mutation',\n    SUBSCRIPTION: 'Subscription',\n    TYPE_CONDITION: 'TypeCondition',\n    INVALID: 'Invalid',\n    COMMENT: 'Comment',\n    SCHEMA_DEF: 'SchemaDef',\n    SCALAR_DEF: 'ScalarDef',\n    OBJECT_TYPE_DEF: 'ObjectTypeDef',\n    OBJECT_VALUE: 'ObjectValue',\n    LIST_VALUE: 'ListValue',\n    INTERFACE_DEF: 'InterfaceDef',\n    UNION_DEF: 'UnionDef',\n    ENUM_DEF: 'EnumDef',\n    ENUM_VALUE: 'EnumValue',\n    FIELD_DEF: 'FieldDef',\n    INPUT_DEF: 'InputDef',\n    INPUT_VALUE_DEF: 'InputValueDef',\n    ARGUMENTS_DEF: 'ArgumentsDef',\n    EXTEND_DEF: 'ExtendDef',\n    EXTENSION_DEFINITION: 'ExtensionDefinition',\n    DIRECTIVE_DEF: 'DirectiveDef',\n    IMPLEMENTS: 'Implements',\n    VARIABLE_DEFINITIONS: 'VariableDefinitions',\n    TYPE: 'Type',\n};\nexport const RuleKinds = Object.assign(Object.assign({}, Kind), AdditionalRuleKinds);\n//# sourceMappingURL=types.js.map","import { isInterfaceType, GraphQLInterfaceType, GraphQLObjectType, Kind, DirectiveLocation, isListType, isNonNullType, isScalarType, isObjectType, isUnionType, isEnumType, isInputObjectType, isOutputType, GraphQLBoolean, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, assertAbstractType, doTypesOverlap, getNamedType, getNullableType, isAbstractType, isCompositeType, isInputType, visit, BREAK, parse, } from 'graphql';\nimport { CompletionItemKind, InsertTextFormat, } from '../types';\nimport { CharacterStream, onlineParser, RuleKinds, } from '../parser';\nimport { forEachState, getDefinitionState, getFieldDef, hintList, objectValues, } from './autocompleteUtils';\nexport const SuggestionCommand = {\n    command: 'editor.action.triggerSuggest',\n    title: 'Suggestions',\n};\nconst collectFragmentDefs = (op) => {\n    const externalFragments = [];\n    if (op) {\n        try {\n            visit(parse(op), {\n                FragmentDefinition(def) {\n                    externalFragments.push(def);\n                },\n            });\n        }\n        catch (_a) {\n            return [];\n        }\n    }\n    return externalFragments;\n};\nconst typeSystemKinds = [\n    Kind.SCHEMA_DEFINITION,\n    Kind.OPERATION_TYPE_DEFINITION,\n    Kind.SCALAR_TYPE_DEFINITION,\n    Kind.OBJECT_TYPE_DEFINITION,\n    Kind.INTERFACE_TYPE_DEFINITION,\n    Kind.UNION_TYPE_DEFINITION,\n    Kind.ENUM_TYPE_DEFINITION,\n    Kind.INPUT_OBJECT_TYPE_DEFINITION,\n    Kind.DIRECTIVE_DEFINITION,\n    Kind.SCHEMA_EXTENSION,\n    Kind.SCALAR_TYPE_EXTENSION,\n    Kind.OBJECT_TYPE_EXTENSION,\n    Kind.INTERFACE_TYPE_EXTENSION,\n    Kind.UNION_TYPE_EXTENSION,\n    Kind.ENUM_TYPE_EXTENSION,\n    Kind.INPUT_OBJECT_TYPE_EXTENSION,\n];\nconst hasTypeSystemDefinitions = (sdl) => {\n    let hasTypeSystemDef = false;\n    if (sdl) {\n        try {\n            visit(parse(sdl), {\n                enter(node) {\n                    if (node.kind === 'Document') {\n                        return;\n                    }\n                    if (typeSystemKinds.includes(node.kind)) {\n                        hasTypeSystemDef = true;\n                        return BREAK;\n                    }\n                    return false;\n                },\n            });\n        }\n        catch (_a) {\n            return hasTypeSystemDef;\n        }\n    }\n    return hasTypeSystemDef;\n};\nexport function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {\n    var _a;\n    const opts = Object.assign(Object.assign({}, options), { schema });\n    const token = contextToken || getTokenAtPosition(queryText, cursor, 1);\n    const state = token.state.kind === 'Invalid' ? token.state.prevState : token.state;\n    const mode = (options === null || options === void 0 ? void 0 : options.mode) || getDocumentMode(queryText, options === null || options === void 0 ? void 0 : options.uri);\n    if (!state) {\n        return [];\n    }\n    const { kind, step, prevState } = state;\n    const typeInfo = getTypeInfo(schema, token.state);\n    if (kind === RuleKinds.DOCUMENT) {\n        if (mode === GraphQLDocumentMode.TYPE_SYSTEM) {\n            return getSuggestionsForTypeSystemDefinitions(token);\n        }\n        return getSuggestionsForExecutableDefinitions(token);\n    }\n    if (kind === RuleKinds.EXTEND_DEF) {\n        return getSuggestionsForExtensionDefinitions(token);\n    }\n    if (((_a = prevState === null || prevState === void 0 ? void 0 : prevState.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.EXTENSION_DEFINITION &&\n        state.name) {\n        return hintList(token, []);\n    }\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind.SCALAR_TYPE_EXTENSION) {\n        return hintList(token, Object.values(schema.getTypeMap())\n            .filter(isScalarType)\n            .map(type => ({\n            label: type.name,\n            kind: CompletionItemKind.Function,\n        })));\n    }\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind.OBJECT_TYPE_EXTENSION) {\n        return hintList(token, Object.values(schema.getTypeMap())\n            .filter(type => isObjectType(type) && !type.name.startsWith('__'))\n            .map(type => ({\n            label: type.name,\n            kind: CompletionItemKind.Function,\n        })));\n    }\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind.INTERFACE_TYPE_EXTENSION) {\n        return hintList(token, Object.values(schema.getTypeMap())\n            .filter(isInterfaceType)\n            .map(type => ({\n            label: type.name,\n            kind: CompletionItemKind.Function,\n        })));\n    }\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind.UNION_TYPE_EXTENSION) {\n        return hintList(token, Object.values(schema.getTypeMap())\n            .filter(isUnionType)\n            .map(type => ({\n            label: type.name,\n            kind: CompletionItemKind.Function,\n        })));\n    }\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind.ENUM_TYPE_EXTENSION) {\n        return hintList(token, Object.values(schema.getTypeMap())\n            .filter(type => isEnumType(type) && !type.name.startsWith('__'))\n            .map(type => ({\n            label: type.name,\n            kind: CompletionItemKind.Function,\n        })));\n    }\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind.INPUT_OBJECT_TYPE_EXTENSION) {\n        return hintList(token, Object.values(schema.getTypeMap())\n            .filter(isInputObjectType)\n            .map(type => ({\n            label: type.name,\n            kind: CompletionItemKind.Function,\n        })));\n    }\n    if (kind === RuleKinds.IMPLEMENTS ||\n        (kind === RuleKinds.NAMED_TYPE && (prevState === null || prevState === void 0 ? void 0 : prevState.kind) === RuleKinds.IMPLEMENTS)) {\n        return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);\n    }\n    if (kind === RuleKinds.SELECTION_SET ||\n        kind === RuleKinds.FIELD ||\n        kind === RuleKinds.ALIASED_FIELD) {\n        return getSuggestionsForFieldNames(token, typeInfo, opts);\n    }\n    if (kind === RuleKinds.ARGUMENTS ||\n        (kind === RuleKinds.ARGUMENT && step === 0)) {\n        const { argDefs } = typeInfo;\n        if (argDefs) {\n            return hintList(token, argDefs.map((argDef) => {\n                var _a;\n                return ({\n                    label: argDef.name,\n                    insertText: argDef.name + ': ',\n                    command: SuggestionCommand,\n                    detail: String(argDef.type),\n                    documentation: (_a = argDef.description) !== null && _a !== void 0 ? _a : undefined,\n                    kind: CompletionItemKind.Variable,\n                    type: argDef.type,\n                });\n            }));\n        }\n    }\n    if ((kind === RuleKinds.OBJECT_VALUE ||\n        (kind === RuleKinds.OBJECT_FIELD && step === 0)) &&\n        typeInfo.objectFieldDefs) {\n        const objectFields = objectValues(typeInfo.objectFieldDefs);\n        const completionKind = kind === RuleKinds.OBJECT_VALUE\n            ? CompletionItemKind.Value\n            : CompletionItemKind.Field;\n        return hintList(token, objectFields.map(field => {\n            var _a;\n            return ({\n                label: field.name,\n                detail: String(field.type),\n                documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n                kind: completionKind,\n                type: field.type,\n            });\n        }));\n    }\n    if (kind === RuleKinds.ENUM_VALUE ||\n        (kind === RuleKinds.LIST_VALUE && step === 1) ||\n        (kind === RuleKinds.OBJECT_FIELD && step === 2) ||\n        (kind === RuleKinds.ARGUMENT && step === 2)) {\n        return getSuggestionsForInputValues(token, typeInfo, queryText, schema);\n    }\n    if (kind === RuleKinds.VARIABLE && step === 1) {\n        const namedInputType = getNamedType(typeInfo.inputType);\n        const variableDefinitions = getVariableCompletions(queryText, schema, token);\n        return hintList(token, variableDefinitions.filter(v => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));\n    }\n    if ((kind === RuleKinds.TYPE_CONDITION && step === 1) ||\n        (kind === RuleKinds.NAMED_TYPE &&\n            prevState != null &&\n            prevState.kind === RuleKinds.TYPE_CONDITION)) {\n        return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, kind);\n    }\n    if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n        return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs)\n            ? fragmentDefs\n            : collectFragmentDefs(fragmentDefs));\n    }\n    const unwrappedState = unwrapType(state);\n    if ((mode === GraphQLDocumentMode.TYPE_SYSTEM &&\n        !unwrappedState.needsAdvance &&\n        kind === RuleKinds.NAMED_TYPE) ||\n        kind === RuleKinds.LIST_TYPE) {\n        if (unwrappedState.kind === RuleKinds.FIELD_DEF) {\n            return hintList(token, Object.values(schema.getTypeMap())\n                .filter(type => isOutputType(type) && !type.name.startsWith('__'))\n                .map(type => ({\n                label: type.name,\n                kind: CompletionItemKind.Function,\n            })));\n        }\n        if (unwrappedState.kind === RuleKinds.INPUT_VALUE_DEF) {\n            return hintList(token, Object.values(schema.getTypeMap())\n                .filter(type => isInputType(type) && !type.name.startsWith('__'))\n                .map(type => ({\n                label: type.name,\n                kind: CompletionItemKind.Function,\n            })));\n        }\n    }\n    if ((kind === RuleKinds.VARIABLE_DEFINITION && step === 2) ||\n        (kind === RuleKinds.LIST_TYPE && step === 1) ||\n        (kind === RuleKinds.NAMED_TYPE &&\n            prevState &&\n            (prevState.kind === RuleKinds.VARIABLE_DEFINITION ||\n                prevState.kind === RuleKinds.LIST_TYPE ||\n                prevState.kind === RuleKinds.NON_NULL_TYPE))) {\n        return getSuggestionsForVariableDefinition(token, schema, kind);\n    }\n    if (kind === RuleKinds.DIRECTIVE) {\n        return getSuggestionsForDirective(token, state, schema, kind);\n    }\n    return [];\n}\nconst insertSuffix = ' {\\n  $1\\n}';\nconst getInsertText = (field) => {\n    const { type } = field;\n    if (isCompositeType(type)) {\n        return insertSuffix;\n    }\n    if (isListType(type) && isCompositeType(type.ofType)) {\n        return insertSuffix;\n    }\n    if (isNonNullType(type)) {\n        if (isCompositeType(type.ofType)) {\n            return insertSuffix;\n        }\n        if (isListType(type.ofType) && isCompositeType(type.ofType.ofType)) {\n            return insertSuffix;\n        }\n    }\n    return null;\n};\nfunction getSuggestionsForTypeSystemDefinitions(token) {\n    return hintList(token, [\n        { label: 'extend', kind: CompletionItemKind.Function },\n        { label: 'type', kind: CompletionItemKind.Function },\n        { label: 'interface', kind: CompletionItemKind.Function },\n        { label: 'union', kind: CompletionItemKind.Function },\n        { label: 'input', kind: CompletionItemKind.Function },\n        { label: 'scalar', kind: CompletionItemKind.Function },\n        { label: 'schema', kind: CompletionItemKind.Function },\n    ]);\n}\nfunction getSuggestionsForExecutableDefinitions(token) {\n    return hintList(token, [\n        { label: 'query', kind: CompletionItemKind.Function },\n        { label: 'mutation', kind: CompletionItemKind.Function },\n        { label: 'subscription', kind: CompletionItemKind.Function },\n        { label: 'fragment', kind: CompletionItemKind.Function },\n        { label: '{', kind: CompletionItemKind.Constructor },\n    ]);\n}\nfunction getSuggestionsForExtensionDefinitions(token) {\n    return hintList(token, [\n        { label: 'type', kind: CompletionItemKind.Function },\n        { label: 'interface', kind: CompletionItemKind.Function },\n        { label: 'union', kind: CompletionItemKind.Function },\n        { label: 'input', kind: CompletionItemKind.Function },\n        { label: 'scalar', kind: CompletionItemKind.Function },\n        { label: 'schema', kind: CompletionItemKind.Function },\n    ]);\n}\nfunction getSuggestionsForFieldNames(token, typeInfo, options) {\n    var _a;\n    if (typeInfo.parentType) {\n        const { parentType } = typeInfo;\n        let fields = [];\n        if ('getFields' in parentType) {\n            fields = objectValues(parentType.getFields());\n        }\n        if (isCompositeType(parentType)) {\n            fields.push(TypeNameMetaFieldDef);\n        }\n        if (parentType === ((_a = options === null || options === void 0 ? void 0 : options.schema) === null || _a === void 0 ? void 0 : _a.getQueryType())) {\n            fields.push(SchemaMetaFieldDef, TypeMetaFieldDef);\n        }\n        return hintList(token, fields.map((field, index) => {\n            var _a;\n            const suggestion = {\n                sortText: String(index) + field.name,\n                label: field.name,\n                detail: String(field.type),\n                documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n                deprecated: Boolean(field.deprecationReason),\n                isDeprecated: Boolean(field.deprecationReason),\n                deprecationReason: field.deprecationReason,\n                kind: CompletionItemKind.Field,\n                type: field.type,\n            };\n            if (options === null || options === void 0 ? void 0 : options.fillLeafsOnComplete) {\n                const insertText = getInsertText(field);\n                if (insertText) {\n                    suggestion.insertText = field.name + insertText;\n                    suggestion.insertTextFormat = InsertTextFormat.Snippet;\n                    suggestion.command = SuggestionCommand;\n                }\n            }\n            return suggestion;\n        }));\n    }\n    return [];\n}\nfunction getSuggestionsForInputValues(token, typeInfo, queryText, schema) {\n    const namedInputType = getNamedType(typeInfo.inputType);\n    const queryVariables = getVariableCompletions(queryText, schema, token).filter(v => v.detail === namedInputType.name);\n    if (namedInputType instanceof GraphQLEnumType) {\n        const values = namedInputType.getValues();\n        return hintList(token, values\n            .map((value) => {\n            var _a;\n            return ({\n                label: value.name,\n                detail: String(namedInputType),\n                documentation: (_a = value.description) !== null && _a !== void 0 ? _a : undefined,\n                deprecated: Boolean(value.deprecationReason),\n                isDeprecated: Boolean(value.deprecationReason),\n                deprecationReason: value.deprecationReason,\n                kind: CompletionItemKind.EnumMember,\n                type: namedInputType,\n            });\n        })\n            .concat(queryVariables));\n    }\n    if (namedInputType === GraphQLBoolean) {\n        return hintList(token, queryVariables.concat([\n            {\n                label: 'true',\n                detail: String(GraphQLBoolean),\n                documentation: 'Not false.',\n                kind: CompletionItemKind.Variable,\n                type: GraphQLBoolean,\n            },\n            {\n                label: 'false',\n                detail: String(GraphQLBoolean),\n                documentation: 'Not true.',\n                kind: CompletionItemKind.Variable,\n                type: GraphQLBoolean,\n            },\n        ]));\n    }\n    return queryVariables;\n}\nfunction getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {\n    if (tokenState.needsSeparator) {\n        return [];\n    }\n    const typeMap = schema.getTypeMap();\n    const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);\n    const schemaInterfaceNames = schemaInterfaces.map(({ name }) => name);\n    const inlineInterfaces = new Set();\n    runOnlineParser(documentText, (_, state) => {\n        var _a, _b, _c, _d, _e;\n        if (state.name) {\n            if (state.kind === RuleKinds.INTERFACE_DEF &&\n                !schemaInterfaceNames.includes(state.name)) {\n                inlineInterfaces.add(state.name);\n            }\n            if (state.kind === RuleKinds.NAMED_TYPE &&\n                ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n                if (typeInfo.interfaceDef) {\n                    const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name }) => name === state.name);\n                    if (existingType) {\n                        return;\n                    }\n                    const type = schema.getType(state.name);\n                    const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();\n                    typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [\n                            ...interfaceConfig.interfaces,\n                            type ||\n                                new GraphQLInterfaceType({ name: state.name, fields: {} }),\n                        ] }));\n                }\n                else if (typeInfo.objectTypeDef) {\n                    const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name }) => name === state.name);\n                    if (existingType) {\n                        return;\n                    }\n                    const type = schema.getType(state.name);\n                    const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();\n                    typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [\n                            ...objectTypeConfig.interfaces,\n                            type ||\n                                new GraphQLInterfaceType({ name: state.name, fields: {} }),\n                        ] }));\n                }\n            }\n        }\n    });\n    const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;\n    const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];\n    const siblingInterfaceNames = siblingInterfaces.map(({ name }) => name);\n    const possibleInterfaces = schemaInterfaces\n        .concat([...inlineInterfaces].map(name => ({ name })))\n        .filter(({ name }) => name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) &&\n        !siblingInterfaceNames.includes(name));\n    return hintList(token, possibleInterfaces.map(type => {\n        const result = {\n            label: type.name,\n            kind: CompletionItemKind.Interface,\n            type,\n        };\n        if (type === null || type === void 0 ? void 0 : type.description) {\n            result.documentation = type.description;\n        }\n        return result;\n    }));\n}\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n    let possibleTypes;\n    if (typeInfo.parentType) {\n        if (isAbstractType(typeInfo.parentType)) {\n            const abstractType = assertAbstractType(typeInfo.parentType);\n            const possibleObjTypes = schema.getPossibleTypes(abstractType);\n            const possibleIfaceMap = Object.create(null);\n            for (const type of possibleObjTypes) {\n                for (const iface of type.getInterfaces()) {\n                    possibleIfaceMap[iface.name] = iface;\n                }\n            }\n            possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n        }\n        else {\n            possibleTypes = [typeInfo.parentType];\n        }\n    }\n    else {\n        const typeMap = schema.getTypeMap();\n        possibleTypes = objectValues(typeMap).filter(type => isCompositeType(type) && !type.name.startsWith('__'));\n    }\n    return hintList(token, possibleTypes.map(type => {\n        const namedType = getNamedType(type);\n        return {\n            label: String(type),\n            documentation: (namedType === null || namedType === void 0 ? void 0 : namedType.description) || '',\n            kind: CompletionItemKind.Field,\n        };\n    }));\n}\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {\n    if (!queryText) {\n        return [];\n    }\n    const typeMap = schema.getTypeMap();\n    const defState = getDefinitionState(token.state);\n    const fragments = getFragmentDefinitions(queryText);\n    if (fragmentDefs && fragmentDefs.length > 0) {\n        fragments.push(...fragmentDefs);\n    }\n    const relevantFrags = fragments.filter(frag => typeMap[frag.typeCondition.name.value] &&\n        !(defState &&\n            defState.kind === RuleKinds.FRAGMENT_DEFINITION &&\n            defState.name === frag.name.value) &&\n        isCompositeType(typeInfo.parentType) &&\n        isCompositeType(typeMap[frag.typeCondition.name.value]) &&\n        doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n    return hintList(token, relevantFrags.map(frag => ({\n        label: frag.name.value,\n        detail: String(typeMap[frag.typeCondition.name.value]),\n        documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n        kind: CompletionItemKind.Field,\n        type: typeMap[frag.typeCondition.name.value],\n    })));\n}\nconst getParentDefinition = (state, kind) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    if (((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === kind) {\n        return state.prevState;\n    }\n    if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {\n        return state.prevState.prevState;\n    }\n    if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {\n        return state.prevState.prevState.prevState;\n    }\n    if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {\n        return state.prevState.prevState.prevState.prevState;\n    }\n};\nexport function getVariableCompletions(queryText, schema, token) {\n    let variableName = null;\n    let variableType;\n    const definitions = Object.create({});\n    runOnlineParser(queryText, (_, state) => {\n        if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.VARIABLE && state.name) {\n            variableName = state.name;\n        }\n        if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.NAMED_TYPE && variableName) {\n            const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);\n            if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {\n                variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);\n            }\n        }\n        if (variableName && variableType && !definitions[variableName]) {\n            definitions[variableName] = {\n                detail: variableType.toString(),\n                insertText: token.string === '$' ? variableName : '$' + variableName,\n                label: variableName,\n                type: variableType,\n                kind: CompletionItemKind.Variable,\n            };\n            variableName = null;\n            variableType = null;\n        }\n    });\n    return objectValues(definitions);\n}\nexport function getFragmentDefinitions(queryText) {\n    const fragmentDefs = [];\n    runOnlineParser(queryText, (_, state) => {\n        if (state.kind === RuleKinds.FRAGMENT_DEFINITION &&\n            state.name &&\n            state.type) {\n            fragmentDefs.push({\n                kind: RuleKinds.FRAGMENT_DEFINITION,\n                name: {\n                    kind: Kind.NAME,\n                    value: state.name,\n                },\n                selectionSet: {\n                    kind: RuleKinds.SELECTION_SET,\n                    selections: [],\n                },\n                typeCondition: {\n                    kind: RuleKinds.NAMED_TYPE,\n                    name: {\n                        kind: Kind.NAME,\n                        value: state.type,\n                    },\n                },\n            });\n        }\n    });\n    return fragmentDefs;\n}\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n    const inputTypeMap = schema.getTypeMap();\n    const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n    return hintList(token, inputTypes.map((type) => ({\n        label: type.name,\n        documentation: type.description,\n        kind: CompletionItemKind.Variable,\n    })));\n}\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n    var _a;\n    if ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) {\n        const directives = schema\n            .getDirectives()\n            .filter(directive => canUseDirective(state.prevState, directive));\n        return hintList(token, directives.map(directive => ({\n            label: directive.name,\n            documentation: directive.description || '',\n            kind: CompletionItemKind.Function,\n        })));\n    }\n    return [];\n}\nexport function getTokenAtPosition(queryText, cursor, offset = 0) {\n    let styleAtCursor = null;\n    let stateAtCursor = null;\n    let stringAtCursor = null;\n    const token = runOnlineParser(queryText, (stream, state, style, index) => {\n        if (index !== cursor.line ||\n            stream.getCurrentPosition() + offset < cursor.character + 1) {\n            return;\n        }\n        styleAtCursor = style;\n        stateAtCursor = Object.assign({}, state);\n        stringAtCursor = stream.current();\n        return 'BREAK';\n    });\n    return {\n        start: token.start,\n        end: token.end,\n        string: stringAtCursor || token.string,\n        state: stateAtCursor || token.state,\n        style: styleAtCursor || token.style,\n    };\n}\nexport function runOnlineParser(queryText, callback) {\n    const lines = queryText.split('\\n');\n    const parser = onlineParser();\n    let state = parser.startState();\n    let style = '';\n    let stream = new CharacterStream('');\n    for (let i = 0; i < lines.length; i++) {\n        stream = new CharacterStream(lines[i]);\n        while (!stream.eol()) {\n            style = parser.token(stream, state);\n            const code = callback(stream, state, style, i);\n            if (code === 'BREAK') {\n                break;\n            }\n        }\n        callback(stream, state, style, i);\n        if (!state.kind) {\n            state = parser.startState();\n        }\n    }\n    return {\n        start: stream.getStartOfToken(),\n        end: stream.getCurrentPosition(),\n        string: stream.current(),\n        state,\n        style,\n    };\n}\nexport function canUseDirective(state, directive) {\n    if (!(state === null || state === void 0 ? void 0 : state.kind)) {\n        return false;\n    }\n    const { kind, prevState } = state;\n    const { locations } = directive;\n    switch (kind) {\n        case RuleKinds.QUERY:\n            return locations.includes(DirectiveLocation.QUERY);\n        case RuleKinds.MUTATION:\n            return locations.includes(DirectiveLocation.MUTATION);\n        case RuleKinds.SUBSCRIPTION:\n            return locations.includes(DirectiveLocation.SUBSCRIPTION);\n        case RuleKinds.FIELD:\n        case RuleKinds.ALIASED_FIELD:\n            return locations.includes(DirectiveLocation.FIELD);\n        case RuleKinds.FRAGMENT_DEFINITION:\n            return locations.includes(DirectiveLocation.FRAGMENT_DEFINITION);\n        case RuleKinds.FRAGMENT_SPREAD:\n            return locations.includes(DirectiveLocation.FRAGMENT_SPREAD);\n        case RuleKinds.INLINE_FRAGMENT:\n            return locations.includes(DirectiveLocation.INLINE_FRAGMENT);\n        case RuleKinds.SCHEMA_DEF:\n            return locations.includes(DirectiveLocation.SCHEMA);\n        case RuleKinds.SCALAR_DEF:\n            return locations.includes(DirectiveLocation.SCALAR);\n        case RuleKinds.OBJECT_TYPE_DEF:\n            return locations.includes(DirectiveLocation.OBJECT);\n        case RuleKinds.FIELD_DEF:\n            return locations.includes(DirectiveLocation.FIELD_DEFINITION);\n        case RuleKinds.INTERFACE_DEF:\n            return locations.includes(DirectiveLocation.INTERFACE);\n        case RuleKinds.UNION_DEF:\n            return locations.includes(DirectiveLocation.UNION);\n        case RuleKinds.ENUM_DEF:\n            return locations.includes(DirectiveLocation.ENUM);\n        case RuleKinds.ENUM_VALUE:\n            return locations.includes(DirectiveLocation.ENUM_VALUE);\n        case RuleKinds.INPUT_DEF:\n            return locations.includes(DirectiveLocation.INPUT_OBJECT);\n        case RuleKinds.INPUT_VALUE_DEF:\n            const prevStateKind = prevState === null || prevState === void 0 ? void 0 : prevState.kind;\n            switch (prevStateKind) {\n                case RuleKinds.ARGUMENTS_DEF:\n                    return locations.includes(DirectiveLocation.ARGUMENT_DEFINITION);\n                case RuleKinds.INPUT_DEF:\n                    return locations.includes(DirectiveLocation.INPUT_FIELD_DEFINITION);\n            }\n    }\n    return false;\n}\nexport function getTypeInfo(schema, tokenState) {\n    let argDef;\n    let argDefs;\n    let directiveDef;\n    let enumValue;\n    let fieldDef;\n    let inputType;\n    let objectTypeDef;\n    let objectFieldDefs;\n    let parentType;\n    let type;\n    let interfaceDef;\n    forEachState(tokenState, state => {\n        var _a;\n        switch (state.kind) {\n            case RuleKinds.QUERY:\n            case 'ShortQuery':\n                type = schema.getQueryType();\n                break;\n            case RuleKinds.MUTATION:\n                type = schema.getMutationType();\n                break;\n            case RuleKinds.SUBSCRIPTION:\n                type = schema.getSubscriptionType();\n                break;\n            case RuleKinds.INLINE_FRAGMENT:\n            case RuleKinds.FRAGMENT_DEFINITION:\n                if (state.type) {\n                    type = schema.getType(state.type);\n                }\n                break;\n            case RuleKinds.FIELD:\n            case RuleKinds.ALIASED_FIELD: {\n                if (!type || !state.name) {\n                    fieldDef = null;\n                }\n                else {\n                    fieldDef = parentType\n                        ? getFieldDef(schema, parentType, state.name)\n                        : null;\n                    type = fieldDef ? fieldDef.type : null;\n                }\n                break;\n            }\n            case RuleKinds.SELECTION_SET:\n                parentType = getNamedType(type);\n                break;\n            case RuleKinds.DIRECTIVE:\n                directiveDef = state.name ? schema.getDirective(state.name) : null;\n                break;\n            case RuleKinds.INTERFACE_DEF:\n                if (state.name) {\n                    objectTypeDef = null;\n                    interfaceDef = new GraphQLInterfaceType({\n                        name: state.name,\n                        interfaces: [],\n                        fields: {},\n                    });\n                }\n                break;\n            case RuleKinds.OBJECT_TYPE_DEF:\n                if (state.name) {\n                    interfaceDef = null;\n                    objectTypeDef = new GraphQLObjectType({\n                        name: state.name,\n                        interfaces: [],\n                        fields: {},\n                    });\n                }\n                break;\n            case RuleKinds.ARGUMENTS: {\n                if (state.prevState) {\n                    switch (state.prevState.kind) {\n                        case RuleKinds.FIELD:\n                            argDefs = fieldDef && fieldDef.args;\n                            break;\n                        case RuleKinds.DIRECTIVE:\n                            argDefs =\n                                directiveDef && directiveDef.args;\n                            break;\n                        case RuleKinds.ALIASED_FIELD: {\n                            const name = (_a = state.prevState) === null || _a === void 0 ? void 0 : _a.name;\n                            if (!name) {\n                                argDefs = null;\n                                break;\n                            }\n                            const field = parentType\n                                ? getFieldDef(schema, parentType, name)\n                                : null;\n                            if (!field) {\n                                argDefs = null;\n                                break;\n                            }\n                            argDefs = field.args;\n                            break;\n                        }\n                        default:\n                            argDefs = null;\n                            break;\n                    }\n                }\n                else {\n                    argDefs = null;\n                }\n                break;\n            }\n            case RuleKinds.ARGUMENT:\n                if (argDefs) {\n                    for (let i = 0; i < argDefs.length; i++) {\n                        if (argDefs[i].name === state.name) {\n                            argDef = argDefs[i];\n                            break;\n                        }\n                    }\n                }\n                inputType = argDef === null || argDef === void 0 ? void 0 : argDef.type;\n                break;\n            case RuleKinds.ENUM_VALUE:\n                const enumType = getNamedType(inputType);\n                enumValue =\n                    enumType instanceof GraphQLEnumType\n                        ? enumType\n                            .getValues()\n                            .find((val) => val.value === state.name)\n                        : null;\n                break;\n            case RuleKinds.LIST_VALUE:\n                const nullableType = getNullableType(inputType);\n                inputType =\n                    nullableType instanceof GraphQLList ? nullableType.ofType : null;\n                break;\n            case RuleKinds.OBJECT_VALUE:\n                const objectType = getNamedType(inputType);\n                objectFieldDefs =\n                    objectType instanceof GraphQLInputObjectType\n                        ? objectType.getFields()\n                        : null;\n                break;\n            case RuleKinds.OBJECT_FIELD:\n                const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n                inputType = objectField === null || objectField === void 0 ? void 0 : objectField.type;\n                break;\n            case RuleKinds.NAMED_TYPE:\n                if (state.name) {\n                    type = schema.getType(state.name);\n                }\n                break;\n        }\n    });\n    return {\n        argDef,\n        argDefs,\n        directiveDef,\n        enumValue,\n        fieldDef,\n        inputType,\n        objectFieldDefs,\n        parentType,\n        type,\n        interfaceDef,\n        objectTypeDef,\n    };\n}\nexport var GraphQLDocumentMode;\n(function (GraphQLDocumentMode) {\n    GraphQLDocumentMode[\"TYPE_SYSTEM\"] = \"TYPE_SYSTEM\";\n    GraphQLDocumentMode[\"EXECUTABLE\"] = \"EXECUTABLE\";\n})(GraphQLDocumentMode || (GraphQLDocumentMode = {}));\nfunction getDocumentMode(documentText, uri) {\n    if (uri === null || uri === void 0 ? void 0 : uri.endsWith('.graphqls')) {\n        return GraphQLDocumentMode.TYPE_SYSTEM;\n    }\n    return hasTypeSystemDefinitions(documentText)\n        ? GraphQLDocumentMode.TYPE_SYSTEM\n        : GraphQLDocumentMode.EXECUTABLE;\n}\nfunction unwrapType(state) {\n    if (state.prevState &&\n        state.kind &&\n        [\n            RuleKinds.NAMED_TYPE,\n            RuleKinds.LIST_TYPE,\n            RuleKinds.TYPE,\n            RuleKinds.NON_NULL_TYPE,\n        ].includes(state.kind)) {\n        return unwrapType(state.prevState);\n    }\n    return state;\n}\n//# sourceMappingURL=getAutocompleteSuggestions.js.map","import { GraphQLNonNull, GraphQLList, } from 'graphql';\nimport { getTokenAtPosition, getTypeInfo } from './getAutocompleteSuggestions';\nexport function getHoverInformation(schema, queryText, cursor, contextToken, config) {\n    const token = contextToken || getTokenAtPosition(queryText, cursor);\n    if (!schema || !token || !token.state) {\n        return '';\n    }\n    const { kind, step } = token.state;\n    const typeInfo = getTypeInfo(schema, token.state);\n    const options = Object.assign(Object.assign({}, config), { schema });\n    if ((kind === 'Field' && step === 0 && typeInfo.fieldDef) ||\n        (kind === 'AliasedField' && step === 2 && typeInfo.fieldDef)) {\n        const into = [];\n        renderMdCodeStart(into, options);\n        renderField(into, typeInfo, options);\n        renderMdCodeEnd(into, options);\n        renderDescription(into, options, typeInfo.fieldDef);\n        return into.join('').trim();\n    }\n    if (kind === 'Directive' && step === 1 && typeInfo.directiveDef) {\n        const into = [];\n        renderMdCodeStart(into, options);\n        renderDirective(into, typeInfo, options);\n        renderMdCodeEnd(into, options);\n        renderDescription(into, options, typeInfo.directiveDef);\n        return into.join('').trim();\n    }\n    if (kind === 'Argument' && step === 0 && typeInfo.argDef) {\n        const into = [];\n        renderMdCodeStart(into, options);\n        renderArg(into, typeInfo, options);\n        renderMdCodeEnd(into, options);\n        renderDescription(into, options, typeInfo.argDef);\n        return into.join('').trim();\n    }\n    if (kind === 'EnumValue' &&\n        typeInfo.enumValue &&\n        'description' in typeInfo.enumValue) {\n        const into = [];\n        renderMdCodeStart(into, options);\n        renderEnumValue(into, typeInfo, options);\n        renderMdCodeEnd(into, options);\n        renderDescription(into, options, typeInfo.enumValue);\n        return into.join('').trim();\n    }\n    if (kind === 'NamedType' && typeInfo.type && 'description' in typeInfo.type) {\n        const into = [];\n        renderMdCodeStart(into, options);\n        renderType(into, typeInfo, options, typeInfo.type);\n        renderMdCodeEnd(into, options);\n        renderDescription(into, options, typeInfo.type);\n        return into.join('').trim();\n    }\n    return '';\n}\nfunction renderMdCodeStart(into, options) {\n    if (options.useMarkdown) {\n        text(into, '```graphql\\n');\n    }\n}\nfunction renderMdCodeEnd(into, options) {\n    if (options.useMarkdown) {\n        text(into, '\\n```');\n    }\n}\nfunction renderField(into, typeInfo, options) {\n    renderQualifiedField(into, typeInfo, options);\n    renderTypeAnnotation(into, typeInfo, options, typeInfo.type);\n}\nfunction renderQualifiedField(into, typeInfo, options) {\n    if (!typeInfo.fieldDef) {\n        return;\n    }\n    const fieldName = typeInfo.fieldDef.name;\n    if (fieldName.slice(0, 2) !== '__') {\n        renderType(into, typeInfo, options, typeInfo.parentType);\n        text(into, '.');\n    }\n    text(into, fieldName);\n}\nfunction renderDirective(into, typeInfo, _options) {\n    if (!typeInfo.directiveDef) {\n        return;\n    }\n    const name = '@' + typeInfo.directiveDef.name;\n    text(into, name);\n}\nfunction renderArg(into, typeInfo, options) {\n    if (typeInfo.directiveDef) {\n        renderDirective(into, typeInfo, options);\n    }\n    else if (typeInfo.fieldDef) {\n        renderQualifiedField(into, typeInfo, options);\n    }\n    if (!typeInfo.argDef) {\n        return;\n    }\n    const { name } = typeInfo.argDef;\n    text(into, '(');\n    text(into, name);\n    renderTypeAnnotation(into, typeInfo, options, typeInfo.inputType);\n    text(into, ')');\n}\nfunction renderTypeAnnotation(into, typeInfo, options, t) {\n    text(into, ': ');\n    renderType(into, typeInfo, options, t);\n}\nfunction renderEnumValue(into, typeInfo, options) {\n    if (!typeInfo.enumValue) {\n        return;\n    }\n    const { name } = typeInfo.enumValue;\n    renderType(into, typeInfo, options, typeInfo.inputType);\n    text(into, '.');\n    text(into, name);\n}\nfunction renderType(into, typeInfo, options, t) {\n    if (!t) {\n        return;\n    }\n    if (t instanceof GraphQLNonNull) {\n        renderType(into, typeInfo, options, t.ofType);\n        text(into, '!');\n    }\n    else if (t instanceof GraphQLList) {\n        text(into, '[');\n        renderType(into, typeInfo, options, t.ofType);\n        text(into, ']');\n    }\n    else {\n        text(into, t.name);\n    }\n}\nfunction renderDescription(into, options, def) {\n    if (!def) {\n        return;\n    }\n    const description = typeof def.description === 'string' ? def.description : null;\n    if (description) {\n        text(into, '\\n\\n');\n        text(into, description);\n    }\n    renderDeprecation(into, options, def);\n}\nfunction renderDeprecation(into, _options, def) {\n    if (!def) {\n        return;\n    }\n    const reason = def.deprecationReason || null;\n    if (!reason) {\n        return;\n    }\n    text(into, '\\n\\n');\n    text(into, 'Deprecated: ');\n    text(into, reason);\n}\nfunction text(into, content) {\n    into.push(content);\n}\n//# sourceMappingURL=getHoverInformation.js.map","import { IPosition } from 'graphql-language-service';\n\nexport class Cursor implements IPosition {\n  line: number;\n  character: number;\n\n  constructor(line: number, char: number) {\n    this.line = line;\n    this.character = char;\n  }\n\n  setLine(line: number) {\n    this.line = line;\n  }\n\n  setCharacter(character: number) {\n    this.character = character;\n  }\n\n  lessThanOrEqualTo(position: IPosition) {\n    return (\n      this.line < position.line ||\n      (this.line === position.line && this.character <= position.character)\n    );\n  }\n}\n","import { ts } from '../ts';\nimport { onlineParser, State, CharacterStream } from 'graphql-language-service';\n\nexport interface Token {\n  start: number;\n  end: number;\n  string: string;\n  tokenKind: string;\n  line: number;\n  state: State;\n}\n\nexport const getToken = (\n  template: ts.Expression,\n  cursorPosition: number\n): Token | undefined => {\n  if (!ts.isTemplateLiteral(template) && !ts.isStringLiteralLike(template)) {\n    return undefined;\n  }\n\n  const text = template.getText().slice(1, -1);\n  const input = text.split('\\n');\n  const parser = onlineParser();\n  const state = parser.startState();\n  let cPos = template.getStart() + 1;\n\n  let foundToken: Token | undefined = undefined;\n  let prevToken: Token | undefined = undefined;\n  for (let line = 0; line < input.length; line++) {\n    if (foundToken) continue;\n    const lPos = cPos - 1;\n    const stream = new CharacterStream(input[line] + '\\n');\n    while (!stream.eol()) {\n      const token = parser.token(stream, state);\n      const string = stream.current();\n\n      if (\n        lPos + stream.getStartOfToken() + 1 <= cursorPosition &&\n        lPos + stream.getCurrentPosition() >= cursorPosition\n      ) {\n        foundToken = prevToken\n          ? prevToken\n          : {\n              line,\n              start: stream.getStartOfToken() + 1,\n              end: stream.getCurrentPosition(),\n              string,\n              state,\n              tokenKind: token,\n            };\n        break;\n      } else if (string === 'on') {\n        prevToken = {\n          line,\n          start: stream.getStartOfToken() + 1,\n          end: stream.getCurrentPosition(),\n          string,\n          state,\n          tokenKind: token,\n        };\n      } else if (string === '.' || string === '..') {\n        prevToken = {\n          line,\n          start: stream.getStartOfToken() + 1,\n          end: stream.getCurrentPosition(),\n          string,\n          state,\n          tokenKind: token,\n        };\n      } else {\n        prevToken = undefined;\n      }\n    }\n\n    cPos += input[line]!.length + 1;\n  }\n\n  return foundToken;\n};\n","import {\n  CompletionItem,\n  CompletionItemKind,\n  ContextToken,\n  ContextTokenUnion,\n  Maybe,\n  RuleKinds,\n  getDefinitionState,\n} from 'graphql-language-service';\nimport {\n  FragmentDefinitionNode,\n  GraphQLArgument,\n  GraphQLCompositeType,\n  GraphQLDirective,\n  GraphQLEnumValue,\n  GraphQLField,\n  GraphQLInputFieldMap,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLSchema,\n  GraphQLType,\n  doTypesOverlap,\n  isCompositeType,\n} from 'graphql';\n\n/**\n * This part is vendored from https://github.com/graphql/graphiql/blob/main/packages/graphql-language-service/src/interface/autocompleteUtils.ts#L97\n */\ntype CompletionItemBase = {\n  label: string;\n  isDeprecated?: boolean;\n};\n\n// Create the expected hint response given a possible list and a token\nfunction hintList<T extends CompletionItemBase>(\n  token: ContextTokenUnion,\n  list: Array<T>\n): Array<T> {\n  return filterAndSortList(list, normalizeText(token.string));\n}\n\n// Given a list of hint entries and currently typed text, sort and filter to\n// provide a concise list.\nfunction filterAndSortList<T extends CompletionItemBase>(\n  list: Array<T>,\n  text: string\n): Array<T> {\n  if (!text) {\n    return filterNonEmpty<T>(list, entry => !entry.isDeprecated);\n  }\n\n  const byProximity = list.map(entry => ({\n    proximity: getProximity(normalizeText(entry.label), text),\n    entry,\n  }));\n\n  return filterNonEmpty(\n    filterNonEmpty(byProximity, pair => pair.proximity <= 2),\n    pair => !pair.entry.isDeprecated\n  )\n    .sort(\n      (a, b) =>\n        (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) ||\n        a.proximity - b.proximity ||\n        a.entry.label.length - b.entry.label.length\n    )\n    .map(pair => pair.entry);\n}\n\n// Filters the array by the predicate, unless it results in an empty array,\n// in which case return the original array.\nfunction filterNonEmpty<T>(\n  array: Array<T>,\n  predicate: (entry: T) => boolean\n): Array<T> {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\n\nfunction normalizeText(text: string): string {\n  return text.toLowerCase().replace(/\\W/g, '');\n}\n\n// Determine a numeric proximity for a suggestion based on current text.\nfunction getProximity(suggestion: string, text: string): number {\n  // start with lexical distance\n  let proximity = lexicalDistance(text, suggestion);\n  if (suggestion.length > text.length) {\n    // do not penalize long suggestions.\n    proximity -= suggestion.length - text.length - 1;\n    // penalize suggestions not starting with this phrase\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\n\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number\n * of edits needed to transform string A into string B. An edit can be an\n * insertion, deletion, or substitution of a single character, or a swap of two\n * adjacent characters.\n *\n * This distance can be useful for detecting typos in input or sorting\n *\n * @param {string} a\n * @param {string} b\n * @return {int} distance in number of edits\n */\nfunction lexicalDistance(a: string, b: string): number {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n\n  for (j = 1; j <= bLength; j++) {\n    d[0]![j] = j;\n  }\n\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n\n      d[i]![j] = Math.min(\n        d[i - 1]![j]! + 1,\n        d[i]![j - 1]! + 1,\n        d[i - 1]![j - 1]! + cost\n      );\n\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i]![j] = Math.min(d[i]![j]!, d[i - 2]![j - 2]! + cost);\n      }\n    }\n  }\n\n  return d[aLength]![bLength]!;\n}\n\nexport type AllTypeInfo = {\n  type: Maybe<GraphQLType>;\n  parentType: Maybe<GraphQLType>;\n  inputType: Maybe<GraphQLType>;\n  directiveDef: Maybe<GraphQLDirective>;\n  fieldDef: Maybe<GraphQLField<any, any>>;\n  enumValue: Maybe<GraphQLEnumValue>;\n  argDef: Maybe<GraphQLArgument>;\n  argDefs: Maybe<GraphQLArgument[]>;\n  objectFieldDefs: Maybe<GraphQLInputFieldMap>;\n  interfaceDef: Maybe<GraphQLInterfaceType>;\n  objectTypeDef: Maybe<GraphQLObjectType>;\n};\n\n/**\n * This is vendored from https://github.com/graphql/graphiql/blob/main/packages/graphql-language-service/src/interface/getAutocompleteSuggestions.ts#L779\n */\nexport function getSuggestionsForFragmentSpread(\n  token: ContextToken,\n  typeInfo: AllTypeInfo,\n  schema: GraphQLSchema,\n  queryText: string,\n  fragments: FragmentDefinitionNode[]\n): Array<CompletionItem> {\n  if (!queryText) {\n    return [];\n  }\n\n  const typeMap = schema.getTypeMap();\n  const defState = getDefinitionState(token.state);\n\n  // Filter down to only the fragments which may exist here.\n  const relevantFrags = fragments.filter(\n    frag =>\n      // Only include fragments with known types.\n      typeMap[frag.typeCondition.name.value] &&\n      // Only include fragments which are not cyclic.\n      !(\n        defState &&\n        defState.kind === RuleKinds.FRAGMENT_DEFINITION &&\n        defState.name === frag.name.value\n      ) &&\n      // Only include fragments which could possibly be spread here.\n      isCompositeType(typeInfo.parentType) &&\n      isCompositeType(typeMap[frag.typeCondition.name.value]) &&\n      doTypesOverlap(\n        schema,\n        typeInfo.parentType,\n        typeMap[frag.typeCondition.name.value] as GraphQLCompositeType\n      )\n  );\n\n  return hintList(\n    token,\n    relevantFrags.map(frag => ({\n      label: frag.name.value,\n      detail: String(typeMap[frag.typeCondition.name.value]),\n      documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n      kind: CompletionItemKind.Field,\n      type: typeMap[frag.typeCondition.name.value],\n    }))\n  );\n}\n","import { ts } from './ts';\n\nimport {\n  getAutocompleteSuggestions,\n  getTokenAtPosition,\n  getTypeInfo,\n  RuleKinds,\n  State,\n  RuleKind,\n  CompletionItem,\n  onlineParser,\n  CharacterStream,\n  ContextToken,\n} from 'graphql-language-service';\nimport { FragmentDefinitionNode, GraphQLSchema, Kind, parse } from 'graphql';\nimport { print } from '@0no-co/graphql.web';\n\nimport * as checks from './ast/checks';\nimport {\n  bubbleUpCallExpression,\n  bubbleUpTemplate,\n  findNode,\n  getAllFragments,\n  getSource,\n} from './ast';\nimport { Cursor } from './ast/cursor';\nimport { resolveTemplate } from './ast/resolve';\nimport { getToken } from './ast/token';\nimport { getSuggestionsForFragmentSpread } from './graphql/getFragmentSpreadSuggestions';\nimport { SchemaRef } from './graphql/getSchema';\n\nexport function getGraphQLCompletions(\n  filename: string,\n  cursorPosition: number,\n  schema: SchemaRef,\n  info: ts.server.PluginCreateInfo\n): ts.WithMetadata<ts.CompletionInfo> | undefined {\n  const isCallExpression = info.config.templateIsCallExpression ?? true;\n  const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n  const source = getSource(info, filename);\n  if (!source) return undefined;\n\n  let node = findNode(source, cursorPosition);\n  if (!node) return undefined;\n\n  node = isCallExpression\n    ? bubbleUpCallExpression(node)\n    : bubbleUpTemplate(node);\n\n  let text, cursor, schemaToUse: GraphQLSchema | undefined;\n  if (isCallExpression && checks.isGraphQLCall(node, typeChecker)) {\n    const schemaName = checks.getSchemaName(node, typeChecker);\n\n    schemaToUse =\n      schemaName && schema.multi[schemaName]\n        ? schema.multi[schemaName]?.schema\n        : schema.current?.schema;\n\n    const foundToken = getToken(node.arguments[0], cursorPosition);\n    if (\n      !schemaToUse ||\n      !foundToken ||\n      foundToken.string === '.' ||\n      foundToken.string === '..'\n    )\n      return undefined;\n\n    const queryText = node.arguments[0].getText().slice(1, -1);\n    const fragments = getAllFragments(node, info);\n\n    text = `${queryText}\\n${fragments.map(x => print(x)).join('\\n')}`;\n    cursor = new Cursor(foundToken.line, foundToken.start - 1);\n  } else if (!isCallExpression && checks.isGraphQLTag(node)) {\n    const foundToken = getToken(node.template, cursorPosition);\n    if (\n      !foundToken ||\n      !schema.current ||\n      foundToken.string === '.' ||\n      foundToken.string === '..'\n    )\n      return undefined;\n\n    const { combinedText, resolvedSpans } = resolveTemplate(\n      node,\n      filename,\n      info\n    );\n\n    const amountOfLines = resolvedSpans\n      .filter(\n        x =>\n          x.original.start < cursorPosition &&\n          x.original.start + x.original.length < cursorPosition\n      )\n      .reduce((acc, span) => acc + (span.lines - 1), 0);\n\n    foundToken.line = foundToken.line + amountOfLines;\n\n    text = combinedText;\n    cursor = new Cursor(foundToken.line, foundToken.start - 1);\n    schemaToUse = schema.current.schema;\n  } else {\n    return undefined;\n  }\n\n  const [suggestions, spreadSuggestions] = getSuggestionsInternal(\n    schemaToUse,\n    text,\n    cursor\n  );\n\n  return {\n    isGlobalCompletion: false,\n    isMemberCompletion: false,\n    isNewIdentifierLocation: false,\n    entries: [\n      ...suggestions.map(suggestion => ({\n        ...suggestion,\n        kind: ts.ScriptElementKind.variableElement,\n        name: suggestion.label,\n        kindModifiers: 'declare',\n        sortText: suggestion.sortText || '0',\n        labelDetails: {\n          detail: suggestion.type\n            ? ' ' + suggestion.type?.toString()\n            : undefined,\n          description: suggestion.documentation,\n        },\n      })),\n      ...spreadSuggestions.map(suggestion => ({\n        ...suggestion,\n        kind: ts.ScriptElementKind.variableElement,\n        name: suggestion.label,\n        insertText: '...' + suggestion.label,\n        kindModifiers: 'declare',\n        sortText: '0',\n        labelDetails: {\n          description: suggestion.documentation,\n        },\n      })),\n    ],\n  };\n}\n\nexport function getSuggestionsInternal(\n  schema: GraphQLSchema,\n  queryText: string,\n  cursor: Cursor\n): [CompletionItem[], CompletionItem[]] {\n  const token = getTokenAtPosition(queryText, cursor);\n\n  let fragments: Array<FragmentDefinitionNode> = [];\n  try {\n    const parsed = parse(queryText, { noLocation: true });\n    fragments = parsed.definitions.filter(\n      x => x.kind === Kind.FRAGMENT_DEFINITION\n    ) as Array<FragmentDefinitionNode>;\n  } catch (e) {}\n\n  const isOnTypeCondition =\n    token.string === 'on' && token.state.kind === 'TypeCondition';\n  let suggestions = getAutocompleteSuggestions(\n    schema,\n    queryText,\n    cursor,\n    isOnTypeCondition\n      ? {\n          ...token,\n          state: {\n            ...token.state,\n            step: 1,\n          },\n          type: null,\n        }\n      : undefined\n  );\n  let spreadSuggestions = !isOnTypeCondition\n    ? getSuggestionsForFragmentSpread(\n        token,\n        getTypeInfo(schema, token.state),\n        schema,\n        queryText,\n        fragments\n      )\n    : [];\n\n  const state =\n    token.state.kind === 'Invalid' ? token.state.prevState : token.state;\n  const parentName = getParentDefinition(token.state, RuleKinds.FIELD)?.name;\n\n  if (state && parentName) {\n    const { kind } = state;\n\n    // Argument names\n    if (kind === RuleKinds.ARGUMENTS || kind === RuleKinds.ARGUMENT) {\n      const usedArguments = new Set<String>();\n\n      runOnlineParser(queryText, (_, state) => {\n        if (state.kind === RuleKinds.ARGUMENT) {\n          const parentDefinition = getParentDefinition(state, RuleKinds.FIELD);\n          if (\n            parentName &&\n            state.name &&\n            parentDefinition?.name === parentName\n          ) {\n            usedArguments.add(state.name);\n          }\n        }\n      });\n\n      suggestions = suggestions.filter(\n        suggestion => !usedArguments.has(suggestion.label)\n      );\n    }\n\n    // Field names\n    if (\n      kind === RuleKinds.SELECTION_SET ||\n      kind === RuleKinds.FIELD ||\n      kind === RuleKinds.ALIASED_FIELD\n    ) {\n      const usedFields = new Set<string>();\n      const usedFragments = getUsedFragments(queryText, parentName);\n\n      runOnlineParser(queryText, (_, state) => {\n        if (\n          state.kind === RuleKinds.FIELD ||\n          state.kind === RuleKinds.ALIASED_FIELD\n        ) {\n          const parentDefinition = getParentDefinition(state, RuleKinds.FIELD);\n          if (\n            parentDefinition &&\n            parentDefinition.name === parentName &&\n            state.name\n          ) {\n            usedFields.add(state.name);\n          }\n        }\n      });\n\n      suggestions = suggestions.filter(\n        suggestion => !usedFields.has(suggestion.label)\n      );\n      spreadSuggestions = spreadSuggestions.filter(\n        suggestion => !usedFragments.has(suggestion.label)\n      );\n    }\n\n    // Fragment spread names\n    if (kind === RuleKinds.FRAGMENT_SPREAD) {\n      const usedFragments = getUsedFragments(queryText, parentName);\n      suggestions = suggestions.filter(\n        suggestion => !usedFragments.has(suggestion.label)\n      );\n      spreadSuggestions = spreadSuggestions.filter(\n        suggestion => !usedFragments.has(suggestion.label)\n      );\n    }\n  }\n\n  return [suggestions, spreadSuggestions];\n}\n\nfunction getUsedFragments(queryText: string, parentName: string | undefined) {\n  const usedFragments = new Set<string>();\n\n  runOnlineParser(queryText, (_, state) => {\n    if (state.kind === RuleKinds.FRAGMENT_SPREAD && state.name) {\n      const parentDefinition = getParentDefinition(state, RuleKinds.FIELD);\n      if (parentName && parentDefinition?.name === parentName) {\n        usedFragments.add(state.name);\n      }\n    }\n  });\n\n  return usedFragments;\n}\n\n/**\n * This is vendored from https://github.com/graphql/graphiql/blob/aeedf7614e422c783f5cfb5e226c5effa46318fd/packages/graphql-language-service/src/interface/getAutocompleteSuggestions.ts#L831\n */\nfunction getParentDefinition(state: State, kind: RuleKind) {\n  if (state.prevState?.kind === kind) {\n    return state.prevState;\n  }\n  if (state.prevState?.prevState?.kind === kind) {\n    return state.prevState.prevState;\n  }\n  if (state.prevState?.prevState?.prevState?.kind === kind) {\n    return state.prevState.prevState.prevState;\n  }\n  if (state.prevState?.prevState?.prevState?.prevState?.kind === kind) {\n    return state.prevState.prevState.prevState.prevState;\n  }\n}\n\nfunction runOnlineParser(\n  queryText: string,\n  callback: (\n    stream: CharacterStream,\n    state: State,\n    style: string,\n    index: number\n  ) => void | 'BREAK'\n): ContextToken {\n  const lines = queryText.split('\\n');\n  const parser = onlineParser();\n  let state = parser.startState();\n  let style = '';\n\n  let stream: CharacterStream = new CharacterStream('');\n\n  for (let i = 0; i < lines.length; i++) {\n    stream = new CharacterStream(lines[i]!);\n    while (!stream.eol()) {\n      style = parser.token(stream, state);\n      const code = callback(stream, state, style, i);\n      if (code === 'BREAK') {\n        break;\n      }\n    }\n\n    // Above while loop won't run if there is an empty line.\n    // Run the callback one more time to catch this.\n    callback(stream, state, style, i);\n\n    if (!state.kind) {\n      state = parser.startState();\n    }\n  }\n\n  return {\n    start: stream.getStartOfToken(),\n    end: stream.getCurrentPosition(),\n    string: stream.current(),\n    state,\n    style,\n  };\n}\n","import type { SchemaOrigin } from '@gql.tada/internal';\n\nimport { ts, init as initTypeScript } from './ts';\nimport { loadSchema } from './graphql/getSchema';\nimport { getGraphQLCompletions } from './autoComplete';\nimport { getGraphQLQuickInfo } from './quickInfo';\nimport { ALL_DIAGNOSTICS, getGraphQLDiagnostics } from './diagnostics';\nimport { templates } from './ast/templates';\nimport { getPersistedCodeFixAtPosition } from './persisted';\n\nfunction createBasicDecorator(info: ts.server.PluginCreateInfo) {\n  const proxy: ts.LanguageService = Object.create(null);\n  for (let k of Object.keys(info.languageService) as Array<\n    keyof ts.LanguageService\n  >) {\n    const x = info.languageService[k]!;\n    // @ts-expect-error - JS runtime trickery which is tricky to type tersely\n    proxy[k] = (...args: Array<{}>) => x.apply(info.languageService, args);\n  }\n\n  return proxy;\n}\n\nexport type Logger = (msg: string) => void;\n\ninterface Config {\n  schema: SchemaOrigin;\n  schemas: SchemaOrigin[];\n  tadaDisablePreprocessing?: boolean;\n  templateIsCallExpression?: boolean;\n  shouldCheckForColocatedFragments?: boolean;\n  template?: string;\n  clientDirectives?: string[];\n  trackFieldUsage?: boolean;\n  tadaOutputLocation?: string;\n}\n\nfunction create(info: ts.server.PluginCreateInfo) {\n  const logger: Logger = (msg: string) =>\n    info.project.projectService.logger.info(`[GraphQLSP] ${msg}`);\n  const config: Config = info.config;\n\n  logger('config: ' + JSON.stringify(config));\n  if (!config.schema && !config.schemas) {\n    logger('Missing \"schema\" option in configuration.');\n    throw new Error('Please provide a GraphQL Schema!');\n  }\n\n  logger('Setting up the GraphQL Plugin');\n\n  if (config.template) {\n    templates.add(config.template);\n  }\n\n  const proxy = createBasicDecorator(info);\n\n  const schema = loadSchema(info, config, logger);\n\n  proxy.getSemanticDiagnostics = (filename: string): ts.Diagnostic[] => {\n    const originalDiagnostics =\n      info.languageService.getSemanticDiagnostics(filename);\n\n    const hasGraphQLDiagnostics = originalDiagnostics.some(x =>\n      ALL_DIAGNOSTICS.includes(x.code)\n    );\n    if (hasGraphQLDiagnostics) return originalDiagnostics;\n\n    const graphQLDiagnostics = getGraphQLDiagnostics(filename, schema, info);\n\n    return graphQLDiagnostics\n      ? [...graphQLDiagnostics, ...originalDiagnostics]\n      : originalDiagnostics;\n  };\n\n  proxy.getCompletionsAtPosition = (\n    filename: string,\n    cursorPosition: number,\n    options: any\n  ): ts.WithMetadata<ts.CompletionInfo> | undefined => {\n    const completions = getGraphQLCompletions(\n      filename,\n      cursorPosition,\n      schema,\n      info\n    );\n\n    if (completions && completions.entries.length) {\n      return completions;\n    } else {\n      return (\n        info.languageService.getCompletionsAtPosition(\n          filename,\n          cursorPosition,\n          options\n        ) || {\n          isGlobalCompletion: false,\n          isMemberCompletion: false,\n          isNewIdentifierLocation: false,\n          entries: [],\n        }\n      );\n    }\n  };\n\n  proxy.getEditsForRefactor = (\n    filename,\n    formatOptions,\n    positionOrRange,\n    refactorName,\n    actionName,\n    preferences,\n    interactive\n  ) => {\n    const original = info.languageService.getEditsForRefactor(\n      filename,\n      formatOptions,\n      positionOrRange,\n      refactorName,\n      actionName,\n      preferences,\n      interactive\n    );\n\n    const codefix = getPersistedCodeFixAtPosition(\n      filename,\n      typeof positionOrRange === 'number'\n        ? positionOrRange\n        : positionOrRange.pos,\n      info\n    );\n    if (!codefix) return original;\n    return {\n      edits: [\n        {\n          fileName: filename,\n          textChanges: [{ newText: codefix.replacement, span: codefix.span }],\n        },\n      ],\n    };\n  };\n\n  proxy.getApplicableRefactors = (\n    filename,\n    positionOrRange,\n    preferences,\n    reason,\n    kind,\n    includeInteractive\n  ) => {\n    const original = info.languageService.getApplicableRefactors(\n      filename,\n      positionOrRange,\n      preferences,\n      reason,\n      kind,\n      includeInteractive\n    );\n\n    const codefix = getPersistedCodeFixAtPosition(\n      filename,\n      typeof positionOrRange === 'number'\n        ? positionOrRange\n        : positionOrRange.pos,\n      info\n    );\n\n    if (codefix) {\n      return [\n        {\n          name: 'GraphQL',\n          description: 'Operations specific to gql.tada!',\n          actions: [\n            {\n              name: 'Insert document-id',\n              description:\n                'Generate a document-id for your persisted-operation, by default a SHA256 hash.',\n            },\n          ],\n          inlineable: true,\n        },\n        ...original,\n      ];\n    } else {\n      return original;\n    }\n  };\n\n  proxy.getQuickInfoAtPosition = (filename: string, cursorPosition: number) => {\n    const quickInfo = getGraphQLQuickInfo(\n      filename,\n      cursorPosition,\n      schema,\n      info\n    );\n\n    if (quickInfo) return quickInfo;\n\n    return info.languageService.getQuickInfoAtPosition(\n      filename,\n      cursorPosition\n    );\n  };\n\n  logger('proxy: ' + JSON.stringify(proxy));\n\n  return proxy;\n}\n\nconst init: ts.server.PluginModuleFactory = ts => {\n  initTypeScript(ts);\n  return { create };\n};\n\nexport default init;\n","import { ts } from './ts';\nimport { getHoverInformation } from 'graphql-language-service';\nimport { GraphQLSchema } from 'graphql';\n\nimport {\n  bubbleUpCallExpression,\n  bubbleUpTemplate,\n  findNode,\n  getSchemaName,\n  getSource,\n} from './ast';\n\nimport * as checks from './ast/checks';\nimport { resolveTemplate } from './ast/resolve';\nimport { getToken } from './ast/token';\nimport { Cursor } from './ast/cursor';\nimport { SchemaRef } from './graphql/getSchema';\n\nexport function getGraphQLQuickInfo(\n  filename: string,\n  cursorPosition: number,\n  schema: SchemaRef,\n  info: ts.server.PluginCreateInfo\n): ts.QuickInfo | undefined {\n  const isCallExpression = info.config.templateIsCallExpression ?? true;\n  const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n\n  const source = getSource(info, filename);\n  if (!source) return undefined;\n\n  let node = findNode(source, cursorPosition);\n  if (!node) return undefined;\n\n  node = isCallExpression\n    ? bubbleUpCallExpression(node)\n    : bubbleUpTemplate(node);\n\n  let cursor, text, schemaToUse: GraphQLSchema | undefined;\n  if (isCallExpression && checks.isGraphQLCall(node, typeChecker)) {\n    const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n    const schemaName = getSchemaName(node, typeChecker);\n\n    schemaToUse =\n      schemaName && schema.multi[schemaName]\n        ? schema.multi[schemaName]?.schema\n        : schema.current?.schema;\n\n    const foundToken = getToken(node.arguments[0], cursorPosition);\n    if (!schemaToUse || !foundToken) return undefined;\n\n    text = node.arguments[0].getText();\n    cursor = new Cursor(foundToken.line, foundToken.start - 1);\n  } else if (!isCallExpression && checks.isGraphQLTag(node)) {\n    const foundToken = getToken(node.template, cursorPosition);\n    if (!foundToken || !schema.current) return undefined;\n\n    const { combinedText, resolvedSpans } = resolveTemplate(\n      node,\n      filename,\n      info\n    );\n\n    const amountOfLines = resolvedSpans\n      .filter(\n        x =>\n          x.original.start < cursorPosition &&\n          x.original.start + x.original.length < cursorPosition\n      )\n      .reduce((acc, span) => acc + (span.lines - 1), 0);\n\n    foundToken.line = foundToken.line + amountOfLines;\n    text = combinedText;\n    cursor = new Cursor(foundToken.line, foundToken.start - 1);\n    schemaToUse = schema.current.schema;\n  } else {\n    return undefined;\n  }\n\n  const hoverInfo = getHoverInformation(schemaToUse, text, cursor);\n\n  return {\n    kind: ts.ScriptElementKind.label,\n    textSpan: {\n      start: cursorPosition,\n      length: 1,\n    },\n    kindModifiers: 'text',\n    documentation: Array.isArray(hoverInfo)\n      ? hoverInfo.map(item => ({ kind: 'text', text: item as string }))\n      : [{ kind: 'text', text: hoverInfo as string }],\n  } as ts.QuickInfo;\n}\n"],"names":["statFile","file","predicate","fs","stat","then","catch","swapWrite","async","target","contents","isFile","writeFile","tempTarget","rename","error","unlink","now","Date","utimes","_error","touchFile","saveTadaIntrospection","introspection","tadaOutputLocation","disablePreprocessing","logger","minified","minifyIntrospection","outputIntrospectionFile","fileType","shouldPreprocess","output","isDirectory","path","join","p","mkdir","dirname","recursive","getDefinitionState","tokenState","definitionState","forEachState","state","kind","getFieldDef","schema","type","fieldName","SchemaMetaFieldDef","name","getQueryType","TypeMetaFieldDef","TypeNameMetaFieldDef","isCompositeType","getFields","stack","fn","reverseStateStack","push","prevState","i","length","objectValues","object","keys","Object","len","values","Array","hintList","token","list","filterAndSortList","text","filterNonEmpty","entry","isDeprecated","byProximity","map","proximity","getProximity","normalizeText","label","pair","sort","a","b","string","array","filtered","filter","toLowerCase","replaceAll","suggestion","lexicalDistance","j","d","aLength","bLength","cost","Math","min","indexOf","DocumentUri","is","value","URI","integer","MIN_VALUE","MAX_VALUE","uinteger","Position","create","line","character","Number","candidate","Is","objectLiteral","Range","one","two","three","four","start","end","Error","Location","uri","range","undefined","LocationLink","targetUri","targetRange","targetSelectionRange","originSelectionRange","Color","red","green","blue","alpha","numberRange","ColorInformation","color","ColorPresentation","textEdit","additionalTextEdits","TextEdit","typedArray","FoldingRangeKind","Comment","Imports","Region","FoldingRange","startLine","endLine","startCharacter","endCharacter","collapsedText","result","defined","DiagnosticRelatedInformation","location","message","DiagnosticSeverity","Warning","Information","Hint","DiagnosticTag","Unnecessary","Deprecated","CodeDescription","href","Diagnostic","severity","code","source","relatedInformation","_a","number","codeDescription","Command","title","command","args","arguments","replace","newText","insert","position","del","ChangeAnnotation","needsConfirmation","description","boolean","ChangeAnnotationIdentifier","AnnotatedTextEdit","annotation","annotationId","TextDocumentEdit","textDocument","edits","OptionalVersionedTextDocumentIdentifier","isArray","CreateFile","options","overwrite","ignoreIfExists","RenameFile","oldUri","newUri","DeleteFile","ignoreIfNotExists","WorkspaceEdit","changes","documentChanges","every","change","TextDocumentIdentifier","VersionedTextDocumentIdentifier","version","TextDocumentItem","languageId","MarkupKind","PlainText","Markdown","MarkupContent","CompletionItemKind","Text","Method","Function","Constructor","Field","Variable","Class","Interface","Module","Property","Unit","Value","Enum","Keyword","Snippet","File","Reference","Folder","EnumMember","Constant","Struct","Event","Operator","TypeParameter","InsertTextFormat","CompletionItemTag","InsertReplaceEdit","InsertTextMode","asIs","adjustIndentation","CompletionItemLabelDetails","detail","CompletionItem","CompletionList","items","isIncomplete","MarkedString","fromPlainText","plainText","language","Hover","ParameterInformation","documentation","SignatureInformation","parameters","DocumentHighlightKind","Read","Write","DocumentHighlight","SymbolKind","Namespace","Package","String","Boolean","Key","Null","SymbolTag","SymbolInformation","containerName","WorkspaceSymbol","DocumentSymbol","selectionRange","children","deprecated","tags","CodeActionKind","Empty","QuickFix","Refactor","RefactorExtract","RefactorInline","RefactorRewrite","Source","SourceOrganizeImports","SourceFixAll","CodeActionTriggerKind","Invoked","Automatic","CodeActionContext","diagnostics","only","triggerKind","CodeAction","kindOrCommandOrEdit","checkKind","edit","isPreferred","CodeLens","data","FormattingOptions","tabSize","insertSpaces","DocumentLink","SelectionRange","parent","SemanticTokenTypes","SemanticTokenModifiers","SemanticTokens","resultId","InlineValueText","InlineValueVariableLookup","variableName","caseSensitiveLookup","InlineValueEvaluatableExpression","expression","InlineValueContext","frameId","stoppedLocation","InlayHintKind","Type","Parameter","InlayHintLabelPart","tooltip","InlayHint","textEdits","paddingLeft","paddingRight","StringValue","createSnippet","InlineCompletionItem","insertText","filterText","InlineCompletionList","InlineCompletionTriggerKind","SelectedCompletionInfo","InlineCompletionContext","selectedCompletionInfo","WorkspaceFolder","TextDocument","content","FullTextDocument","lineCount","func","getText","positionAt","offsetAt","applyEdits","document","sortedEdits","mergeSort","diff","lastModifiedOffset","e","startOffset","endOffset","substring","compare","left","slice","right","leftIdx","rightIdx","constructor","this","_uri","_languageId","_version","_content","_lineOffsets","update","event","getLineOffsets","lineOffsets","isLineStart","ch","charAt","offset","max","low","high","mid","floor","lineOffset","toString","prototype","call","check","RuleKinds","assign","Kind","ALIASED_FIELD","ARGUMENTS","SHORT_QUERY","QUERY","MUTATION","SUBSCRIPTION","TYPE_CONDITION","INVALID","COMMENT","SCHEMA_DEF","SCALAR_DEF","OBJECT_TYPE_DEF","OBJECT_VALUE","LIST_VALUE","INTERFACE_DEF","UNION_DEF","ENUM_DEF","ENUM_VALUE","FIELD_DEF","INPUT_DEF","INPUT_VALUE_DEF","ARGUMENTS_DEF","EXTEND_DEF","EXTENSION_DEFINITION","DIRECTIVE_DEF","IMPLEMENTS","VARIABLE_DEFINITIONS","TYPE","SuggestionCommand","typeSystemKinds","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","DIRECTIVE_DEFINITION","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","getAutocompleteSuggestions","queryText","cursor","contextToken","fragmentDefs","opts","getTokenAtPosition","mode","getDocumentMode","documentText","endsWith","GraphQLDocumentMode","TYPE_SYSTEM","sdl","hasTypeSystemDef","visit","parse","enter","node","includes","BREAK","hasTypeSystemDefinitions","EXECUTABLE","step","typeInfo","getTypeInfo","DOCUMENT","getSuggestionsForTypeSystemDefinitions","getSuggestionsForExecutableDefinitions","getSuggestionsForExtensionDefinitions","getTypeMap","isScalarType","isObjectType","startsWith","isInterfaceType","isUnionType","isEnumType","isInputObjectType","NAMED_TYPE","getSuggestionsForImplements","needsSeparator","typeMap","schemaInterfaces","schemaInterfaceNames","inlineInterfaces","Set","runOnlineParser","_","add","interfaceDef","_b","getInterfaces","find","getType","interfaceConfig","_c","toConfig","GraphQLInterfaceType","interfaces","fields","objectTypeDef","_d","objectTypeConfig","_e","GraphQLObjectType","currentTypeToExtend","siblingInterfaceNames","possibleInterfaces","concat","SELECTION_SET","FIELD","getSuggestionsForFieldNames","parentType","field","index","sortText","deprecationReason","fillLeafsOnComplete","getInsertText","insertTextFormat","ARGUMENT","argDefs","argDef","OBJECT_FIELD","objectFieldDefs","objectFields","completionKind","getSuggestionsForInputValues","namedInputType","getNamedType","inputType","queryVariables","getVariableCompletions","v","GraphQLEnumType","getValues","GraphQLBoolean","VARIABLE","getSuggestionsForFragmentTypeConditions","_kind","possibleTypes","isAbstractType","abstractType","assertAbstractType","possibleObjTypes","getPossibleTypes","possibleIfaceMap","iface","namedType","FRAGMENT_SPREAD","getSuggestionsForFragmentSpread","defState","fragments","getFragmentDefinitions","FRAGMENT_DEFINITION","NAME","selectionSet","selections","typeCondition","relevantFrags","frag","doTypesOverlap","op","externalFragments","FragmentDefinition","def","collectFragmentDefs","unwrappedState","unwrapType","needsAdvance","LIST_TYPE","isOutputType","isInputType","VARIABLE_DEFINITION","NON_NULL_TYPE","getSuggestionsForVariableDefinition","inputTypeMap","inputTypes","DIRECTIVE","getSuggestionsForDirective","directives","getDirectives","directive","canUseDirective","locations","DirectiveLocation","INLINE_FRAGMENT","SCHEMA","SCALAR","OBJECT","FIELD_DEFINITION","INTERFACE","UNION","ENUM","INPUT_OBJECT","ARGUMENT_DEFINITION","INPUT_FIELD_DEFINITION","insertSuffix","isListType","ofType","isNonNullType","getParentDefinition","_f","_k","_j","_h","_g","variableType","definitions","parentDefinition","styleAtCursor","stateAtCursor","stringAtCursor","stream","style","getCurrentPosition","current","callback","lines","split","parser","onlineParser","startState","CharacterStream","eol","getStartOfToken","directiveDef","enumValue","fieldDef","getMutationType","getSubscriptionType","getDirective","enumType","val","nullableType","getNullableType","GraphQLList","objectType","GraphQLInputObjectType","objectField","getHoverInformation","config","into","renderMdCodeStart","renderField","renderQualifiedField","renderTypeAnnotation","renderMdCodeEnd","renderDescription","trim","renderDirective","renderArg","renderEnumValue","renderType","useMarkdown","_options","t","GraphQLNonNull","renderDeprecation","reason","Cursor","char","setLine","setCharacter","lessThanOrEqualTo","getToken","template","cursorPosition","ts","isTemplateLiteral","isStringLiteralLike","input","cPos","getStart","foundToken","prevToken","lPos","tokenKind","getGraphQLCompletions","filename","info","isCallExpression","templateIsCallExpression","typeChecker","languageService","getProgram","getTypeChecker","getSource","findNode","bubbleUpCallExpression","bubbleUpTemplate","schemaToUse","checks","schemaName","multi","getAllFragments","x","print","combinedText","resolvedSpans","resolveTemplate","amountOfLines","original","reduce","acc","span","suggestions","spreadSuggestions","getSuggestionsInternal","noLocation","isOnTypeCondition","parentName","usedArguments","has","usedFields","usedFragments","getUsedFragments","isGlobalCompletion","isMemberCompletion","isNewIdentifierLocation","entries","ScriptElementKind","variableElement","kindModifiers","labelDetails","msg","project","projectService","JSON","stringify","schemas","templates","proxy","createBasicDecorator","_loop","k","apply","loadSchema","origin","ref","loadRef","rootPath","resolveTypeScriptRootDir","getProjectName","tadaDisablePreprocessing","resolve","load","forEach","autoupdate","schemaRef","found","getSemanticDiagnostics","originalDiagnostics","some","ALL_DIAGNOSTICS","graphQLDiagnostics","getGraphQLDiagnostics","getCompletionsAtPosition","completions","getEditsForRefactor","formatOptions","positionOrRange","refactorName","actionName","preferences","interactive","codefix","getPersistedCodeFixAtPosition","pos","fileName","textChanges","replacement","getApplicableRefactors","includeInteractive","actions","inlineable","getQuickInfoAtPosition","quickInfo","getGraphQLQuickInfo","getSchemaName","hoverInfo","textSpan","item","init","initTypeScript"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6]}