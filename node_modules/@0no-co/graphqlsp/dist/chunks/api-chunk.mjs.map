{"version":3,"file":"api-chunk.mjs","sources":["../../src/ts/index.js","../../../../node_modules/.pnpm/graphql-language-service@5.2.0_graphql@16.8.1/node_modules/graphql-language-service/esm/parser/CharacterStream.js","../../../../node_modules/.pnpm/graphql-language-service@5.2.0_graphql@16.8.1/node_modules/graphql-language-service/esm/parser/RuleHelpers.js","../../../../node_modules/.pnpm/graphql-language-service@5.2.0_graphql@16.8.1/node_modules/graphql-language-service/esm/parser/Rules.js","../../../../node_modules/.pnpm/graphql-language-service@5.2.0_graphql@16.8.1/node_modules/graphql-language-service/esm/parser/onlineParser.js","../../../../node_modules/.pnpm/graphql-language-service@5.2.0_graphql@16.8.1/node_modules/graphql-language-service/esm/utils/Range.js","../../../../node_modules/.pnpm/graphql-language-service@5.2.0_graphql@16.8.1/node_modules/graphql-language-service/esm/utils/validateWithCustomRules.js","../../../../node_modules/.pnpm/graphql-language-service@5.2.0_graphql@16.8.1/node_modules/graphql-language-service/esm/interface/getDiagnostics.js","../../../../node_modules/.pnpm/@0no-co+graphql.web@1.0.4_graphql@16.8.1/node_modules/@0no-co/graphql.web/dist/graphql.web.mjs","../../src/ast/templates.ts","../../src/ast/checks.ts","../../src/ast/declaration.ts","../../src/ast/resolve.ts","../../src/ast/index.ts","../../../../node_modules/.pnpm/lru-cache@10.0.1/node_modules/lru-cache/dist/mjs/index.js","../../../../node_modules/.pnpm/@sindresorhus+fnv1a@2.0.0/node_modules/@sindresorhus/fnv1a/index.js","../../src/fieldUsage.ts","../../src/checkImports.ts","../../src/persisted.ts","../../src/diagnostics.ts"],"sourcesContent":["export var ts;\nexport function init(modules) {\n  ts = modules.typescript;\n}\n","export default class CharacterStream {\n    constructor(sourceText) {\n        this._start = 0;\n        this._pos = 0;\n        this.getStartOfToken = () => this._start;\n        this.getCurrentPosition = () => this._pos;\n        this.eol = () => this._sourceText.length === this._pos;\n        this.sol = () => this._pos === 0;\n        this.peek = () => {\n            return this._sourceText.charAt(this._pos) || null;\n        };\n        this.next = () => {\n            const char = this._sourceText.charAt(this._pos);\n            this._pos++;\n            return char;\n        };\n        this.eat = (pattern) => {\n            const isMatched = this._testNextCharacter(pattern);\n            if (isMatched) {\n                this._start = this._pos;\n                this._pos++;\n                return this._sourceText.charAt(this._pos - 1);\n            }\n            return undefined;\n        };\n        this.eatWhile = (match) => {\n            let isMatched = this._testNextCharacter(match);\n            let didEat = false;\n            if (isMatched) {\n                didEat = isMatched;\n                this._start = this._pos;\n            }\n            while (isMatched) {\n                this._pos++;\n                isMatched = this._testNextCharacter(match);\n                didEat = true;\n            }\n            return didEat;\n        };\n        this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n        this.skipToEnd = () => {\n            this._pos = this._sourceText.length;\n        };\n        this.skipTo = (position) => {\n            this._pos = position;\n        };\n        this.match = (pattern, consume = true, caseFold = false) => {\n            let token = null;\n            let match = null;\n            if (typeof pattern === 'string') {\n                const regex = new RegExp(pattern, caseFold ? 'i' : 'g');\n                match = regex.test(this._sourceText.slice(this._pos, this._pos + pattern.length));\n                token = pattern;\n            }\n            else if (pattern instanceof RegExp) {\n                match = this._sourceText.slice(this._pos).match(pattern);\n                token = match === null || match === void 0 ? void 0 : match[0];\n            }\n            if (match != null &&\n                (typeof pattern === 'string' ||\n                    (match instanceof Array &&\n                        this._sourceText.startsWith(match[0], this._pos)))) {\n                if (consume) {\n                    this._start = this._pos;\n                    if (token && token.length) {\n                        this._pos += token.length;\n                    }\n                }\n                return match;\n            }\n            return false;\n        };\n        this.backUp = (num) => {\n            this._pos -= num;\n        };\n        this.column = () => this._pos;\n        this.indentation = () => {\n            const match = this._sourceText.match(/\\s*/);\n            let indent = 0;\n            if (match && match.length !== 0) {\n                const whiteSpaces = match[0];\n                let pos = 0;\n                while (whiteSpaces.length > pos) {\n                    if (whiteSpaces.charCodeAt(pos) === 9) {\n                        indent += 2;\n                    }\n                    else {\n                        indent++;\n                    }\n                    pos++;\n                }\n            }\n            return indent;\n        };\n        this.current = () => this._sourceText.slice(this._start, this._pos);\n        this._sourceText = sourceText;\n    }\n    _testNextCharacter(pattern) {\n        const character = this._sourceText.charAt(this._pos);\n        let isMatched = false;\n        if (typeof pattern === 'string') {\n            isMatched = character === pattern;\n        }\n        else {\n            isMatched =\n                pattern instanceof RegExp\n                    ? pattern.test(character)\n                    : pattern(character);\n        }\n        return isMatched;\n    }\n}\n//# sourceMappingURL=CharacterStream.js.map","export function opt(ofRule) {\n    return { ofRule };\n}\nexport function list(ofRule, separator) {\n    return { ofRule, isList: true, separator };\n}\nexport function butNot(rule, exclusions) {\n    const ruleMatch = rule.match;\n    rule.match = token => {\n        let check = false;\n        if (ruleMatch) {\n            check = ruleMatch(token);\n        }\n        return (check &&\n            exclusions.every(exclusion => exclusion.match && !exclusion.match(token)));\n    };\n    return rule;\n}\nexport function t(kind, style) {\n    return { style, match: (token) => token.kind === kind };\n}\nexport function p(value, style) {\n    return {\n        style: style || 'punctuation',\n        match: (token) => token.kind === 'Punctuation' && token.value === value,\n    };\n}\n//# sourceMappingURL=RuleHelpers.js.map","import { opt, list, butNot, t, p } from './RuleHelpers';\nimport { Kind } from 'graphql';\nexport const isIgnored = (ch) => ch === ' ' ||\n    ch === '\\t' ||\n    ch === ',' ||\n    ch === '\\n' ||\n    ch === '\\r' ||\n    ch === '\\uFEFF' ||\n    ch === '\\u00A0';\nexport const LexRules = {\n    Name: /^[_A-Za-z][_0-9A-Za-z]*/,\n    Punctuation: /^(?:!|\\$|\\(|\\)|\\.\\.\\.|:|=|&|@|\\[|]|\\{|\\||\\})/,\n    Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n    String: /^(?:\"\"\"(?:\\\\\"\"\"|[^\"]|\"[^\"]|\"\"[^\"])*(?:\"\"\")?|\"(?:[^\"\\\\]|\\\\(?:\"|\\/|\\\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?)/,\n    Comment: /^#.*/,\n};\nexport const ParseRules = {\n    Document: [list('Definition')],\n    Definition(token) {\n        switch (token.value) {\n            case '{':\n                return 'ShortQuery';\n            case 'query':\n                return 'Query';\n            case 'mutation':\n                return 'Mutation';\n            case 'subscription':\n                return 'Subscription';\n            case 'fragment':\n                return Kind.FRAGMENT_DEFINITION;\n            case 'schema':\n                return 'SchemaDef';\n            case 'scalar':\n                return 'ScalarDef';\n            case 'type':\n                return 'ObjectTypeDef';\n            case 'interface':\n                return 'InterfaceDef';\n            case 'union':\n                return 'UnionDef';\n            case 'enum':\n                return 'EnumDef';\n            case 'input':\n                return 'InputDef';\n            case 'extend':\n                return 'ExtendDef';\n            case 'directive':\n                return 'DirectiveDef';\n        }\n    },\n    ShortQuery: ['SelectionSet'],\n    Query: [\n        word('query'),\n        opt(name('def')),\n        opt('VariableDefinitions'),\n        list('Directive'),\n        'SelectionSet',\n    ],\n    Mutation: [\n        word('mutation'),\n        opt(name('def')),\n        opt('VariableDefinitions'),\n        list('Directive'),\n        'SelectionSet',\n    ],\n    Subscription: [\n        word('subscription'),\n        opt(name('def')),\n        opt('VariableDefinitions'),\n        list('Directive'),\n        'SelectionSet',\n    ],\n    VariableDefinitions: [p('('), list('VariableDefinition'), p(')')],\n    VariableDefinition: ['Variable', p(':'), 'Type', opt('DefaultValue')],\n    Variable: [p('$', 'variable'), name('variable')],\n    DefaultValue: [p('='), 'Value'],\n    SelectionSet: [p('{'), list('Selection'), p('}')],\n    Selection(token, stream) {\n        return token.value === '...'\n            ? stream.match(/[\\s\\u00a0,]*(on\\b|@|{)/, false)\n                ? 'InlineFragment'\n                : 'FragmentSpread'\n            : stream.match(/[\\s\\u00a0,]*:/, false)\n                ? 'AliasedField'\n                : 'Field';\n    },\n    AliasedField: [\n        name('property'),\n        p(':'),\n        name('qualifier'),\n        opt('Arguments'),\n        list('Directive'),\n        opt('SelectionSet'),\n    ],\n    Field: [\n        name('property'),\n        opt('Arguments'),\n        list('Directive'),\n        opt('SelectionSet'),\n    ],\n    Arguments: [p('('), list('Argument'), p(')')],\n    Argument: [name('attribute'), p(':'), 'Value'],\n    FragmentSpread: [p('...'), name('def'), list('Directive')],\n    InlineFragment: [\n        p('...'),\n        opt('TypeCondition'),\n        list('Directive'),\n        'SelectionSet',\n    ],\n    FragmentDefinition: [\n        word('fragment'),\n        opt(butNot(name('def'), [word('on')])),\n        'TypeCondition',\n        list('Directive'),\n        'SelectionSet',\n    ],\n    TypeCondition: [word('on'), 'NamedType'],\n    Value(token) {\n        switch (token.kind) {\n            case 'Number':\n                return 'NumberValue';\n            case 'String':\n                return 'StringValue';\n            case 'Punctuation':\n                switch (token.value) {\n                    case '[':\n                        return 'ListValue';\n                    case '{':\n                        return 'ObjectValue';\n                    case '$':\n                        return 'Variable';\n                    case '&':\n                        return 'NamedType';\n                }\n                return null;\n            case 'Name':\n                switch (token.value) {\n                    case 'true':\n                    case 'false':\n                        return 'BooleanValue';\n                }\n                if (token.value === 'null') {\n                    return 'NullValue';\n                }\n                return 'EnumValue';\n        }\n    },\n    NumberValue: [t('Number', 'number')],\n    StringValue: [\n        {\n            style: 'string',\n            match: (token) => token.kind === 'String',\n            update(state, token) {\n                if (token.value.startsWith('\"\"\"')) {\n                    state.inBlockstring = !token.value.slice(3).endsWith('\"\"\"');\n                }\n            },\n        },\n    ],\n    BooleanValue: [t('Name', 'builtin')],\n    NullValue: [t('Name', 'keyword')],\n    EnumValue: [name('string-2')],\n    ListValue: [p('['), list('Value'), p(']')],\n    ObjectValue: [p('{'), list('ObjectField'), p('}')],\n    ObjectField: [name('attribute'), p(':'), 'Value'],\n    Type(token) {\n        return token.value === '[' ? 'ListType' : 'NonNullType';\n    },\n    ListType: [p('['), 'Type', p(']'), opt(p('!'))],\n    NonNullType: ['NamedType', opt(p('!'))],\n    NamedType: [type('atom')],\n    Directive: [p('@', 'meta'), name('meta'), opt('Arguments')],\n    DirectiveDef: [\n        word('directive'),\n        p('@', 'meta'),\n        name('meta'),\n        opt('ArgumentsDef'),\n        word('on'),\n        list('DirectiveLocation', p('|')),\n    ],\n    InterfaceDef: [\n        word('interface'),\n        name('atom'),\n        opt('Implements'),\n        list('Directive'),\n        p('{'),\n        list('FieldDef'),\n        p('}'),\n    ],\n    Implements: [word('implements'), list('NamedType', p('&'))],\n    DirectiveLocation: [name('string-2')],\n    SchemaDef: [\n        word('schema'),\n        list('Directive'),\n        p('{'),\n        list('OperationTypeDef'),\n        p('}'),\n    ],\n    OperationTypeDef: [name('keyword'), p(':'), name('atom')],\n    ScalarDef: [word('scalar'), name('atom'), list('Directive')],\n    ObjectTypeDef: [\n        word('type'),\n        name('atom'),\n        opt('Implements'),\n        list('Directive'),\n        p('{'),\n        list('FieldDef'),\n        p('}'),\n    ],\n    FieldDef: [\n        name('property'),\n        opt('ArgumentsDef'),\n        p(':'),\n        'Type',\n        list('Directive'),\n    ],\n    ArgumentsDef: [p('('), list('InputValueDef'), p(')')],\n    InputValueDef: [\n        name('attribute'),\n        p(':'),\n        'Type',\n        opt('DefaultValue'),\n        list('Directive'),\n    ],\n    UnionDef: [\n        word('union'),\n        name('atom'),\n        list('Directive'),\n        p('='),\n        list('UnionMember', p('|')),\n    ],\n    UnionMember: ['NamedType'],\n    EnumDef: [\n        word('enum'),\n        name('atom'),\n        list('Directive'),\n        p('{'),\n        list('EnumValueDef'),\n        p('}'),\n    ],\n    EnumValueDef: [name('string-2'), list('Directive')],\n    InputDef: [\n        word('input'),\n        name('atom'),\n        list('Directive'),\n        p('{'),\n        list('InputValueDef'),\n        p('}'),\n    ],\n    ExtendDef: [word('extend'), 'ExtensionDefinition'],\n    ExtensionDefinition(token) {\n        switch (token.value) {\n            case 'schema':\n                return Kind.SCHEMA_EXTENSION;\n            case 'scalar':\n                return Kind.SCALAR_TYPE_EXTENSION;\n            case 'type':\n                return Kind.OBJECT_TYPE_EXTENSION;\n            case 'interface':\n                return Kind.INTERFACE_TYPE_EXTENSION;\n            case 'union':\n                return Kind.UNION_TYPE_EXTENSION;\n            case 'enum':\n                return Kind.ENUM_TYPE_EXTENSION;\n            case 'input':\n                return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n        }\n    },\n    [Kind.SCHEMA_EXTENSION]: ['SchemaDef'],\n    [Kind.SCALAR_TYPE_EXTENSION]: ['ScalarDef'],\n    [Kind.OBJECT_TYPE_EXTENSION]: ['ObjectTypeDef'],\n    [Kind.INTERFACE_TYPE_EXTENSION]: ['InterfaceDef'],\n    [Kind.UNION_TYPE_EXTENSION]: ['UnionDef'],\n    [Kind.ENUM_TYPE_EXTENSION]: ['EnumDef'],\n    [Kind.INPUT_OBJECT_TYPE_EXTENSION]: ['InputDef'],\n};\nfunction word(value) {\n    return {\n        style: 'keyword',\n        match: (token) => token.kind === 'Name' && token.value === value,\n    };\n}\nfunction name(style) {\n    return {\n        style,\n        match: (token) => token.kind === 'Name',\n        update(state, token) {\n            state.name = token.value;\n        },\n    };\n}\nfunction type(style) {\n    return {\n        style,\n        match: (token) => token.kind === 'Name',\n        update(state, token) {\n            var _a;\n            if ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.prevState) {\n                state.name = token.value;\n                state.prevState.prevState.type = token.value;\n            }\n        },\n    };\n}\n//# sourceMappingURL=Rules.js.map","import { LexRules, ParseRules, isIgnored } from './Rules';\nimport { Kind } from 'graphql';\nexport default function onlineParser(options = {\n    eatWhitespace: stream => stream.eatWhile(isIgnored),\n    lexRules: LexRules,\n    parseRules: ParseRules,\n    editorConfig: {},\n}) {\n    return {\n        startState() {\n            const initialState = {\n                level: 0,\n                step: 0,\n                name: null,\n                kind: null,\n                type: null,\n                rule: null,\n                needsSeparator: false,\n                prevState: null,\n            };\n            pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n            return initialState;\n        },\n        token(stream, state) {\n            return getToken(stream, state, options);\n        },\n    };\n}\nfunction getToken(stream, state, options) {\n    var _a;\n    if (state.inBlockstring) {\n        if (stream.match(/.*\"\"\"/)) {\n            state.inBlockstring = false;\n            return 'string';\n        }\n        stream.skipToEnd();\n        return 'string';\n    }\n    const { lexRules, parseRules, eatWhitespace, editorConfig } = options;\n    if (state.rule && state.rule.length === 0) {\n        popRule(state);\n    }\n    else if (state.needsAdvance) {\n        state.needsAdvance = false;\n        advanceRule(state, true);\n    }\n    if (stream.sol()) {\n        const tabSize = (editorConfig === null || editorConfig === void 0 ? void 0 : editorConfig.tabSize) || 2;\n        state.indentLevel = Math.floor(stream.indentation() / tabSize);\n    }\n    if (eatWhitespace(stream)) {\n        return 'ws';\n    }\n    const token = lex(lexRules, stream);\n    if (!token) {\n        const matchedSomething = stream.match(/\\S+/);\n        if (!matchedSomething) {\n            stream.match(/\\s/);\n        }\n        pushRule(SpecialParseRules, state, 'Invalid');\n        return 'invalidchar';\n    }\n    if (token.kind === 'Comment') {\n        pushRule(SpecialParseRules, state, 'Comment');\n        return 'comment';\n    }\n    const backupState = assign({}, state);\n    if (token.kind === 'Punctuation') {\n        if (/^[{([]/.test(token.value)) {\n            if (state.indentLevel !== undefined) {\n                state.levels = (state.levels || []).concat(state.indentLevel + 1);\n            }\n        }\n        else if (/^[})\\]]/.test(token.value)) {\n            const levels = (state.levels = (state.levels || []).slice(0, -1));\n            if (state.indentLevel &&\n                levels.length > 0 &&\n                levels.at(-1) < state.indentLevel) {\n                state.indentLevel = levels.at(-1);\n            }\n        }\n    }\n    while (state.rule) {\n        let expected = typeof state.rule === 'function'\n            ? state.step === 0\n                ? state.rule(token, stream)\n                : null\n            : state.rule[state.step];\n        if (state.needsSeparator) {\n            expected = expected === null || expected === void 0 ? void 0 : expected.separator;\n        }\n        if (expected) {\n            if (expected.ofRule) {\n                expected = expected.ofRule;\n            }\n            if (typeof expected === 'string') {\n                pushRule(parseRules, state, expected);\n                continue;\n            }\n            if ((_a = expected.match) === null || _a === void 0 ? void 0 : _a.call(expected, token)) {\n                if (expected.update) {\n                    expected.update(state, token);\n                }\n                if (token.kind === 'Punctuation') {\n                    advanceRule(state, true);\n                }\n                else {\n                    state.needsAdvance = true;\n                }\n                return expected.style;\n            }\n        }\n        unsuccessful(state);\n    }\n    assign(state, backupState);\n    pushRule(SpecialParseRules, state, 'Invalid');\n    return 'invalidchar';\n}\nfunction assign(to, from) {\n    const keys = Object.keys(from);\n    for (let i = 0; i < keys.length; i++) {\n        to[keys[i]] = from[keys[i]];\n    }\n    return to;\n}\nconst SpecialParseRules = {\n    Invalid: [],\n    Comment: [],\n};\nfunction pushRule(rules, state, ruleKind) {\n    if (!rules[ruleKind]) {\n        throw new TypeError('Unknown rule: ' + ruleKind);\n    }\n    state.prevState = Object.assign({}, state);\n    state.kind = ruleKind;\n    state.name = null;\n    state.type = null;\n    state.rule = rules[ruleKind];\n    state.step = 0;\n    state.needsSeparator = false;\n}\nfunction popRule(state) {\n    if (!state.prevState) {\n        return;\n    }\n    state.kind = state.prevState.kind;\n    state.name = state.prevState.name;\n    state.type = state.prevState.type;\n    state.rule = state.prevState.rule;\n    state.step = state.prevState.step;\n    state.needsSeparator = state.prevState.needsSeparator;\n    state.prevState = state.prevState.prevState;\n}\nfunction advanceRule(state, successful) {\n    var _a;\n    if (isList(state) && state.rule) {\n        const step = state.rule[state.step];\n        if (step.separator) {\n            const { separator } = step;\n            state.needsSeparator = !state.needsSeparator;\n            if (!state.needsSeparator && separator.ofRule) {\n                return;\n            }\n        }\n        if (successful) {\n            return;\n        }\n    }\n    state.needsSeparator = false;\n    state.step++;\n    while (state.rule &&\n        !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n        popRule(state);\n        if (state.rule) {\n            if (isList(state)) {\n                if ((_a = state.rule) === null || _a === void 0 ? void 0 : _a[state.step].separator) {\n                    state.needsSeparator = !state.needsSeparator;\n                }\n            }\n            else {\n                state.needsSeparator = false;\n                state.step++;\n            }\n        }\n    }\n}\nfunction isList(state) {\n    const step = Array.isArray(state.rule) &&\n        typeof state.rule[state.step] !== 'string' &&\n        state.rule[state.step];\n    return step && step.isList;\n}\nfunction unsuccessful(state) {\n    while (state.rule &&\n        !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n        popRule(state);\n    }\n    if (state.rule) {\n        advanceRule(state, false);\n    }\n}\nfunction lex(lexRules, stream) {\n    const kinds = Object.keys(lexRules);\n    for (let i = 0; i < kinds.length; i++) {\n        const match = stream.match(lexRules[kinds[i]]);\n        if (match && match instanceof Array) {\n            return { kind: kinds[i], value: match[0] };\n        }\n    }\n}\n//# sourceMappingURL=onlineParser.js.map","export class Range {\n    constructor(start, end) {\n        this.containsPosition = (position) => {\n            if (this.start.line === position.line) {\n                return this.start.character <= position.character;\n            }\n            if (this.end.line === position.line) {\n                return this.end.character >= position.character;\n            }\n            return this.start.line <= position.line && this.end.line >= position.line;\n        };\n        this.start = start;\n        this.end = end;\n    }\n    setStart(line, character) {\n        this.start = new Position(line, character);\n    }\n    setEnd(line, character) {\n        this.end = new Position(line, character);\n    }\n}\nexport class Position {\n    constructor(line, character) {\n        this.lessThanOrEqualTo = (position) => this.line < position.line ||\n            (this.line === position.line && this.character <= position.character);\n        this.line = line;\n        this.character = character;\n    }\n    setLine(line) {\n        this.line = line;\n    }\n    setCharacter(character) {\n        this.character = character;\n    }\n}\nexport function offsetToPosition(text, loc) {\n    const EOL = '\\n';\n    const buf = text.slice(0, loc);\n    const lines = buf.split(EOL).length - 1;\n    const lastLineIndex = buf.lastIndexOf(EOL);\n    return new Position(lines, loc - lastLineIndex - 1);\n}\nexport function locToRange(text, loc) {\n    const start = offsetToPosition(text, loc.start);\n    const end = offsetToPosition(text, loc.end);\n    return new Range(start, end);\n}\n//# sourceMappingURL=Range.js.map","import { specifiedRules, validate, NoUnusedFragmentsRule, KnownFragmentNamesRule, Kind, ExecutableDefinitionsRule, LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, } from 'graphql';\nconst specifiedSDLRules = [\n    LoneSchemaDefinitionRule,\n    UniqueOperationTypesRule,\n    UniqueTypeNamesRule,\n    UniqueEnumValueNamesRule,\n    UniqueFieldDefinitionNamesRule,\n    UniqueDirectiveNamesRule,\n    KnownTypeNamesRule,\n    KnownDirectivesRule,\n    UniqueDirectivesPerLocationRule,\n    PossibleTypeExtensionsRule,\n    UniqueArgumentNamesRule,\n    UniqueInputFieldNamesRule,\n];\nexport function validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {\n    const rules = specifiedRules.filter(rule => {\n        if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitionsRule) {\n            return false;\n        }\n        if (isRelayCompatMode && rule === KnownFragmentNamesRule) {\n            return false;\n        }\n        return true;\n    });\n    if (customRules) {\n        Array.prototype.push.apply(rules, customRules);\n    }\n    if (isSchemaDocument) {\n        Array.prototype.push.apply(rules, specifiedSDLRules);\n    }\n    const errors = validate(schema, ast, rules);\n    return errors.filter(error => {\n        if (error.message.includes('Unknown directive') && error.nodes) {\n            const node = error.nodes[0];\n            if (node && node.kind === Kind.DIRECTIVE) {\n                const name = node.name.value;\n                if (name === 'arguments' || name === 'argumentDefinitions') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    });\n}\n//# sourceMappingURL=validateWithCustomRules.js.map","import { GraphQLError, print, validate, NoDeprecatedCustomRule, parse, } from 'graphql';\nimport { CharacterStream, onlineParser } from '../parser';\nimport { Range, validateWithCustomRules, Position } from '../utils';\nexport const SEVERITY = {\n    Error: 'Error',\n    Warning: 'Warning',\n    Information: 'Information',\n    Hint: 'Hint',\n};\nexport const DIAGNOSTIC_SEVERITY = {\n    [SEVERITY.Error]: 1,\n    [SEVERITY.Warning]: 2,\n    [SEVERITY.Information]: 3,\n    [SEVERITY.Hint]: 4,\n};\nconst invariant = (condition, message) => {\n    if (!condition) {\n        throw new Error(message);\n    }\n};\nexport function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n    var _a, _b;\n    let ast = null;\n    let fragments = '';\n    if (externalFragments) {\n        fragments =\n            typeof externalFragments === 'string'\n                ? externalFragments\n                : externalFragments.reduce((acc, node) => acc + print(node) + '\\n\\n', '');\n    }\n    const enhancedQuery = fragments ? `${query}\\n\\n${fragments}` : query;\n    try {\n        ast = parse(enhancedQuery);\n    }\n    catch (error) {\n        if (error instanceof GraphQLError) {\n            const range = getRange((_b = (_a = error.locations) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : { line: 0, column: 0 }, enhancedQuery);\n            return [\n                {\n                    severity: DIAGNOSTIC_SEVERITY.Error,\n                    message: error.message,\n                    source: 'GraphQL: Syntax',\n                    range,\n                },\n            ];\n        }\n        throw error;\n    }\n    return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\nexport function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n    if (!schema) {\n        return [];\n    }\n    const validationErrorAnnotations = validateWithCustomRules(schema, ast, customRules, isRelayCompatMode).flatMap(error => annotations(error, DIAGNOSTIC_SEVERITY.Error, 'Validation'));\n    const deprecationWarningAnnotations = validate(schema, ast, [\n        NoDeprecatedCustomRule,\n    ]).flatMap(error => annotations(error, DIAGNOSTIC_SEVERITY.Warning, 'Deprecation'));\n    return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\nfunction annotations(error, severity, type) {\n    if (!error.nodes) {\n        return [];\n    }\n    const highlightedNodes = [];\n    for (const [i, node] of error.nodes.entries()) {\n        const highlightNode = node.kind !== 'Variable' && 'name' in node && node.name !== undefined\n            ? node.name\n            : 'variable' in node && node.variable !== undefined\n                ? node.variable\n                : node;\n        if (highlightNode) {\n            invariant(error.locations, 'GraphQL validation error requires locations.');\n            const loc = error.locations[i];\n            const highlightLoc = getLocation(highlightNode);\n            const end = loc.column + (highlightLoc.end - highlightLoc.start);\n            highlightedNodes.push({\n                source: `GraphQL: ${type}`,\n                message: error.message,\n                severity,\n                range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end)),\n            });\n        }\n    }\n    return highlightedNodes;\n}\nexport function getRange(location, queryText) {\n    const parser = onlineParser();\n    const state = parser.startState();\n    const lines = queryText.split('\\n');\n    invariant(lines.length >= location.line, 'Query text must have more lines than where the error happened');\n    let stream = null;\n    for (let i = 0; i < location.line; i++) {\n        stream = new CharacterStream(lines[i]);\n        while (!stream.eol()) {\n            const style = parser.token(stream, state);\n            if (style === 'invalidchar') {\n                break;\n            }\n        }\n    }\n    invariant(stream, 'Expected Parser stream to be available.');\n    const line = location.line - 1;\n    const start = stream.getStartOfToken();\n    const end = stream.getCurrentPosition();\n    return new Range(new Position(line, start), new Position(line, end));\n}\nfunction getLocation(node) {\n    const typeCastedNode = node;\n    const location = typeCastedNode.loc;\n    invariant(location, 'Expected ASTNode to have a location.');\n    return location;\n}\n//# sourceMappingURL=getDiagnostics.js.map","var e = {\n  NAME: \"Name\",\n  DOCUMENT: \"Document\",\n  OPERATION_DEFINITION: \"OperationDefinition\",\n  VARIABLE_DEFINITION: \"VariableDefinition\",\n  SELECTION_SET: \"SelectionSet\",\n  FIELD: \"Field\",\n  ARGUMENT: \"Argument\",\n  FRAGMENT_SPREAD: \"FragmentSpread\",\n  INLINE_FRAGMENT: \"InlineFragment\",\n  FRAGMENT_DEFINITION: \"FragmentDefinition\",\n  VARIABLE: \"Variable\",\n  INT: \"IntValue\",\n  FLOAT: \"FloatValue\",\n  STRING: \"StringValue\",\n  BOOLEAN: \"BooleanValue\",\n  NULL: \"NullValue\",\n  ENUM: \"EnumValue\",\n  LIST: \"ListValue\",\n  OBJECT: \"ObjectValue\",\n  OBJECT_FIELD: \"ObjectField\",\n  DIRECTIVE: \"Directive\",\n  NAMED_TYPE: \"NamedType\",\n  LIST_TYPE: \"ListType\",\n  NON_NULL_TYPE: \"NonNullType\"\n};\n\nvar r = {\n  QUERY: \"query\",\n  MUTATION: \"mutation\",\n  SUBSCRIPTION: \"subscription\"\n};\n\nclass GraphQLError extends Error {\n  constructor(e, r, i, n, a, t, o) {\n    super(e);\n    this.name = \"GraphQLError\";\n    this.message = e;\n    if (a) {\n      this.path = a;\n    }\n    if (r) {\n      this.nodes = Array.isArray(r) ? r : [ r ];\n    }\n    if (i) {\n      this.source = i;\n    }\n    if (n) {\n      this.positions = n;\n    }\n    if (t) {\n      this.originalError = t;\n    }\n    var l = o;\n    if (!l && t) {\n      var u = t.extensions;\n      if (u && \"object\" == typeof u) {\n        l = u;\n      }\n    }\n    this.extensions = l || {};\n  }\n  toJSON() {\n    return {\n      ...this,\n      message: this.message\n    };\n  }\n  toString() {\n    return this.message;\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLError\";\n  }\n}\n\nvar i;\n\nvar n;\n\nfunction error(e) {\n  return new GraphQLError(`Syntax Error: Unexpected token at ${n} in ${e}`);\n}\n\nfunction advance(e) {\n  e.lastIndex = n;\n  if (e.test(i)) {\n    return i.slice(n, n = e.lastIndex);\n  }\n}\n\nvar a = / +(?=[^\\s])/y;\n\nfunction blockString(e) {\n  var r = e.split(\"\\n\");\n  var i = \"\";\n  var n = 0;\n  var t = 0;\n  var o = r.length - 1;\n  for (var l = 0; l < r.length; l++) {\n    a.lastIndex = 0;\n    if (a.test(r[l])) {\n      if (l && (!n || a.lastIndex < n)) {\n        n = a.lastIndex;\n      }\n      t = t || l;\n      o = l;\n    }\n  }\n  for (var u = t; u <= o; u++) {\n    if (u !== t) {\n      i += \"\\n\";\n    }\n    i += r[u].slice(n).replace(/\\\\\"\"\"/g, '\"\"\"');\n  }\n  return i;\n}\n\nfunction ignored() {\n  for (var e = 0 | i.charCodeAt(n++); 9 === e || 10 === e || 13 === e || 32 === e || 35 === e || 44 === e || 65279 === e; e = 0 | i.charCodeAt(n++)) {\n    if (35 === e) {\n      while (10 !== (e = i.charCodeAt(n++)) && 13 !== e) {}\n    }\n  }\n  n--;\n}\n\nvar t = /[_A-Za-z]\\w*/y;\n\nfunction name() {\n  var e;\n  if (e = advance(t)) {\n    return {\n      kind: \"Name\",\n      value: e\n    };\n  }\n}\n\nvar o = /(?:null|true|false)/y;\n\nvar l = /\\$[_A-Za-z]\\w*/y;\n\nvar u = /-?\\d+/y;\n\nvar v = /(?:\\.\\d+)?[eE][+-]?\\d+|\\.\\d+/y;\n\nvar d = /\\\\/g;\n\nvar s = /\"\"\"(?:\"\"\"|(?:[\\s\\S]*?[^\\\\])\"\"\")/y;\n\nvar c = /\"(?:\"|[^\\r\\n]*?[^\\\\]\")/y;\n\nfunction value(e) {\n  var r;\n  var a;\n  if (a = advance(o)) {\n    r = \"null\" === a ? {\n      kind: \"NullValue\"\n    } : {\n      kind: \"BooleanValue\",\n      value: \"true\" === a\n    };\n  } else if (!e && (a = advance(l))) {\n    r = {\n      kind: \"Variable\",\n      name: {\n        kind: \"Name\",\n        value: a.slice(1)\n      }\n    };\n  } else if (a = advance(u)) {\n    var f = a;\n    if (a = advance(v)) {\n      r = {\n        kind: \"FloatValue\",\n        value: f + a\n      };\n    } else {\n      r = {\n        kind: \"IntValue\",\n        value: f\n      };\n    }\n  } else if (a = advance(t)) {\n    r = {\n      kind: \"EnumValue\",\n      value: a\n    };\n  } else if (a = advance(s)) {\n    r = {\n      kind: \"StringValue\",\n      value: blockString(a.slice(3, -3)),\n      block: !0\n    };\n  } else if (a = advance(c)) {\n    r = {\n      kind: \"StringValue\",\n      value: d.test(a) ? JSON.parse(a) : a.slice(1, -1),\n      block: !1\n    };\n  } else if (r = function list(e) {\n    var r;\n    if (91 === i.charCodeAt(n)) {\n      n++;\n      ignored();\n      var a = [];\n      while (r = value(e)) {\n        a.push(r);\n      }\n      if (93 !== i.charCodeAt(n++)) {\n        throw error(\"ListValue\");\n      }\n      ignored();\n      return {\n        kind: \"ListValue\",\n        values: a\n      };\n    }\n  }(e) || function object(e) {\n    if (123 === i.charCodeAt(n)) {\n      n++;\n      ignored();\n      var r = [];\n      var a;\n      while (a = name()) {\n        ignored();\n        if (58 !== i.charCodeAt(n++)) {\n          throw error(\"ObjectField\");\n        }\n        ignored();\n        var t = value(e);\n        if (!t) {\n          throw error(\"ObjectField\");\n        }\n        r.push({\n          kind: \"ObjectField\",\n          name: a,\n          value: t\n        });\n      }\n      if (125 !== i.charCodeAt(n++)) {\n        throw error(\"ObjectValue\");\n      }\n      ignored();\n      return {\n        kind: \"ObjectValue\",\n        fields: r\n      };\n    }\n  }(e)) {\n    return r;\n  }\n  ignored();\n  return r;\n}\n\nfunction arguments_(e) {\n  var r = [];\n  ignored();\n  if (40 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    var a;\n    while (a = name()) {\n      ignored();\n      if (58 !== i.charCodeAt(n++)) {\n        throw error(\"Argument\");\n      }\n      ignored();\n      var t = value(e);\n      if (!t) {\n        throw error(\"Argument\");\n      }\n      r.push({\n        kind: \"Argument\",\n        name: a,\n        value: t\n      });\n    }\n    if (!r.length || 41 !== i.charCodeAt(n++)) {\n      throw error(\"Argument\");\n    }\n    ignored();\n  }\n  return r;\n}\n\nfunction directives(e) {\n  var r = [];\n  ignored();\n  while (64 === i.charCodeAt(n)) {\n    n++;\n    var a = name();\n    if (!a) {\n      throw error(\"Directive\");\n    }\n    ignored();\n    r.push({\n      kind: \"Directive\",\n      name: a,\n      arguments: arguments_(e)\n    });\n  }\n  return r;\n}\n\nfunction field() {\n  var e = name();\n  if (e) {\n    ignored();\n    var r;\n    if (58 === i.charCodeAt(n)) {\n      n++;\n      ignored();\n      r = e;\n      if (!(e = name())) {\n        throw error(\"Field\");\n      }\n      ignored();\n    }\n    return {\n      kind: \"Field\",\n      alias: r,\n      name: e,\n      arguments: arguments_(!1),\n      directives: directives(!1),\n      selectionSet: selectionSet()\n    };\n  }\n}\n\nfunction type() {\n  var e;\n  ignored();\n  if (91 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    var r = type();\n    if (!r || 93 !== i.charCodeAt(n++)) {\n      throw error(\"ListType\");\n    }\n    e = {\n      kind: \"ListType\",\n      type: r\n    };\n  } else if (e = name()) {\n    e = {\n      kind: \"NamedType\",\n      name: e\n    };\n  } else {\n    throw error(\"NamedType\");\n  }\n  ignored();\n  if (33 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    return {\n      kind: \"NonNullType\",\n      type: e\n    };\n  } else {\n    return e;\n  }\n}\n\nvar f = /on/y;\n\nfunction typeCondition() {\n  if (advance(f)) {\n    ignored();\n    var e = name();\n    if (!e) {\n      throw error(\"NamedType\");\n    }\n    ignored();\n    return {\n      kind: \"NamedType\",\n      name: e\n    };\n  }\n}\n\nvar p = /\\.\\.\\./y;\n\nfunction fragmentSpread() {\n  if (advance(p)) {\n    ignored();\n    var e = n;\n    var r;\n    if ((r = name()) && \"on\" !== r.value) {\n      return {\n        kind: \"FragmentSpread\",\n        name: r,\n        directives: directives(!1)\n      };\n    } else {\n      n = e;\n      var i = typeCondition();\n      var a = directives(!1);\n      var t = selectionSet();\n      if (!t) {\n        throw error(\"InlineFragment\");\n      }\n      return {\n        kind: \"InlineFragment\",\n        typeCondition: i,\n        directives: a,\n        selectionSet: t\n      };\n    }\n  }\n}\n\nfunction selectionSet() {\n  var e;\n  ignored();\n  if (123 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    var r = [];\n    while (e = fragmentSpread() || field()) {\n      r.push(e);\n    }\n    if (!r.length || 125 !== i.charCodeAt(n++)) {\n      throw error(\"SelectionSet\");\n    }\n    ignored();\n    return {\n      kind: \"SelectionSet\",\n      selections: r\n    };\n  }\n}\n\nvar m = /fragment/y;\n\nfunction fragmentDefinition() {\n  if (advance(m)) {\n    ignored();\n    var e = name();\n    if (!e) {\n      throw error(\"FragmentDefinition\");\n    }\n    ignored();\n    var r = typeCondition();\n    if (!r) {\n      throw error(\"FragmentDefinition\");\n    }\n    var i = directives(!1);\n    var n = selectionSet();\n    if (!n) {\n      throw error(\"FragmentDefinition\");\n    }\n    return {\n      kind: \"FragmentDefinition\",\n      name: e,\n      typeCondition: r,\n      directives: i,\n      selectionSet: n\n    };\n  }\n}\n\nvar g = /(?:query|mutation|subscription)/y;\n\nfunction operationDefinition() {\n  var e;\n  var r;\n  var a = [];\n  var t = [];\n  if (e = advance(g)) {\n    ignored();\n    r = name();\n    a = function variableDefinitions() {\n      var e;\n      var r = [];\n      ignored();\n      if (40 === i.charCodeAt(n)) {\n        n++;\n        ignored();\n        while (e = advance(l)) {\n          ignored();\n          if (58 !== i.charCodeAt(n++)) {\n            throw error(\"VariableDefinition\");\n          }\n          var a = type();\n          var t = void 0;\n          if (61 === i.charCodeAt(n)) {\n            n++;\n            ignored();\n            if (!(t = value(!0))) {\n              throw error(\"VariableDefinition\");\n            }\n          }\n          ignored();\n          r.push({\n            kind: \"VariableDefinition\",\n            variable: {\n              kind: \"Variable\",\n              name: {\n                kind: \"Name\",\n                value: e.slice(1)\n              }\n            },\n            type: a,\n            defaultValue: t,\n            directives: directives(!0)\n          });\n        }\n        if (41 !== i.charCodeAt(n++)) {\n          throw error(\"VariableDefinition\");\n        }\n        ignored();\n      }\n      return r;\n    }();\n    t = directives(!1);\n  }\n  var o = selectionSet();\n  if (o) {\n    return {\n      kind: \"OperationDefinition\",\n      operation: e || \"query\",\n      name: r,\n      variableDefinitions: a,\n      directives: t,\n      selectionSet: o\n    };\n  }\n}\n\nfunction parse(e, r) {\n  i = \"string\" == typeof e.body ? e.body : e;\n  n = 0;\n  return function document() {\n    var e;\n    ignored();\n    var r = [];\n    while (e = fragmentDefinition() || operationDefinition()) {\n      r.push(e);\n    }\n    return {\n      kind: \"Document\",\n      definitions: r\n    };\n  }();\n}\n\nfunction parseValue(e, r) {\n  i = \"string\" == typeof e.body ? e.body : e;\n  n = 0;\n  ignored();\n  var a = value(!1);\n  if (!a) {\n    throw error(\"ValueNode\");\n  }\n  return a;\n}\n\nfunction parseType(e, r) {\n  i = \"string\" == typeof e.body ? e.body : e;\n  n = 0;\n  return type();\n}\n\nvar h = {};\n\nfunction visit(e, r) {\n  var i = [];\n  var n = [];\n  try {\n    var a = function traverse(e, a, t) {\n      var o = !1;\n      var l = r[e.kind] && r[e.kind].enter || r[e.kind] || r.enter;\n      var u = l && l.call(r, e, a, t, n, i);\n      if (!1 === u) {\n        return e;\n      } else if (null === u) {\n        return null;\n      } else if (u === h) {\n        throw h;\n      } else if (u && \"string\" == typeof u.kind) {\n        o = u !== e;\n        e = u;\n      }\n      if (t) {\n        i.push(t);\n      }\n      var v;\n      var d = {\n        ...e\n      };\n      for (var s in e) {\n        n.push(s);\n        var c = e[s];\n        if (Array.isArray(c)) {\n          var f = [];\n          for (var p = 0; p < c.length; p++) {\n            if (null != c[p] && \"string\" == typeof c[p].kind) {\n              i.push(e);\n              n.push(p);\n              v = traverse(c[p], p, c);\n              n.pop();\n              i.pop();\n              if (null == v) {\n                o = !0;\n              } else {\n                o = o || v !== c[p];\n                f.push(v);\n              }\n            }\n          }\n          c = f;\n        } else if (null != c && \"string\" == typeof c.kind) {\n          if (void 0 !== (v = traverse(c, s, e))) {\n            o = o || c !== v;\n            c = v;\n          }\n        }\n        n.pop();\n        if (o) {\n          d[s] = c;\n        }\n      }\n      if (t) {\n        i.pop();\n      }\n      var m = r[e.kind] && r[e.kind].leave || r.leave;\n      var g = m && m.call(r, e, a, t, n, i);\n      if (g === h) {\n        throw h;\n      } else if (void 0 !== g) {\n        return g;\n      } else if (void 0 !== u) {\n        return o ? d : u;\n      } else {\n        return o ? d : e;\n      }\n    }(e);\n    return void 0 !== a && !1 !== a ? a : e;\n  } catch (r) {\n    if (r !== h) {\n      throw r;\n    }\n    return e;\n  }\n}\n\nfunction printString(e) {\n  return JSON.stringify(e);\n}\n\nfunction printBlockString(e) {\n  return '\"\"\"\\n' + e.replace(/\"\"\"/g, '\\\\\"\"\"') + '\\n\"\"\"';\n}\n\nvar hasItems = e => !(!e || !e.length);\n\nvar y = {\n  OperationDefinition(e) {\n    if (\"query\" === e.operation && !e.name && !hasItems(e.variableDefinitions) && !hasItems(e.directives)) {\n      return y.SelectionSet(e.selectionSet);\n    }\n    var r = e.operation;\n    if (e.name) {\n      r += \" \" + e.name.value;\n    }\n    if (hasItems(e.variableDefinitions)) {\n      if (!e.name) {\n        r += \" \";\n      }\n      r += \"(\" + e.variableDefinitions.map(y.VariableDefinition).join(\", \") + \")\";\n    }\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r + \" \" + y.SelectionSet(e.selectionSet);\n  },\n  VariableDefinition(e) {\n    var r = y.Variable(e.variable) + \": \" + print(e.type);\n    if (e.defaultValue) {\n      r += \" = \" + print(e.defaultValue);\n    }\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r;\n  },\n  Field(e) {\n    var r = (e.alias ? e.alias.value + \": \" : \"\") + e.name.value;\n    if (hasItems(e.arguments)) {\n      var i = e.arguments.map(y.Argument);\n      var n = r + \"(\" + i.join(\", \") + \")\";\n      r = n.length > 80 ? r + \"(\\n  \" + i.join(\"\\n\").replace(/\\n/g, \"\\n  \") + \"\\n)\" : n;\n    }\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return e.selectionSet ? r + \" \" + y.SelectionSet(e.selectionSet) : r;\n  },\n  StringValue: e => e.block ? printBlockString(e.value) : printString(e.value),\n  BooleanValue: e => \"\" + e.value,\n  NullValue: e => \"null\",\n  IntValue: e => e.value,\n  FloatValue: e => e.value,\n  EnumValue: e => e.value,\n  Name: e => e.value,\n  Variable: e => \"$\" + e.name.value,\n  ListValue: e => \"[\" + e.values.map(print).join(\", \") + \"]\",\n  ObjectValue: e => \"{\" + e.fields.map(y.ObjectField).join(\", \") + \"}\",\n  ObjectField: e => e.name.value + \": \" + print(e.value),\n  Document: e => hasItems(e.definitions) ? e.definitions.map(print).join(\"\\n\\n\") : \"\",\n  SelectionSet: e => \"{\\n  \" + e.selections.map(print).join(\"\\n\").replace(/\\n/g, \"\\n  \") + \"\\n}\",\n  Argument: e => e.name.value + \": \" + print(e.value),\n  FragmentSpread(e) {\n    var r = \"...\" + e.name.value;\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r;\n  },\n  InlineFragment(e) {\n    var r = \"...\";\n    if (e.typeCondition) {\n      r += \" on \" + e.typeCondition.name.value;\n    }\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r + \" \" + print(e.selectionSet);\n  },\n  FragmentDefinition(e) {\n    var r = \"fragment \" + e.name.value;\n    r += \" on \" + e.typeCondition.name.value;\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r + \" \" + print(e.selectionSet);\n  },\n  Directive(e) {\n    var r = \"@\" + e.name.value;\n    if (hasItems(e.arguments)) {\n      r += \"(\" + e.arguments.map(y.Argument).join(\", \") + \")\";\n    }\n    return r;\n  },\n  NamedType: e => e.name.value,\n  ListType: e => \"[\" + print(e.type) + \"]\",\n  NonNullType: e => print(e.type) + \"!\"\n};\n\nfunction print(e) {\n  return y[e.kind] ? y[e.kind](e) : \"\";\n}\n\nfunction valueFromASTUntyped(e, r) {\n  switch (e.kind) {\n   case \"NullValue\":\n    return null;\n\n   case \"IntValue\":\n    return parseInt(e.value, 10);\n\n   case \"FloatValue\":\n    return parseFloat(e.value);\n\n   case \"StringValue\":\n   case \"EnumValue\":\n   case \"BooleanValue\":\n    return e.value;\n\n   case \"ListValue\":\n    var i = [];\n    for (var n = 0, a = e.values; n < a.length; n += 1) {\n      i.push(valueFromASTUntyped(a[n], r));\n    }\n    return i;\n\n   case \"ObjectValue\":\n    var t = Object.create(null);\n    for (var o = 0, l = e.fields; o < l.length; o += 1) {\n      var u = l[o];\n      t[u.name.value] = valueFromASTUntyped(u.value, r);\n    }\n    return t;\n\n   case \"Variable\":\n    return r && r[e.name.value];\n  }\n}\n\nfunction valueFromTypeNode(e, r, i) {\n  if (\"Variable\" === e.kind) {\n    return i ? valueFromTypeNode(i[e.name.value], r, i) : void 0;\n  } else if (\"NonNullType\" === r.kind) {\n    return \"NullValue\" !== e.kind ? valueFromTypeNode(e, r, i) : void 0;\n  } else if (\"NullValue\" === e.kind) {\n    return null;\n  } else if (\"ListType\" === r.kind) {\n    if (\"ListValue\" === e.kind) {\n      var n = [];\n      for (var a = 0, t = e.values; a < t.length; a += 1) {\n        var o = valueFromTypeNode(t[a], r.type, i);\n        if (void 0 === o) {\n          return;\n        } else {\n          n.push(o);\n        }\n      }\n      return n;\n    }\n  } else if (\"NamedType\" === r.kind) {\n    switch (r.name.value) {\n     case \"Int\":\n     case \"Float\":\n     case \"String\":\n     case \"Bool\":\n      return r.name.value + \"Value\" === e.kind ? valueFromASTUntyped(e, i) : void 0;\n\n     default:\n      return valueFromASTUntyped(e, i);\n    }\n  }\n}\n\nexport { h as BREAK, GraphQLError, e as Kind, r as OperationTypeNode, parse, parseType, parseValue, print, printBlockString, printString, valueFromASTUntyped, valueFromTypeNode, visit };\n//# sourceMappingURL=graphql.web.mjs.map\n","export const templates = new Set(['gql', 'graphql']);\n","import { ts } from '../ts';\nimport { templates } from './templates';\n\n/** Checks for an immediately-invoked function expression */\nexport const isIIFE = (node: ts.Node): boolean =>\n  ts.isCallExpression(node) &&\n  node.arguments.length === 0 &&\n  (ts.isFunctionExpression(node.expression) ||\n    ts.isArrowFunction(node.expression)) &&\n  !node.expression.asteriskToken &&\n  !node.expression.modifiers?.length;\n\n/** Checks if node is a known identifier of graphql functions ('graphql' or 'gql') */\nexport const isGraphQLFunctionIdentifier = (\n  node: ts.Node\n): node is ts.Identifier =>\n  ts.isIdentifier(node) && templates.has(node.escapedText as string);\n\n/** If `checker` is passed, checks if node (as identifier/expression) is a gql.tada graphql() function */\nexport const isTadaGraphQLFunction = (\n  node: ts.Node,\n  checker: ts.TypeChecker | undefined\n): node is ts.LeftHandSideExpression => {\n  if (!ts.isLeftHandSideExpression(node)) return false;\n  const type = checker?.getTypeAtLocation(node);\n  // Any function that has both a `scalar` and `persisted` property\n  // is automatically considered a gql.tada graphql() function.\n  return (\n    type != null &&\n    type.getProperty('scalar') != null &&\n    type.getProperty('persisted') != null\n  );\n};\n\n/** If `checker` is passed, checks if node is a gql.tada graphql() call */\nexport const isTadaGraphQLCall = (\n  node: ts.CallExpression,\n  checker: ts.TypeChecker | undefined\n): boolean => {\n  // We expect graphql() to be called with either a string literal\n  // or a string literal and an array of fragments\n  if (!ts.isCallExpression(node)) {\n    return false;\n  } else if (node.arguments.length < 1 || node.arguments.length > 2) {\n    return false;\n  } else if (!ts.isStringLiteralLike(node.arguments[0]!)) {\n    return false;\n  }\n  return checker ? isTadaGraphQLFunction(node.expression, checker) : false;\n};\n\n/** Checks if node is a gql.tada graphql.persisted() call */\nexport const isTadaPersistedCall = (\n  node: ts.Node | undefined,\n  checker: ts.TypeChecker | undefined\n): node is ts.CallExpression => {\n  if (!node) {\n    return false;\n  } else if (!ts.isCallExpression(node)) {\n    return false;\n  } else if (!ts.isPropertyAccessExpression(node.expression)) {\n    return false; // rejecting non property access calls: <expression>.<name>()\n  } else if (\n    !ts.isIdentifier(node.expression.name) ||\n    node.expression.name.escapedText !== 'persisted'\n  ) {\n    return false; // rejecting calls on anyting but 'persisted': <expression>.persisted()\n  } else if (isGraphQLFunctionIdentifier(node.expression.expression)) {\n    return true;\n  } else {\n    return isTadaGraphQLFunction(node.expression.expression, checker);\n  }\n};\n\n// As per check in `isGraphQLCall()` below, enforces arguments length\nexport type GraphQLCallNode = ts.CallExpression & {\n  arguments: [ts.Expression] | [ts.Expression, ts.Expression];\n};\n\n/** Checks if node is a gql.tada or regular graphql() call */\nexport const isGraphQLCall = (\n  node: ts.Node,\n  checker: ts.TypeChecker | undefined\n): node is GraphQLCallNode => {\n  return (\n    ts.isCallExpression(node) &&\n    node.arguments.length >= 1 &&\n    node.arguments.length <= 2 &&\n    (isGraphQLFunctionIdentifier(node.expression) ||\n      isTadaGraphQLCall(node, checker))\n  );\n};\n\n/** Checks if node is a gql/graphql tagged template literal */\nexport const isGraphQLTag = (\n  node: ts.Node\n): node is ts.TaggedTemplateExpression =>\n  ts.isTaggedTemplateExpression(node) && isGraphQLFunctionIdentifier(node.tag);\n\n/** Retrieves the `__name` branded tag from gql.tada `graphql()` or `graphql.persisted()` calls */\nexport const getSchemaName = (\n  node: ts.CallExpression,\n  typeChecker: ts.TypeChecker | undefined,\n  isTadaPersistedCall = false\n): string | null => {\n  if (!typeChecker) return null;\n  const type = typeChecker.getTypeAtLocation(\n    // When calling `graphql.persisted`, we need to access the `graphql` part of\n    // the expression; `node.expression` is the `.persisted` part\n    isTadaPersistedCall ? node.getChildAt(0).getChildAt(0) : node.expression\n  );\n  if (type) {\n    const brandTypeSymbol = type.getProperty('__name');\n    if (brandTypeSymbol) {\n      const brand = typeChecker.getTypeOfSymbol(brandTypeSymbol);\n      if (brand.isUnionOrIntersection()) {\n        const found = brand.types.find(x => x.isStringLiteral());\n        return found && found.isStringLiteral() ? found.value : null;\n      } else if (brand.isStringLiteral()) {\n        return brand.value;\n      }\n    }\n  }\n  return null;\n};\n\n/** Checks if node is a maskFragments() call */\nexport const isMaskFragmentsCall = (\n  node: ts.Node\n): node is ts.CallExpression => {\n  if (!ts.isCallExpression(node)) return false;\n  if (!ts.isIdentifier(node.expression)) return false;\n  // Only checks function name, not whether it's from gql.tada\n  return node.expression.escapedText === 'maskFragments';\n};\n","import { ts } from '../ts';\n\nexport type ValueDeclaration =\n  | ts.BinaryExpression\n  | ts.ArrowFunction\n  | ts.BindingElement\n  | ts.ClassDeclaration\n  | ts.ClassExpression\n  | ts.ClassStaticBlockDeclaration\n  | ts.ConstructorDeclaration\n  | ts.EnumDeclaration\n  | ts.EnumMember\n  | ts.ExportAssignment\n  | ts.ExportSpecifier\n  | ts.FunctionDeclaration\n  | ts.FunctionExpression\n  | ts.GetAccessorDeclaration\n  | ts.JsxAttribute\n  | ts.MethodDeclaration\n  | ts.ModuleDeclaration\n  | ts.ParameterDeclaration\n  | ts.PropertyAssignment\n  | ts.PropertyDeclaration\n  | ts.SetAccessorDeclaration\n  | ts.ShorthandPropertyAssignment\n  | ts.VariableDeclaration;\n\nexport type ValueOfDeclaration =\n  | ts.ClassExpression\n  | ts.ClassDeclaration\n  | ts.ArrowFunction\n  | ts.ClassStaticBlockDeclaration\n  | ts.ConstructorDeclaration\n  | ts.EnumDeclaration\n  | ts.FunctionDeclaration\n  | ts.GetAccessorDeclaration\n  | ts.SetAccessorDeclaration\n  | ts.MethodDeclaration\n  | ts.Expression;\n\n/** Checks if a node is a `ts.Declaration` and a value.\n * @remarks\n * This checks if a given node is a value declaration only,\n * excluding import/export specifiers, type declarations, and\n * ambient declarations.\n * All declarations that aren't JS(x) nodes will be discarded.\n * This is based on `ts.isDeclarationKind`.\n */\nexport function isValueDeclaration(node: ts.Node): node is ValueDeclaration {\n  switch (node.kind) {\n    case ts.SyntaxKind.BinaryExpression:\n    case ts.SyntaxKind.ArrowFunction:\n    case ts.SyntaxKind.BindingElement:\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.ClassExpression:\n    case ts.SyntaxKind.ClassStaticBlockDeclaration:\n    case ts.SyntaxKind.Constructor:\n    case ts.SyntaxKind.EnumDeclaration:\n    case ts.SyntaxKind.EnumMember:\n    case ts.SyntaxKind.ExportAssignment:\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.GetAccessor:\n    case ts.SyntaxKind.JsxAttribute:\n    case ts.SyntaxKind.MethodDeclaration:\n    case ts.SyntaxKind.Parameter:\n    case ts.SyntaxKind.PropertyAssignment:\n    case ts.SyntaxKind.PropertyDeclaration:\n    case ts.SyntaxKind.SetAccessor:\n    case ts.SyntaxKind.ShorthandPropertyAssignment:\n    case ts.SyntaxKind.VariableDeclaration:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/** Returns true if operator assigns a value unchanged */\nfunction isAssignmentOperator(token: ts.BinaryOperatorToken): boolean {\n  switch (token.kind) {\n    case ts.SyntaxKind.EqualsToken:\n    case ts.SyntaxKind.BarBarEqualsToken:\n    case ts.SyntaxKind.AmpersandAmpersandEqualsToken:\n    case ts.SyntaxKind.QuestionQuestionEqualsToken:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/** Evaluates to the declaration's value initializer or itself if it declares a value */\nexport function getValueOfValueDeclaration(\n  node: ValueDeclaration\n): ValueOfDeclaration | undefined {\n  switch (node.kind) {\n    case ts.SyntaxKind.ClassExpression:\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.ArrowFunction:\n    case ts.SyntaxKind.ClassStaticBlockDeclaration:\n    case ts.SyntaxKind.Constructor:\n    case ts.SyntaxKind.EnumDeclaration:\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.GetAccessor:\n    case ts.SyntaxKind.SetAccessor:\n    case ts.SyntaxKind.MethodDeclaration:\n      return node;\n    case ts.SyntaxKind.BindingElement:\n    case ts.SyntaxKind.EnumMember:\n    case ts.SyntaxKind.JsxAttribute:\n    case ts.SyntaxKind.Parameter:\n    case ts.SyntaxKind.PropertyAssignment:\n    case ts.SyntaxKind.PropertyDeclaration:\n    case ts.SyntaxKind.VariableDeclaration:\n      return node.initializer;\n    case ts.SyntaxKind.ExportAssignment:\n      return node.expression;\n    case ts.SyntaxKind.BinaryExpression:\n      return isAssignmentOperator(node.operatorToken) ? node.right : undefined;\n    case ts.SyntaxKind.ShorthandPropertyAssignment:\n      return node.objectAssignmentInitializer;\n    default:\n      return undefined;\n  }\n}\n\n// See: https://github.com/microsoft/TypeScript/blob/a5eec24/src/services/utilities.ts#L652-L654\nfunction climbPastPropertyOrElementAccess(node: ts.Node): ts.Node {\n  if (\n    node.parent &&\n    ts.isPropertyAccessExpression(node.parent) &&\n    node.parent.name === node\n  ) {\n    return node.parent;\n  } else if (\n    node.parent &&\n    ts.isElementAccessExpression(node.parent) &&\n    node.parent.argumentExpression === node\n  ) {\n    return node.parent;\n  } else {\n    return node;\n  }\n}\n\n// See: https://github.com/microsoft/TypeScript/blob/a5eec24/src/services/utilities.ts#L602-L605\nfunction isNewExpressionTarget(node: ts.Node): node is ts.NewExpression {\n  const target = climbPastPropertyOrElementAccess(node).parent;\n  return ts.isNewExpression(target) && target.expression === node;\n}\n\n// See: https://github.com/microsoft/TypeScript/blob/a5eec24/src/services/utilities.ts#L607-L610\nfunction isCallOrNewExpressionTarget(\n  node: ts.Node\n): node is ts.CallExpression | ts.NewExpression {\n  const target = climbPastPropertyOrElementAccess(node).parent;\n  return ts.isCallOrNewExpression(target) && target.expression === node;\n}\n\n// See: https://github.com/microsoft/TypeScript/blob/a5eec24/src/services/utilities.ts#L716-L719\nfunction isNameOfFunctionDeclaration(node: ts.Node): boolean {\n  return (\n    ts.isIdentifier(node) &&\n    node.parent &&\n    ts.isFunctionLike(node.parent) &&\n    node.parent.name === node\n  );\n}\n\n// See: https://github.com/microsoft/TypeScript/blob/a5eec24/src/services/utilities.ts#L2441-L2447\nfunction getNameFromPropertyName(name: ts.PropertyName): string | undefined {\n  if (ts.isComputedPropertyName(name)) {\n    return ts.isStringLiteralLike(name.expression) ||\n      ts.isNumericLiteral(name.expression)\n      ? name.expression.text\n      : undefined;\n  } else if (ts.isPrivateIdentifier(name) || ts.isMemberName(name)) {\n    return ts.idText(name);\n  } else {\n    return name.text;\n  }\n}\n\n/** Resolves the declaration of an identifier.\n * @remarks\n * This returns the declaration node first found for an identifier by resolving an identifier's\n * symbol via the type checker.\n * @privateRemarks\n * This mirrors the implementation of `getDefinitionAtPosition` in TS' language service. However,\n * it removes all cases that aren't applicable to identifiers and removes the intermediary positional\n * data structure, instead returning raw AST nodes.\n */\nexport function getDeclarationOfIdentifier(\n  node: ts.Identifier,\n  checker: ts.TypeChecker\n): ValueDeclaration | undefined {\n  // See: https://github.com/microsoft/TypeScript/blob/a5eec24/src/services/goToDefinition.ts#L523-L540\n  let symbol = checker.getSymbolAtLocation(node);\n  if (\n    symbol?.declarations?.[0] &&\n    symbol.flags & ts.SymbolFlags.Alias &&\n    (node.parent === symbol?.declarations?.[0] ||\n      !ts.isNamespaceImport(symbol.declarations[0]))\n  ) {\n    // Resolve alias symbols, excluding self-referential symbols\n    const aliased = checker.getAliasedSymbol(symbol);\n    if (aliased.declarations) symbol = aliased;\n  }\n\n  if (symbol && ts.isShorthandPropertyAssignment(node.parent)) {\n    // See: https://github.com/microsoft/TypeScript/blob/a5eec24/src/services/goToDefinition.ts#L248-L257\n    // Resolve shorthand property assignments\n    const shorthandSymbol = checker.getShorthandAssignmentValueSymbol(\n      symbol.valueDeclaration\n    );\n    if (shorthandSymbol) symbol = shorthandSymbol;\n  } else if (\n    ts.isBindingElement(node.parent) &&\n    ts.isObjectBindingPattern(node.parent.parent) &&\n    node === (node.parent.propertyName || node.parent.name)\n  ) {\n    // See: https://github.com/microsoft/TypeScript/blob/a5eec24/src/services/goToDefinition.ts#L259-L280\n    // Resolve symbol of property in shorthand assignments\n    const name = getNameFromPropertyName(node);\n    const prop = name\n      ? checker.getTypeAtLocation(node.parent.parent).getProperty(name)\n      : undefined;\n    if (prop) symbol = prop;\n  } else if (\n    ts.isObjectLiteralElement(node.parent) &&\n    (ts.isObjectLiteralExpression(node.parent.parent) ||\n      ts.isJsxAttributes(node.parent.parent)) &&\n    node.parent.name === node\n  ) {\n    // See: https://github.com/microsoft/TypeScript/blob/a5eec24/src/services/goToDefinition.ts#L298-L316\n    // Resolve symbol of property in object literal destructre expressions\n    const name = getNameFromPropertyName(node);\n    const prop = name\n      ? checker.getContextualType(node.parent.parent)?.getProperty(name)\n      : undefined;\n    if (prop) symbol = prop;\n  }\n\n  if (symbol && symbol.declarations?.length) {\n    if (\n      symbol.flags & ts.SymbolFlags.Class &&\n      !(symbol.flags & (ts.SymbolFlags.Function | ts.SymbolFlags.Variable)) &&\n      isNewExpressionTarget(node)\n    ) {\n      // See: https://github.com/microsoft/TypeScript/blob/a5eec24/src/services/goToDefinition.ts#L603-L610\n      // Resolve first class-like declaration for new expressions\n      for (const declaration of symbol.declarations) {\n        if (ts.isClassLike(declaration)) return declaration;\n      }\n    } else if (\n      isCallOrNewExpressionTarget(node) ||\n      isNameOfFunctionDeclaration(node)\n    ) {\n      // See: https://github.com/microsoft/TypeScript/blob/a5eec24/src/services/goToDefinition.ts#L612-L616\n      // Resolve first function-like declaration for call expressions or named functions\n      for (const declaration of symbol.declarations) {\n        if (\n          ts.isFunctionLike(declaration) &&\n          !!(declaration as ts.FunctionLikeDeclaration).body &&\n          isValueDeclaration(declaration)\n        ) {\n          return declaration;\n        }\n      }\n    }\n\n    // Account for assignments to property access expressions\n    // This resolves property access expressions to binding element parents\n    if (\n      symbol.valueDeclaration &&\n      ts.isPropertyAccessExpression(symbol.valueDeclaration)\n    ) {\n      const parent = symbol.valueDeclaration.parent;\n      if (\n        parent &&\n        ts.isBinaryExpression(parent) &&\n        parent.left === symbol.valueDeclaration\n      ) {\n        return parent;\n      }\n    }\n\n    if (\n      symbol.valueDeclaration &&\n      isValueDeclaration(symbol.valueDeclaration)\n    ) {\n      // NOTE: We prefer value declarations, since the checker may have already applied conditions\n      // similar to `isValueDeclaration` and selected it beforehand\n      // Only use value declarations if they're not type/ambient declarations or imports/exports\n      return symbol.valueDeclaration;\n    }\n\n    // Selecting the first available result, if any\n    // NOTE: We left out `!isExpandoDeclaration` as a condition, since `valueDeclaration` above\n    // should handle some of these cases, and we don't have to care about this subtlety as much for identifiers\n    // See: https://github.com/microsoft/TypeScript/blob/a5eec24/src/services/goToDefinition.ts#L582-L590\n    for (const declaration of symbol.declarations) {\n      // Only use declarations if they're not type/ambient declarations or imports/exports\n      if (isValueDeclaration(declaration)) return declaration;\n    }\n  }\n\n  return undefined;\n}\n\n/** Loops {@link getDeclarationOfIdentifier} until a value of the identifier is found */\nexport function getValueOfIdentifier(\n  node: ts.Identifier,\n  checker: ts.TypeChecker\n): ValueOfDeclaration | undefined {\n  while (ts.isIdentifier(node)) {\n    const declaration = getDeclarationOfIdentifier(node, checker);\n    if (!declaration) {\n      return undefined;\n    } else {\n      const value = getValueOfValueDeclaration(declaration);\n      if (value && ts.isIdentifier(value) && value !== node) {\n        // If the resolved value is another identifiers, we continue searching, if the\n        // identifier isn't self-referential\n        node = value;\n      } else {\n        return value;\n      }\n    }\n  }\n}\n\n/** Resolves exressions that might not influence the target identifier */\nexport function getIdentifierOfChainExpression(\n  node: ts.Expression\n): ts.Identifier | undefined {\n  let target: ts.Expression | undefined = node;\n  while (target) {\n    if (ts.isPropertyAccessExpression(target)) {\n      target = target.name;\n    } else if (\n      ts.isAsExpression(target) ||\n      ts.isSatisfiesExpression(target) ||\n      ts.isNonNullExpression(target) ||\n      ts.isParenthesizedExpression(target) ||\n      ts.isExpressionWithTypeArguments(target)\n    ) {\n      target = target.expression;\n    } else if (ts.isCommaListExpression(target)) {\n      target = target.elements[target.elements.length - 1];\n    } else if (ts.isIdentifier(target)) {\n      return target;\n    } else {\n      return;\n    }\n  }\n}\n","import { print } from '@0no-co/graphql.web';\nimport { ts } from '../ts';\nimport {\n  getDeclarationOfIdentifier,\n  getValueOfValueDeclaration,\n} from './declaration';\n\ntype TemplateResult = {\n  combinedText: string;\n  resolvedSpans: Array<{\n    lines: number;\n    identifier: string;\n    original: { start: number; length: number };\n    new: { start: number; length: number };\n  }>;\n};\n\nexport function resolveTemplate(\n  node: ts.TaggedTemplateExpression | ts.StringLiteralLike,\n  filename: string,\n  info: ts.server.PluginCreateInfo\n): TemplateResult {\n  if (ts.isStringLiteralLike(node)) {\n    return { combinedText: node.getText().slice(1, -1), resolvedSpans: [] };\n  }\n\n  let templateText = node.template.getText().slice(1, -1);\n  if (\n    ts.isNoSubstitutionTemplateLiteral(node.template) ||\n    node.template.templateSpans.length === 0\n  ) {\n    return { combinedText: templateText, resolvedSpans: [] };\n  }\n\n  let addedCharacters = 0;\n  const resolvedSpans = node.template.templateSpans\n    .map(span => {\n      if (ts.isIdentifier(span.expression)) {\n        const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n        if (!typeChecker) return;\n\n        const declaration = getDeclarationOfIdentifier(\n          span.expression,\n          typeChecker\n        );\n        if (!declaration) return;\n\n        const parent = declaration;\n        if (ts.isVariableDeclaration(parent)) {\n          const identifierName = span.expression.escapedText;\n          const value = getValueOfValueDeclaration(parent);\n          if (!value) return;\n\n          // we reduce by two to account for the \"${\"\n          const originalStart = span.expression.getStart() - 2;\n          const originalRange = {\n            start: originalStart,\n            // we add 1 to account for the \"}\"\n            length: span.expression.end - originalStart + 1,\n          };\n\n          if (ts.isTaggedTemplateExpression(value)) {\n            const text = resolveTemplate(\n              value,\n              parent.getSourceFile().fileName,\n              info\n            );\n            templateText = templateText.replace(\n              '${' + span.expression.escapedText + '}',\n              text.combinedText\n            );\n\n            const alteredSpan = {\n              lines: text.combinedText.split('\\n').length,\n              identifier: identifierName,\n              original: originalRange,\n              new: {\n                start: originalRange.start + addedCharacters,\n                length: text.combinedText.length,\n              },\n            };\n            addedCharacters += text.combinedText.length - originalRange.length;\n            return alteredSpan;\n          } else if (\n            ts.isAsExpression(value) &&\n            ts.isTaggedTemplateExpression(value.expression)\n          ) {\n            const text = resolveTemplate(\n              value.expression,\n              parent.getSourceFile().fileName,\n              info\n            );\n            templateText = templateText.replace(\n              '${' + span.expression.escapedText + '}',\n              text.combinedText\n            );\n            const alteredSpan = {\n              lines: text.combinedText.split('\\n').length,\n              identifier: identifierName,\n              original: originalRange,\n              new: {\n                start: originalRange.start + addedCharacters,\n                length: text.combinedText.length,\n              },\n            };\n            addedCharacters += text.combinedText.length - originalRange.length;\n            return alteredSpan;\n          } else if (\n            ts.isAsExpression(value) &&\n            ts.isAsExpression(value.expression) &&\n            ts.isObjectLiteralExpression(value.expression.expression)\n          ) {\n            const astObject = JSON.parse(value.expression.expression.getText());\n            const resolvedTemplate = print(astObject);\n            templateText = templateText.replace(\n              '${' + span.expression.escapedText + '}',\n              resolvedTemplate\n            );\n            const alteredSpan = {\n              lines: resolvedTemplate.split('\\n').length,\n              identifier: identifierName,\n              original: originalRange,\n              new: {\n                start: originalRange.start + addedCharacters,\n                length: resolvedTemplate.length,\n              },\n            };\n            addedCharacters += resolvedTemplate.length - originalRange.length;\n            return alteredSpan;\n          }\n\n          return undefined;\n        }\n      }\n\n      return undefined;\n    })\n    .filter(Boolean) as TemplateResult['resolvedSpans'];\n\n  return { combinedText: templateText, resolvedSpans };\n}\n\nexport const resolveTadaFragmentArray = (\n  node: ts.Expression | undefined\n): undefined | readonly ts.Identifier[] => {\n  if (!node) return undefined;\n  // NOTE: Remove `as T`, users may commonly use `as const` for no reason\n  while (ts.isAsExpression(node)) node = node.expression;\n  if (!ts.isArrayLiteralExpression(node)) return undefined;\n  // NOTE: Let's avoid the allocation of another array here if we can\n  if (node.elements.every(ts.isIdentifier)) return node.elements;\n  const identifiers: ts.Identifier[] = [];\n  for (let element of node.elements) {\n    while (ts.isPropertyAccessExpression(element)) element = element.name;\n    if (ts.isIdentifier(element)) identifiers.push(element);\n  }\n  return identifiers;\n};\n","import { ts } from '../ts';\nimport { FragmentDefinitionNode, parse } from 'graphql';\nimport * as checks from './checks';\nimport { resolveTadaFragmentArray } from './resolve';\nimport {\n  getDeclarationOfIdentifier,\n  getValueOfIdentifier,\n  getIdentifierOfChainExpression,\n} from './declaration';\n\nexport { getSchemaName } from './checks';\n\nexport function getSource(info: ts.server.PluginCreateInfo, filename: string) {\n  const program = info.languageService.getProgram();\n  if (!program) return undefined;\n\n  const source = program.getSourceFile(filename);\n  if (!source) return undefined;\n\n  return source;\n}\n\nexport function findNode(\n  sourceFile: ts.SourceFile,\n  position: number\n): ts.Node | undefined {\n  function find(node: ts.Node): ts.Node | undefined {\n    if (position >= node.getStart() && position < node.getEnd()) {\n      return ts.forEachChild(node, find) || node;\n    }\n  }\n  return find(sourceFile);\n}\n\nexport function findAllTaggedTemplateNodes(\n  sourceFile: ts.SourceFile | ts.Node\n): Array<ts.TaggedTemplateExpression | ts.NoSubstitutionTemplateLiteral> {\n  const result: Array<\n    ts.TaggedTemplateExpression | ts.NoSubstitutionTemplateLiteral\n  > = [];\n  function find(node: ts.Node) {\n    if (\n      checks.isGraphQLTag(node) ||\n      (ts.isNoSubstitutionTemplateLiteral(node) &&\n        checks.isGraphQLTag(node.parent))\n    ) {\n      result.push(node);\n      return;\n    } else {\n      ts.forEachChild(node, find);\n    }\n  }\n  find(sourceFile);\n  return result;\n}\n\nfunction resolveIdentifierToGraphQLCall(\n  input: ts.Identifier,\n  info: ts.server.PluginCreateInfo,\n  checker: ts.TypeChecker | undefined\n): checks.GraphQLCallNode | null {\n  if (!checker) return null;\n\n  const value = getValueOfIdentifier(input, checker);\n  if (!value) return null;\n\n  // Check whether we've got a `graphql()` or `gql()` call\n  return checks.isGraphQLCall(value, checker) ? value : null;\n}\n\nexport function unrollFragment(\n  element: ts.Identifier,\n  info: ts.server.PluginCreateInfo,\n  checker: ts.TypeChecker | undefined\n): Array<FragmentDefinitionNode> {\n  const fragments: FragmentDefinitionNode[] = [];\n  const elements: ts.Identifier[] = [element];\n  const seen = new WeakSet<ts.Identifier>();\n\n  const _unrollElement = (element: ts.Identifier): void => {\n    if (seen.has(element)) return;\n    seen.add(element);\n\n    const node = resolveIdentifierToGraphQLCall(element, info, checker);\n    if (!node) return;\n\n    const fragmentRefs = resolveTadaFragmentArray(node.arguments[1]);\n    if (fragmentRefs) elements.push(...fragmentRefs);\n\n    try {\n      const text = node.arguments[0];\n      const parsed = parse(text.getText().slice(1, -1), { noLocation: true });\n      parsed.definitions.forEach(definition => {\n        if (definition.kind === 'FragmentDefinition') {\n          fragments.push(definition);\n        }\n      });\n    } catch (_error) {\n      // NOTE: Assume graphql.parse errors can be ignored\n    }\n  };\n\n  let nextElement: ts.Identifier | undefined;\n  while ((nextElement = elements.shift()) !== undefined)\n    _unrollElement(nextElement);\n  return fragments;\n}\n\nexport function unrollTadaFragments(\n  fragmentsArray: ts.ArrayLiteralExpression,\n  wip: FragmentDefinitionNode[],\n  info: ts.server.PluginCreateInfo\n): FragmentDefinitionNode[] {\n  const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n  fragmentsArray.elements.forEach(element => {\n    if (ts.isIdentifier(element)) {\n      wip.push(...unrollFragment(element, info, typeChecker));\n    } else if (ts.isPropertyAccessExpression(element)) {\n      let el = element;\n      while (ts.isPropertyAccessExpression(el.expression)) el = el.expression;\n      if (ts.isIdentifier(el.name)) {\n        wip.push(...unrollFragment(el.name, info, typeChecker));\n      }\n    }\n  });\n\n  return wip;\n}\n\nexport function findAllCallExpressions(\n  sourceFile: ts.SourceFile,\n  info: ts.server.PluginCreateInfo,\n  shouldSearchFragments: boolean = true\n): {\n  nodes: Array<{\n    node: ts.StringLiteralLike;\n    schema: string | null;\n    // For gql.tada call-expressions, this contains the identifiers of explicitly declared fragments\n    tadaFragmentRefs?: readonly ts.Identifier[] | null;\n  }>;\n  fragments: Array<FragmentDefinitionNode>;\n} {\n  const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n  const result: Array<{\n    node: ts.StringLiteralLike;\n    schema: string | null;\n    tadaFragmentRefs?: readonly ts.Identifier[];\n  }> = [];\n  let fragments: Array<FragmentDefinitionNode> = [];\n  let hasTriedToFindFragments = shouldSearchFragments ? false : true;\n\n  function find(node: ts.Node): void {\n    if (!ts.isCallExpression(node) || checks.isIIFE(node)) {\n      return ts.forEachChild(node, find);\n    }\n\n    // Check whether we've got a `graphql()` or `gql()` call, by the\n    // call expression's identifier\n    if (!checks.isGraphQLCall(node, typeChecker)) {\n      return ts.forEachChild(node, find);\n    }\n\n    const name = checks.getSchemaName(node, typeChecker);\n    const text = node.arguments[0];\n    const fragmentRefs = resolveTadaFragmentArray(node.arguments[1]);\n    const isTadaCall = checks.isTadaGraphQLCall(node, typeChecker);\n\n    if (!hasTriedToFindFragments && !fragmentRefs) {\n      // Only collect global fragments if this is NOT a gql.tada call\n      if (!isTadaCall) {\n        hasTriedToFindFragments = true;\n        fragments.push(...getAllFragments(node, info));\n      }\n    } else if (fragmentRefs) {\n      for (const identifier of fragmentRefs) {\n        fragments.push(...unrollFragment(identifier, info, typeChecker));\n      }\n    }\n\n    if (text && ts.isStringLiteralLike(text)) {\n      result.push({\n        node: text,\n        schema: name,\n        tadaFragmentRefs: isTadaCall\n          ? fragmentRefs === undefined\n            ? []\n            : fragmentRefs\n          : undefined,\n      });\n    }\n  }\n  find(sourceFile);\n  return { nodes: result, fragments };\n}\n\nexport function findAllPersistedCallExpressions(\n  sourceFile: ts.SourceFile\n): Array<ts.CallExpression>;\nexport function findAllPersistedCallExpressions(\n  sourceFile: ts.SourceFile,\n  info: ts.server.PluginCreateInfo\n): Array<{ node: ts.CallExpression; schema: string | null }>;\n\nexport function findAllPersistedCallExpressions(\n  sourceFile: ts.SourceFile,\n  info?: ts.server.PluginCreateInfo\n) {\n  const result: Array<\n    ts.CallExpression | { node: ts.CallExpression; schema: string | null }\n  > = [];\n  const typeChecker = info?.languageService.getProgram()?.getTypeChecker();\n  function find(node: ts.Node): void {\n    if (!ts.isCallExpression(node) || checks.isIIFE(node)) {\n      return ts.forEachChild(node, find);\n    }\n\n    if (!checks.isTadaPersistedCall(node, typeChecker)) {\n      return;\n    } else if (info) {\n      const name = checks.getSchemaName(node, typeChecker, true);\n      result.push({ node, schema: name });\n    } else {\n      result.push(node);\n    }\n  }\n  find(sourceFile);\n  return result;\n}\n\nexport function getAllFragments(\n  node: ts.Node,\n  info: ts.server.PluginCreateInfo\n) {\n  let fragments: Array<FragmentDefinitionNode> = [];\n\n  const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n  if (!ts.isCallExpression(node)) {\n    return fragments;\n  }\n\n  const fragmentRefs = resolveTadaFragmentArray(node.arguments[1]);\n  if (fragmentRefs) {\n    const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n    for (const identifier of fragmentRefs) {\n      fragments.push(...unrollFragment(identifier, info, typeChecker));\n    }\n    return fragments;\n  } else if (checks.isTadaGraphQLCall(node, typeChecker)) {\n    return fragments;\n  }\n\n  if (!typeChecker) return fragments;\n\n  const identifier = getIdentifierOfChainExpression(node.expression);\n  if (!identifier) return fragments;\n\n  const declaration = getDeclarationOfIdentifier(identifier, typeChecker);\n  if (!declaration) return fragments;\n\n  const sourceFile = declaration.getSourceFile();\n  if (!sourceFile) return fragments;\n\n  const definitions = [\n    {\n      fileName: sourceFile.fileName,\n      textSpan: {\n        start: declaration.getStart(),\n        length: declaration.getWidth(),\n      },\n    },\n  ];\n  if (!definitions || !definitions.length) return fragments;\n\n  const def = definitions[0];\n  if (!def) return fragments;\n  const src = getSource(info, def.fileName);\n  if (!src) return fragments;\n\n  ts.forEachChild(src, node => {\n    if (\n      ts.isVariableStatement(node) &&\n      node.declarationList &&\n      node.declarationList.declarations[0] &&\n      node.declarationList.declarations[0].name.getText() === 'documents'\n    ) {\n      const [declaration] = node.declarationList.declarations;\n      if (\n        declaration.initializer &&\n        ts.isObjectLiteralExpression(declaration.initializer)\n      ) {\n        declaration.initializer.properties.forEach(property => {\n          if (\n            ts.isPropertyAssignment(property) &&\n            ts.isStringLiteral(property.name)\n          ) {\n            try {\n              const possibleFragment = JSON.parse(\n                `${property.name.getText().replace(/'/g, '\"')}`\n              );\n\n              if (\n                possibleFragment.includes('fragment ') &&\n                possibleFragment.includes(' on ')\n              ) {\n                const parsed = parse(possibleFragment, {\n                  noLocation: true,\n                });\n                parsed.definitions.forEach(definition => {\n                  if (definition.kind === 'FragmentDefinition') {\n                    fragments.push(definition);\n                  }\n                });\n              }\n            } catch (e: any) {}\n          }\n        });\n      }\n    }\n  });\n\n  return fragments;\n}\n\nexport function findAllImports(\n  sourceFile: ts.SourceFile\n): Array<ts.ImportDeclaration> {\n  return sourceFile.statements.filter(ts.isImportDeclaration);\n}\n\nexport function findAllMaskFragmentsCalls(\n  sourceFile: ts.SourceFile\n): Array<ts.CallExpression> {\n  const result: Array<ts.CallExpression> = [];\n\n  function find(node: ts.Node): void {\n    if (checks.isMaskFragmentsCall(node)) {\n      result.push(node);\n    }\n    ts.forEachChild(node, find);\n  }\n  find(sourceFile);\n  return result;\n}\n\nexport function bubbleUpTemplate(node: ts.Node): ts.Node {\n  while (\n    ts.isNoSubstitutionTemplateLiteral(node) ||\n    ts.isToken(node) ||\n    ts.isTemplateExpression(node) ||\n    ts.isTemplateSpan(node)\n  ) {\n    node = node.parent;\n  }\n\n  return node;\n}\n\nexport function bubbleUpCallExpression(node: ts.Node): ts.Node {\n  while (\n    ts.isStringLiteralLike(node) ||\n    ts.isToken(node) ||\n    ts.isTemplateExpression(node) ||\n    ts.isTemplateSpan(node)\n  ) {\n    node = node.parent;\n  }\n\n  return node;\n}\n","/**\n * @module LRUCache\n */\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */\nexport class LRUCache {\n    // properties coming in from the options of these, only max and maxSize\n    // really *need* to be protected. The rest can be modified, as they just\n    // set defaults for various methods.\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the remaining TTL time for a given entry key\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.delete(this.#keyList[index]);\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (ttl === 0 || start === 0) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            return (ttls[index] !== 0 &&\n                starts[index] !== 0 &&\n                (cachedNow || getNow()) - starts[index] > ttls[index]);\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to Array.find().  fn is called as fn(value, key, cache).\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from\n     * most recently used to least recently used.  fn is called as\n     * fn(value, key, cache).  Does not update age or recenty of use.\n     * Does not iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.delete(this.#keyList[i]);\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to cache.load()\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     * Note that the shape of the resulting cache may be different if the\n     * same options are not used in both caches.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.delete(k);\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined &&\n            (allowStale || !this.#isStale(index))) {\n            const v = this.#valList[index];\n            // either stale and allowed, or forcing a refresh of non-stale value\n            return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n        }\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.delete(k);\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.delete(k);\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.delete(k);\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.clear();\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, 'delete');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, 'delete']);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        this.#next[this.#prev[index]] = this.#next[index];\n                        this.#prev[this.#next[index]] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, 'delete');\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, 'delete']);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","'use strict';\n\n// FNV_PRIMES and FNV_OFFSETS from\n// http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param\n\nconst FNV_PRIMES = {\n\t32: 16777619n,\n\t64: 1099511628211n,\n\t128: 309485009821345068724781371n,\n\t256: 374144419156711147060143317175368453031918731002211n,\n\t512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,\n\t1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n\n};\n\nconst FNV_OFFSETS = {\n\t32: 2166136261n,\n\t64: 14695981039346656037n,\n\t128: 144066263297769815596495629667062367629n,\n\t256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,\n\t512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,\n\t1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n\n};\n\n// Legacy implementation for 32-bit + number types\nfunction fnv1a(string) {\n\t// Handle Unicode code points > 0x7f\n\tlet hash = Number(FNV_OFFSETS[32]);\n\tlet isUnicoded = false;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet characterCode = string.charCodeAt(i);\n\n\t\t// Non-ASCII characters trigger the Unicode escape logic\n\t\tif (characterCode > 0x7F && !isUnicoded) {\n\t\t\tstring = unescape(encodeURIComponent(string));\n\t\t\tcharacterCode = string.charCodeAt(i);\n\t\t\tisUnicoded = true;\n\t\t}\n\n\t\thash ^= characterCode;\n\t\thash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n\t}\n\n\treturn hash >>> 0;\n}\n\nfunction bigInt(string, {size = 32} = {}) {\n\tif (!FNV_PRIMES[size]) {\n\t\tthrow new Error('The `size` option must be one of 32, 64, 128, 256, 512, or 1024');\n\t}\n\n\tlet hash = FNV_OFFSETS[size];\n\tconst fnvPrime = FNV_PRIMES[size];\n\n\t// Handle Unicode code points > 0x7f\n\tlet isUnicoded = false;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet characterCode = string.charCodeAt(i);\n\n\t\t// Non-ASCII characters trigger the Unicode escape logic\n\t\tif (characterCode > 0x7F && !isUnicoded) {\n\t\t\tstring = unescape(encodeURIComponent(string));\n\t\t\tcharacterCode = string.charCodeAt(i);\n\t\t\tisUnicoded = true;\n\t\t}\n\n\t\thash ^= BigInt(characterCode);\n\t\thash = BigInt.asUintN(size, hash * fnvPrime);\n\t}\n\n\treturn hash;\n}\n\nmodule.exports = fnv1a;\nmodule.exports.bigInt = bigInt;\n","import { ts } from './ts';\nimport { parse, visit } from 'graphql';\n\nimport { findNode } from './ast';\nimport { getValueOfIdentifier } from './ast/declaration';\n\nexport const UNUSED_FIELD_CODE = 52005;\n\nconst unwrapAbstractType = (type: ts.Type) => {\n  return type.isUnionOrIntersection()\n    ? type.types.find(type => type.flags & ts.TypeFlags.Object) || type\n    : type;\n};\n\nconst getVariableDeclaration = (\n  start: ts.Node\n): ts.VariableDeclaration | undefined => {\n  let node: ts.Node = start;\n  const seen = new Set();\n  while (node.parent && !seen.has(node)) {\n    seen.add(node);\n    if (ts.isBlock(node)) {\n      return; // NOTE: We never want to traverse up into a new function/module block\n    } else if (ts.isVariableDeclaration((node = node.parent))) {\n      return node;\n    }\n  }\n};\n\nconst traverseArrayDestructuring = (\n  node: ts.ArrayBindingPattern,\n  originalWip: Array<string>,\n  allFields: Array<string>,\n  source: ts.SourceFile,\n  info: ts.server.PluginCreateInfo\n): Array<string> => {\n  return node.elements.flatMap(element => {\n    if (ts.isOmittedExpression(element)) return [];\n\n    const wip = [...originalWip];\n    return ts.isIdentifier(element.name)\n      ? crawlScope(element.name, wip, allFields, source, info, false)\n      : ts.isObjectBindingPattern(element.name)\n      ? traverseDestructuring(element.name, wip, allFields, source, info)\n      : traverseArrayDestructuring(element.name, wip, allFields, source, info);\n  });\n};\n\nconst traverseDestructuring = (\n  node: ts.ObjectBindingPattern,\n  originalWip: Array<string>,\n  allFields: Array<string>,\n  source: ts.SourceFile,\n  info: ts.server.PluginCreateInfo\n): Array<string> => {\n  const results = [];\n  for (const binding of node.elements) {\n    if (ts.isObjectBindingPattern(binding.name)) {\n      const wip = [...originalWip];\n      if (\n        binding.propertyName &&\n        !originalWip.includes(binding.propertyName.getText())\n      ) {\n        const joined = [...wip, binding.propertyName.getText()].join('.');\n        if (allFields.find(x => x.startsWith(joined))) {\n          wip.push(binding.propertyName.getText());\n        }\n      }\n      const traverseResult = traverseDestructuring(\n        binding.name,\n        wip,\n        allFields,\n        source,\n        info\n      );\n\n      results.push(...traverseResult);\n    } else if (ts.isIdentifier(binding.name)) {\n      const wip = [...originalWip];\n      if (\n        binding.propertyName &&\n        !originalWip.includes(binding.propertyName.getText())\n      ) {\n        const joined = [...wip, binding.propertyName.getText()].join('.');\n        if (allFields.find(x => x.startsWith(joined))) {\n          wip.push(binding.propertyName.getText());\n        }\n      } else {\n        const joined = [...wip, binding.name.getText()].join('.');\n        if (allFields.find(x => x.startsWith(joined))) {\n          wip.push(binding.name.getText());\n        }\n      }\n\n      const crawlResult = crawlScope(\n        binding.name,\n        wip,\n        allFields,\n        source,\n        info,\n        false\n      );\n\n      results.push(...crawlResult);\n    }\n  }\n\n  return results;\n};\n\nconst arrayMethods = new Set([\n  'map',\n  'filter',\n  'forEach',\n  'reduce',\n  'every',\n  'some',\n  'find',\n  'flatMap',\n  'sort',\n]);\n\nconst crawlChainedExpressions = (\n  ref: ts.CallExpression,\n  pathParts: string[],\n  allFields: string[],\n  source: ts.SourceFile,\n  info: ts.server.PluginCreateInfo\n): string[] => {\n  const isChained =\n    ts.isPropertyAccessExpression(ref.expression) &&\n    arrayMethods.has(ref.expression.name.text);\n  if (isChained) {\n    const foundRef = ref.expression;\n    const isReduce = foundRef.name.text === 'reduce';\n    let func: ts.Expression | ts.FunctionDeclaration | undefined =\n      ref.arguments[0];\n\n    const res = [];\n    if (ts.isCallExpression(ref.parent.parent)) {\n      const nestedResult = crawlChainedExpressions(\n        ref.parent.parent,\n        pathParts,\n        allFields,\n        source,\n        info\n      );\n      if (nestedResult.length) {\n        res.push(...nestedResult);\n      }\n    }\n\n    if (func && ts.isIdentifier(func)) {\n      // TODO: Scope utilities in checkFieldUsageInFile to deduplicate\n      const checker = info.languageService.getProgram()!.getTypeChecker();\n\n      const value = getValueOfIdentifier(func, checker);\n      if (\n        value &&\n        (ts.isFunctionDeclaration(value) ||\n          ts.isFunctionExpression(value) ||\n          ts.isArrowFunction(value))\n      ) {\n        func = value;\n      }\n    }\n\n    if (\n      func &&\n      (ts.isFunctionDeclaration(func) ||\n        ts.isFunctionExpression(func) ||\n        ts.isArrowFunction(func))\n    ) {\n      const param = func.parameters[isReduce ? 1 : 0];\n      if (param) {\n        const scopedResult = crawlScope(\n          param.name,\n          pathParts,\n          allFields,\n          source,\n          info,\n          true\n        );\n\n        if (scopedResult.length) {\n          res.push(...scopedResult);\n        }\n      }\n    }\n\n    return res;\n  }\n\n  return [];\n};\n\nconst crawlScope = (\n  node: ts.BindingName,\n  originalWip: Array<string>,\n  allFields: Array<string>,\n  source: ts.SourceFile,\n  info: ts.server.PluginCreateInfo,\n  inArrayMethod: boolean\n): Array<string> => {\n  if (ts.isObjectBindingPattern(node)) {\n    return traverseDestructuring(node, originalWip, allFields, source, info);\n  } else if (ts.isArrayBindingPattern(node)) {\n    return traverseArrayDestructuring(\n      node,\n      originalWip,\n      allFields,\n      source,\n      info\n    );\n  }\n\n  let results: string[] = [];\n\n  const references = info.languageService.getReferencesAtPosition(\n    source.fileName,\n    node.getStart()\n  );\n\n  if (!references) return results;\n\n  // Go over all the references tied to the result of\n  // accessing our equery and collect them as fully\n  // qualified paths (ideally ending in a leaf-node)\n  results = references.flatMap(ref => {\n    // If we get a reference to a different file we can bail\n    if (ref.fileName !== source.fileName) return [];\n    // We don't want to end back at our document so we narrow\n    // the scope.\n    if (\n      node.getStart() <= ref.textSpan.start &&\n      node.getEnd() >= ref.textSpan.start + ref.textSpan.length\n    )\n      return [];\n\n    let foundRef = findNode(source, ref.textSpan.start);\n    if (!foundRef) return [];\n\n    const pathParts = [...originalWip];\n    // In here we'll start crawling all the accessors of result\n    // and try to determine the total path\n    // - result.data.pokemon.name --> pokemon.name this is the easy route and never accesses\n    //   any of the recursive functions\n    // - const pokemon = result.data.pokemon --> this initiates a new crawl with a renewed scope\n    // - const { pokemon } = result.data --> this initiates a destructuring traversal which will\n    //   either end up in more destructuring traversals or a scope crawl\n    while (\n      ts.isIdentifier(foundRef) ||\n      ts.isPropertyAccessExpression(foundRef) ||\n      ts.isElementAccessExpression(foundRef) ||\n      ts.isVariableDeclaration(foundRef) ||\n      ts.isBinaryExpression(foundRef) ||\n      ts.isReturnStatement(foundRef) ||\n      ts.isArrowFunction(foundRef)\n    ) {\n      if (\n        !inArrayMethod &&\n        (ts.isReturnStatement(foundRef) || ts.isArrowFunction(foundRef))\n      ) {\n        // When we are returning the ref or we are dealing with an implicit return\n        // we mark all its children as used (bail scenario)\n        const joined = pathParts.join('.');\n        const bailedFields = allFields.filter(x => x.startsWith(joined + '.'));\n        return bailedFields;\n      } else if (ts.isVariableDeclaration(foundRef)) {\n        return crawlScope(\n          foundRef.name,\n          pathParts,\n          allFields,\n          source,\n          info,\n          false\n        );\n      } else if (\n        ts.isIdentifier(foundRef) &&\n        !pathParts.includes(foundRef.text)\n      ) {\n        const joined = [...pathParts, foundRef.text].join('.');\n        if (allFields.find(x => x.startsWith(joined + '.'))) {\n          pathParts.push(foundRef.text);\n        }\n\n        // When we encounter an external function where we use this identifier\n        // we'll mark all of the sub-fields as used as we consider this a bail\n        // scenario.\n        if (ts.isCallExpression(foundRef.parent)) {\n          const callExpression = foundRef.parent;\n          return callExpression.arguments.flatMap(arg => {\n            let parts = [...pathParts];\n            let reference = arg;\n\n            while (ts.isPropertyAccessExpression(reference)) {\n              const joined = [...parts, reference.name.text].join('.');\n              if (allFields.find(x => x.startsWith(joined + '.'))) {\n                parts.push(reference.name.text);\n              }\n              reference = reference.expression;\n            }\n\n            if (ts.isIdentifier(reference)) {\n              const joined = [...parts, reference.getText()].join('.');\n              if (allFields.find(x => x.startsWith(joined + '.'))) {\n                parts.push(reference.getText());\n              }\n            }\n\n            const joined = parts.join('.');\n            return allFields.filter(x => x.startsWith(joined + '.'));\n          });\n        }\n      } else if (\n        ts.isPropertyAccessExpression(foundRef) &&\n        foundRef.name.text === 'at' &&\n        ts.isCallExpression(foundRef.parent)\n      ) {\n        foundRef = foundRef.parent;\n      } else if (\n        ts.isPropertyAccessExpression(foundRef) &&\n        arrayMethods.has(foundRef.name.text) &&\n        ts.isCallExpression(foundRef.parent)\n      ) {\n        const callExpression = foundRef.parent;\n        const res = [];\n        const isSomeOrEvery =\n          foundRef.name.text === 'some' || foundRef.name.text === 'every';\n        const chainedResults = crawlChainedExpressions(\n          callExpression,\n          pathParts,\n          allFields,\n          source,\n          info\n        );\n        if (chainedResults.length) {\n          res.push(...chainedResults);\n        }\n\n        if (ts.isVariableDeclaration(callExpression.parent) && !isSomeOrEvery) {\n          const varRes = crawlScope(\n            callExpression.parent.name,\n            pathParts,\n            allFields,\n            source,\n            info,\n            true\n          );\n          res.push(...varRes);\n        }\n\n        return res;\n      } else if (\n        ts.isPropertyAccessExpression(foundRef) &&\n        !pathParts.includes(foundRef.name.text)\n      ) {\n        const joined = [...pathParts, foundRef.name.text].join('.');\n        if (allFields.find(x => x.startsWith(joined))) {\n          pathParts.push(foundRef.name.text);\n        }\n      } else if (\n        ts.isElementAccessExpression(foundRef) &&\n        ts.isStringLiteral(foundRef.argumentExpression) &&\n        !pathParts.includes(foundRef.argumentExpression.text)\n      ) {\n        const joined = [...pathParts, foundRef.argumentExpression.text].join(\n          '.'\n        );\n        if (allFields.find(x => x.startsWith(joined))) {\n          pathParts.push(foundRef.argumentExpression.text);\n        }\n      }\n\n      if (ts.isNonNullExpression(foundRef.parent)) {\n        foundRef = foundRef.parent.parent;\n      } else {\n        foundRef = foundRef.parent;\n      }\n    }\n\n    return pathParts.join('.');\n  });\n\n  return results;\n};\n\nexport const checkFieldUsageInFile = (\n  source: ts.SourceFile,\n  nodes: ts.NoSubstitutionTemplateLiteral[],\n  info: ts.server.PluginCreateInfo\n) => {\n  const diagnostics: ts.Diagnostic[] = [];\n  const shouldTrackFieldUsage = info.config.trackFieldUsage ?? true;\n  if (!shouldTrackFieldUsage) return diagnostics;\n\n  const defaultReservedKeys = ['id', '_id', '__typename'];\n  const additionalKeys = info.config.reservedKeys ?? [];\n  const reservedKeys = new Set([...defaultReservedKeys, ...additionalKeys]);\n  const checker = info.languageService.getProgram()?.getTypeChecker();\n  if (!checker) return;\n\n  try {\n    nodes.forEach(node => {\n      const nodeText = node.getText();\n      // Bailing for mutations/subscriptions as these could have small details\n      // for normalised cache interactions\n      if (nodeText.includes('mutation') || nodeText.includes('subscription'))\n        return;\n\n      const variableDeclaration = getVariableDeclaration(node);\n      if (!variableDeclaration) return;\n\n      let dataType: ts.Type | undefined;\n\n      const type = checker.getTypeAtLocation(node.parent) as\n        | ts.TypeReference\n        | ts.Type;\n      // Attempt to retrieve type from internally resolve type arguments\n      if ('target' in type) {\n        const typeArguments = (type as any)\n          .resolvedTypeArguments as readonly ts.Type[];\n        dataType =\n          typeArguments && typeArguments.length > 1\n            ? typeArguments[0]\n            : undefined;\n      }\n      // Fallback to resolving the type from scratch\n      if (!dataType) {\n        const apiTypeSymbol = type.getProperty('__apiType');\n        if (apiTypeSymbol) {\n          let apiType = checker.getTypeOfSymbol(apiTypeSymbol);\n          let callSignature: ts.Signature | undefined =\n            type.getCallSignatures()[0];\n          if (apiType.isUnionOrIntersection()) {\n            for (const type of apiType.types) {\n              callSignature = type.getCallSignatures()[0];\n              if (callSignature) {\n                dataType = callSignature.getReturnType();\n                break;\n              }\n            }\n          }\n          dataType = callSignature && callSignature.getReturnType();\n        }\n      }\n\n      const references = info.languageService.getReferencesAtPosition(\n        source.fileName,\n        variableDeclaration.name.getStart()\n      );\n\n      if (!references) return;\n\n      const allAccess: string[] = [];\n      const inProgress: string[] = [];\n      const allPaths: string[] = [];\n      const fieldToLoc = new Map<string, { start: number; length: number }>();\n      // This visitor gets all the leaf-paths in the document\n      // as well as all fields that are part of the document\n      // We need the leaf-paths to check usage and we need the\n      // fields to validate whether an access on a given reference\n      // is valid given the current document...\n      visit(parse(node.getText().slice(1, -1)), {\n        Field: {\n          enter(node) {\n            const alias = node.alias ? node.alias.value : node.name.value;\n            const path = inProgress.length\n              ? `${inProgress.join('.')}.${alias}`\n              : alias;\n\n            if (!node.selectionSet && !reservedKeys.has(node.name.value)) {\n              allPaths.push(path);\n              fieldToLoc.set(path, {\n                start: node.name.loc!.start,\n                length: node.name.loc!.end - node.name.loc!.start,\n              });\n            } else if (node.selectionSet) {\n              inProgress.push(alias);\n              fieldToLoc.set(path, {\n                start: node.name.loc!.start,\n                length: node.name.loc!.end - node.name.loc!.start,\n              });\n            }\n          },\n          leave(node) {\n            if (node.selectionSet) {\n              inProgress.pop();\n            }\n          },\n        },\n      });\n\n      references.forEach(ref => {\n        if (ref.fileName !== source.fileName) return;\n\n        const targetNode = findNode(source, ref.textSpan.start);\n        if (!targetNode) return;\n        // Skip declaration as reference of itself\n        if (targetNode.parent === variableDeclaration) return;\n\n        const scopeSymbols = checker.getSymbolsInScope(\n          targetNode,\n          ts.SymbolFlags.BlockScopedVariable\n        );\n\n        let scopeDataSymbol: ts.Symbol | undefined;\n        for (let scopeSymbol of scopeSymbols) {\n          if (!scopeSymbol.valueDeclaration) continue;\n          let typeOfScopeSymbol = unwrapAbstractType(\n            checker.getTypeOfSymbol(scopeSymbol)\n          );\n          if (dataType === typeOfScopeSymbol) {\n            scopeDataSymbol = scopeSymbol;\n            break;\n          }\n\n          // NOTE: This is an aggressive fallback for hooks where the return value isn't destructured\n          // This is a last resort solution for patterns like react-query, where the fallback that\n          // would otherwise happen below isn't sufficient\n          if (typeOfScopeSymbol.flags & ts.TypeFlags.Object) {\n            const tuplePropertySymbol = typeOfScopeSymbol.getProperty('0');\n            if (tuplePropertySymbol) {\n              typeOfScopeSymbol = checker.getTypeOfSymbol(tuplePropertySymbol);\n              if (dataType === typeOfScopeSymbol) {\n                scopeDataSymbol = scopeSymbol;\n                break;\n              }\n            }\n\n            const dataPropertySymbol = typeOfScopeSymbol.getProperty('data');\n            if (dataPropertySymbol) {\n              typeOfScopeSymbol = unwrapAbstractType(\n                checker.getTypeOfSymbol(dataPropertySymbol)\n              );\n              if (dataType === typeOfScopeSymbol) {\n                scopeDataSymbol = scopeSymbol;\n                break;\n              }\n            }\n          }\n        }\n\n        const valueDeclaration = scopeDataSymbol?.valueDeclaration;\n        let name: ts.BindingName | undefined;\n        if (\n          valueDeclaration &&\n          'name' in valueDeclaration &&\n          !!valueDeclaration.name &&\n          (ts.isIdentifier(valueDeclaration.name as any) ||\n            ts.isBindingName(valueDeclaration.name as any))\n        ) {\n          name = valueDeclaration.name as ts.BindingName;\n        } else {\n          // Fall back to looking at the variable declaration directly,\n          // if we are on one.\n          const variableDeclaration = getVariableDeclaration(targetNode);\n          if (variableDeclaration) name = variableDeclaration.name;\n        }\n\n        if (name) {\n          const result = crawlScope(name, [], allPaths, source, info, false);\n          allAccess.push(...result);\n        }\n      });\n\n      if (!allAccess.length) {\n        return;\n      }\n\n      const unused = allPaths.filter(x => !allAccess.includes(x));\n      const aggregatedUnusedFields = new Set<string>();\n      const unusedChildren: { [key: string]: Set<string> } = {};\n      const unusedFragmentLeaf = new Set<string>();\n      unused.forEach(unusedField => {\n        const split = unusedField.split('.');\n        split.pop();\n        const parentField = split.join('.');\n        const loc = fieldToLoc.get(parentField);\n\n        if (loc) {\n          aggregatedUnusedFields.add(parentField);\n          if (unusedChildren[parentField]) {\n            unusedChildren[parentField]!.add(unusedField);\n          } else {\n            unusedChildren[parentField] = new Set([unusedField]);\n          }\n        } else {\n          unusedFragmentLeaf.add(unusedField);\n        }\n      });\n\n      aggregatedUnusedFields.forEach(field => {\n        const loc = fieldToLoc.get(field)!;\n        const unusedFields = unusedChildren[field]!;\n        diagnostics.push({\n          file: source,\n          length: loc.length,\n          start: node.getStart() + loc.start + 1,\n          category: ts.DiagnosticCategory.Warning,\n          code: UNUSED_FIELD_CODE,\n          messageText: `Field(s) ${[...unusedFields]\n            .map(x => `'${x}'`)\n            .join(', ')} are not used.`,\n        });\n      });\n\n      unusedFragmentLeaf.forEach(field => {\n        const loc = fieldToLoc.get(field)!;\n        diagnostics.push({\n          file: source,\n          length: loc.length,\n          start: node.getStart() + loc.start + 1,\n          category: ts.DiagnosticCategory.Warning,\n          code: UNUSED_FIELD_CODE,\n          messageText: `Field ${field} is not used.`,\n        });\n      });\n    });\n  } catch (e: any) {\n    console.error('[GraphQLSP]: ', e.message, e.stack);\n  }\n\n  return diagnostics;\n};\n","import { ts } from './ts';\nimport { FragmentDefinitionNode, Kind, parse } from 'graphql';\n\nimport { findAllCallExpressions, findAllImports } from './ast';\nimport { resolveTemplate } from './ast/resolve';\nimport { getDeclarationOfIdentifier } from './ast/declaration';\n\nexport const MISSING_FRAGMENT_CODE = 52003;\n\nexport const getColocatedFragmentNames = (\n  source: ts.SourceFile,\n  info: ts.server.PluginCreateInfo\n): Record<\n  string,\n  { start: number; length: number; fragments: Array<string> }\n> => {\n  const imports = findAllImports(source);\n  const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n\n  const importSpecifierToFragments: Record<\n    string,\n    { start: number; length: number; fragments: Array<string> }\n  > = {};\n\n  if (!typeChecker) return importSpecifierToFragments;\n\n  if (imports.length) {\n    imports.forEach(imp => {\n      if (!imp.importClause) return;\n\n      if (imp.importClause.name) {\n        const declaration = getDeclarationOfIdentifier(\n          imp.importClause.name,\n          typeChecker\n        );\n        if (declaration) {\n          const sourceFile = declaration.getSourceFile();\n          if (sourceFile.fileName.includes('node_modules')) return;\n\n          const externalSource = sourceFile;\n          if (!externalSource) return;\n\n          const fragmentsForImport = getFragmentsInSource(\n            externalSource,\n            typeChecker,\n            info\n          );\n\n          const names = fragmentsForImport.map(fragment => fragment.name.value);\n          const key = imp.moduleSpecifier.getText();\n          let fragmentsEntry = importSpecifierToFragments[key];\n          if (names.length && fragmentsEntry) {\n            fragmentsEntry.fragments = fragmentsEntry.fragments.concat(names);\n          } else if (names.length && !fragmentsEntry) {\n            importSpecifierToFragments[key] = fragmentsEntry = {\n              start: imp.moduleSpecifier.getStart(),\n              length: imp.moduleSpecifier.getText().length,\n              fragments: names,\n            };\n          }\n        }\n      }\n\n      if (\n        imp.importClause.namedBindings &&\n        ts.isNamespaceImport(imp.importClause.namedBindings)\n      ) {\n        const declaration = getDeclarationOfIdentifier(\n          imp.importClause.namedBindings.name,\n          typeChecker\n        );\n        if (declaration) {\n          const sourceFile = declaration.getSourceFile();\n          if (sourceFile.fileName.includes('node_modules')) return;\n\n          const externalSource = sourceFile;\n          if (!externalSource) return;\n\n          const fragmentsForImport = getFragmentsInSource(\n            externalSource,\n            typeChecker,\n            info\n          );\n          const names = fragmentsForImport.map(fragment => fragment.name.value);\n          const key = imp.moduleSpecifier.getText();\n          let fragmentsEntry = importSpecifierToFragments[key];\n          if (names.length && fragmentsEntry) {\n            fragmentsEntry.fragments = fragmentsEntry.fragments.concat(names);\n          } else if (names.length && !fragmentsEntry) {\n            importSpecifierToFragments[key] = fragmentsEntry = {\n              start: imp.moduleSpecifier.getStart(),\n              length: imp.moduleSpecifier.getText().length,\n              fragments: names,\n            };\n          }\n        }\n      } else if (\n        imp.importClause.namedBindings &&\n        ts.isNamedImportBindings(imp.importClause.namedBindings)\n      ) {\n        imp.importClause.namedBindings.elements.forEach(el => {\n          const identifier = el.name || el.propertyName;\n          if (!identifier) return;\n\n          const declaration = getDeclarationOfIdentifier(\n            identifier,\n            typeChecker\n          );\n          if (declaration) {\n            const sourceFile = declaration.getSourceFile();\n            if (sourceFile.fileName.includes('node_modules')) return;\n\n            const externalSource = sourceFile;\n            if (!externalSource) return;\n\n            const fragmentsForImport = getFragmentsInSource(\n              externalSource,\n              typeChecker,\n              info\n            );\n            const names = fragmentsForImport.map(\n              fragment => fragment.name.value\n            );\n            const key = imp.moduleSpecifier.getText();\n            let fragmentsEntry = importSpecifierToFragments[key];\n            if (names.length && fragmentsEntry) {\n              fragmentsEntry.fragments = fragmentsEntry.fragments.concat(names);\n            } else if (names.length && !fragmentsEntry) {\n              importSpecifierToFragments[key] = fragmentsEntry = {\n                start: imp.moduleSpecifier.getStart(),\n                length: imp.moduleSpecifier.getText().length,\n                fragments: names,\n              };\n            }\n          }\n        });\n      }\n    });\n  }\n\n  return importSpecifierToFragments;\n};\n\nfunction getFragmentsInSource(\n  src: ts.SourceFile,\n  typeChecker: ts.TypeChecker,\n  info: ts.server.PluginCreateInfo\n): Array<FragmentDefinitionNode> {\n  let fragments: Array<FragmentDefinitionNode> = [];\n  const callExpressions = findAllCallExpressions(src, info, false);\n\n  const symbol = typeChecker.getSymbolAtLocation(src);\n  if (!symbol) return [];\n\n  const exports = typeChecker.getExportsOfModule(symbol);\n  const exportedNames = exports.map(symb => symb.name);\n  const nodes = callExpressions.nodes.filter(x => {\n    let parent = x.node.parent;\n    while (\n      parent &&\n      !ts.isSourceFile(parent) &&\n      !ts.isVariableDeclaration(parent)\n    ) {\n      parent = parent.parent;\n    }\n\n    if (ts.isVariableDeclaration(parent)) {\n      return exportedNames.includes(parent.name.getText());\n    } else {\n      return false;\n    }\n  });\n\n  nodes.forEach(node => {\n    const text = resolveTemplate(node.node, src.fileName, info).combinedText;\n    try {\n      const parsed = parse(text, { noLocation: true });\n      if (parsed.definitions.every(x => x.kind === Kind.FRAGMENT_DEFINITION)) {\n        fragments = fragments.concat(parsed.definitions as any);\n      }\n    } catch (e) {\n      return;\n    }\n  });\n\n  return fragments;\n}\n","import { ts } from './ts';\n\nimport { createHash } from 'crypto';\n\nimport * as checks from './ast/checks';\nimport {\n  findAllCallExpressions,\n  findNode,\n  getSource,\n  unrollTadaFragments,\n} from './ast';\nimport { resolveTemplate } from './ast/resolve';\nimport {\n  FragmentDefinitionNode,\n  Kind,\n  parse,\n  print,\n  visit,\n} from '@0no-co/graphql.web';\nimport {\n  getDeclarationOfIdentifier,\n  getValueOfIdentifier,\n} from './ast/declaration';\n\ntype PersistedAction = {\n  span: {\n    start: number;\n    length: number;\n  };\n  replacement: string;\n};\n\nexport function getPersistedCodeFixAtPosition(\n  filename: string,\n  position: number,\n  info: ts.server.PluginCreateInfo\n): PersistedAction | undefined {\n  const isCallExpression = info.config.templateIsCallExpression ?? true;\n  const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n  if (!isCallExpression) return undefined;\n\n  let source = getSource(info, filename);\n  if (!source) return undefined;\n\n  const node = findNode(source, position);\n  if (!node) return undefined;\n\n  let callExpression: ts.Node = node;\n  // We found a node and need to check where on the path we are\n  // we expect this to look a little bit like\n  // const persistedDoc = graphql.persisted<typeof x>()\n  // When we are on the left half of this statement we bubble down\n  // looking for the correct call-expression and on the right hand\n  // we bubble up.\n  if (ts.isVariableStatement(callExpression)) {\n    callExpression =\n      callExpression.declarationList.declarations.find(declaration => {\n        return (\n          ts.isVariableDeclaration(declaration) &&\n          declaration.initializer &&\n          ts.isCallExpression(declaration.initializer)\n        );\n      }) || node;\n  } else if (ts.isVariableDeclarationList(callExpression)) {\n    callExpression =\n      callExpression.declarations.find(declaration => {\n        return (\n          ts.isVariableDeclaration(declaration) &&\n          declaration.initializer &&\n          ts.isCallExpression(declaration.initializer)\n        );\n      }) || node;\n  } else if (\n    ts.isVariableDeclaration(callExpression) &&\n    callExpression.initializer &&\n    ts.isCallExpression(callExpression.initializer)\n  ) {\n    callExpression = callExpression.initializer;\n  } else {\n    while (callExpression && !ts.isCallExpression(callExpression)) {\n      callExpression = callExpression.parent;\n    }\n  }\n\n  // We want to ensure that we found a call-expression and that it looks\n  // like \"graphql.persisted\", in a future iteration when the API surface\n  // is more defined we will need to use the ts.Symbol to support re-exporting\n  // this function by means of \"export const peristed = graphql.persisted\".\n  if (!checks.isTadaPersistedCall(callExpression, typeChecker)) {\n    return undefined;\n  }\n\n  let foundNode,\n    foundFilename = filename;\n  if (callExpression.typeArguments) {\n    const [typeQuery] = callExpression.typeArguments;\n    if (!typeQuery || !ts.isTypeQueryNode(typeQuery)) return undefined;\n    const { node: found, filename: fileName } =\n      getDocumentReferenceFromTypeQuery(typeQuery, filename, info);\n    foundNode = found;\n    foundFilename = fileName;\n  } else if (callExpression.arguments[1]) {\n    if (\n      !ts.isIdentifier(callExpression.arguments[1]) &&\n      !ts.isCallExpression(callExpression.arguments[1])\n    )\n      return undefined;\n    const { node: found, filename: fileName } =\n      getDocumentReferenceFromDocumentNode(\n        callExpression.arguments[1],\n        filename,\n        info\n      );\n    foundNode = found;\n    foundFilename = fileName;\n  }\n\n  if (!foundNode) return undefined;\n\n  const initializer = foundNode;\n  if (\n    !initializer ||\n    !ts.isCallExpression(initializer) ||\n    !initializer.arguments[0] ||\n    !ts.isStringLiteralLike(initializer.arguments[0])\n  ) {\n    return undefined;\n  }\n\n  const hash = generateHashForDocument(\n    info,\n    initializer.arguments[0],\n    foundFilename,\n    initializer.arguments[1] &&\n      ts.isArrayLiteralExpression(initializer.arguments[1])\n      ? initializer.arguments[1]\n      : undefined\n  );\n  const existingHash = callExpression.arguments[0];\n  // We assume for now that this is either undefined or an existing string literal\n  if (!existingHash) {\n    // We have no persisted-identifier yet, suggest adding in a new one\n    return {\n      span: {\n        start: callExpression.arguments.pos,\n        length: 1,\n      },\n      replacement: `\"sha256:${hash}\")`,\n    };\n  } else if (\n    ts.isStringLiteral(existingHash) &&\n    existingHash.getText() !== `\"sha256:${hash}\"`\n  ) {\n    // We are out of sync, suggest replacing this with the updated hash\n    return {\n      span: {\n        start: existingHash.getStart(),\n        length: existingHash.end - existingHash.getStart(),\n      },\n      replacement: `\"sha256:${hash}\"`,\n    };\n  } else if (ts.isIdentifier(existingHash)) {\n    // Suggest replacing a reference with a static one\n    // this to make these easier to statically analyze\n    return {\n      span: {\n        start: existingHash.getStart(),\n        length: existingHash.end - existingHash.getStart(),\n      },\n      replacement: `\"sha256:${hash}\"`,\n    };\n  } else {\n    return undefined;\n  }\n}\n\nexport const generateHashForDocument = (\n  info: ts.server.PluginCreateInfo,\n  templateLiteral: ts.StringLiteralLike | ts.TaggedTemplateExpression,\n  foundFilename: string,\n  referencedFragments: ts.ArrayLiteralExpression | undefined\n): string | undefined => {\n  if (referencedFragments) {\n    const fragments: Array<FragmentDefinitionNode> = [];\n    unrollTadaFragments(referencedFragments, fragments, info);\n    let text = resolveTemplate(\n      templateLiteral,\n      foundFilename,\n      info\n    ).combinedText;\n    const parsed = parse(text);\n    const seen = new Set<unknown>();\n    for (const definition of parsed.definitions) {\n      if (\n        definition.kind === Kind.FRAGMENT_DEFINITION &&\n        !seen.has(definition)\n      ) {\n        stripUnmaskDirectivesFromDefinition(definition);\n      }\n    }\n\n    const deduplicatedFragments = fragments\n      .map(fragment => {\n        stripUnmaskDirectivesFromDefinition(fragment);\n        return print(fragment);\n      })\n      .filter((fragment, index, array) => array.indexOf(fragment) === index);\n\n    deduplicatedFragments.forEach(fragmentDefinition => {\n      text = `${text}\\n\\n${fragmentDefinition}`;\n    });\n    const fullText = print(parse(text));\n    return createHash('sha256').update(fullText).digest('hex');\n  } else {\n    const externalSource = getSource(info, foundFilename)!;\n    const { fragments } = findAllCallExpressions(externalSource, info);\n\n    const text = resolveTemplate(\n      templateLiteral,\n      foundFilename,\n      info\n    ).combinedText;\n\n    const parsed = parse(text);\n    const seen = new Set<unknown>();\n    for (const definition of parsed.definitions) {\n      if (\n        definition.kind === Kind.FRAGMENT_DEFINITION &&\n        !seen.has(definition)\n      ) {\n        stripUnmaskDirectivesFromDefinition(definition);\n      }\n    }\n\n    const spreads = new Set<string>();\n    visit(parsed, {\n      FragmentDefinition: node => {\n        fragments.push(node);\n      },\n      FragmentSpread: node => {\n        spreads.add(node.name.value);\n      },\n    });\n\n    let resolvedText = text;\n    const visited = new Set();\n    const traversedSpreads = [...spreads];\n\n    let spreadName: string | undefined;\n    while ((spreadName = traversedSpreads.shift())) {\n      visited.add(spreadName);\n      const fragmentDefinition = fragments.find(\n        x => x.name.value === spreadName\n      );\n      if (!fragmentDefinition) {\n        info.project.projectService.logger.info(\n          `[GraphQLSP] could not find fragment for spread ${spreadName}!`\n        );\n        return;\n      }\n\n      stripUnmaskDirectivesFromDefinition(fragmentDefinition);\n\n      visit(fragmentDefinition, {\n        FragmentSpread: node => {\n          if (!visited.has(node.name.value))\n            traversedSpreads.push(node.name.value);\n        },\n      });\n\n      resolvedText = `${resolvedText}\\n\\n${print(fragmentDefinition)}`;\n    }\n\n    return createHash('sha256')\n      .update(print(parse(resolvedText)))\n      .digest('hex');\n  }\n};\n\nexport const getDocumentReferenceFromTypeQuery = (\n  typeQuery: ts.TypeQueryNode,\n  filename: string,\n  info: ts.server.PluginCreateInfo\n): { node: ts.CallExpression | null; filename: string } => {\n  const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n  if (!typeChecker) return { node: null, filename };\n\n  // Handle EntityName (Identifier | QualifiedName)\n  let identifier: ts.Identifier | undefined;\n  if (ts.isIdentifier(typeQuery.exprName)) {\n    identifier = typeQuery.exprName;\n  } else if (ts.isQualifiedName(typeQuery.exprName)) {\n    // For qualified names like 'module.identifier', get the right-most identifier\n    identifier = typeQuery.exprName.right;\n  }\n\n  if (!identifier) return { node: null, filename };\n\n  const value = getValueOfIdentifier(identifier, typeChecker);\n  if (!value || !checks.isGraphQLCall(value, typeChecker)) {\n    return { node: null, filename };\n  }\n\n  return {\n    node: value as ts.CallExpression,\n    filename: value.getSourceFile().fileName,\n  };\n};\n\nexport const getDocumentReferenceFromDocumentNode = (\n  documentNodeArgument: ts.Identifier | ts.CallExpression,\n  filename: string,\n  info: ts.server.PluginCreateInfo\n): { node: ts.CallExpression | null; filename: string } => {\n  if (ts.isIdentifier(documentNodeArgument)) {\n    const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n    if (!typeChecker) return { node: null, filename };\n\n    const value = getValueOfIdentifier(documentNodeArgument, typeChecker);\n    if (!value || !checks.isGraphQLCall(value, typeChecker)) {\n      return { node: null, filename };\n    }\n\n    return {\n      node: value as ts.CallExpression,\n      filename: value.getSourceFile().fileName,\n    };\n  } else {\n    return { node: documentNodeArgument, filename };\n  }\n};\n\ntype writable<T> = { -readonly [K in keyof T]: T[K] };\n\nconst stripUnmaskDirectivesFromDefinition = (\n  definition: FragmentDefinitionNode\n) => {\n  (definition as writable<FragmentDefinitionNode>).directives =\n    definition.directives?.filter(\n      directive => directive.name.value !== '_unmask'\n    );\n};\n","import { ts } from './ts';\nimport { Diagnostic, getDiagnostics } from 'graphql-language-service';\nimport {\n  FragmentDefinitionNode,\n  Kind,\n  OperationDefinitionNode,\n  parse,\n  visit,\n} from 'graphql';\nimport { LRUCache } from 'lru-cache';\nimport fnv1a from '@sindresorhus/fnv1a';\nimport { print } from '@0no-co/graphql.web';\n\nimport {\n  findAllCallExpressions,\n  findAllPersistedCallExpressions,\n  findAllTaggedTemplateNodes,\n  findAllMaskFragmentsCalls,\n  getSource,\n  unrollFragment,\n} from './ast';\nimport { resolveTemplate } from './ast/resolve';\nimport { UNUSED_FIELD_CODE, checkFieldUsageInFile } from './fieldUsage';\nimport {\n  MISSING_FRAGMENT_CODE,\n  getColocatedFragmentNames,\n} from './checkImports';\nimport {\n  generateHashForDocument,\n  getDocumentReferenceFromDocumentNode,\n  getDocumentReferenceFromTypeQuery,\n} from './persisted';\nimport { SchemaRef } from './graphql/getSchema';\n\nconst BASE_CLIENT_DIRECTIVES = new Set([\n  'populate',\n  'client',\n  'unmask',\n  '_unmask',\n  '_optional',\n  '_relayPagination',\n  '_simplePagination',\n  '_required',\n  'optional',\n  'required',\n  'arguments',\n  'argumentDefinitions',\n  'connection',\n  'refetchable',\n  'relay',\n  'required',\n  'inline',\n]);\n\nexport const SEMANTIC_DIAGNOSTIC_CODE = 52001;\nexport const USING_DEPRECATED_FIELD_CODE = 52004;\nexport const MISSING_PERSISTED_TYPE_ARG = 520100;\nexport const MISSING_PERSISTED_CODE_ARG = 520101;\nexport const MISSING_PERSISTED_DOCUMENT = 520102;\nexport const MISSMATCH_HASH_TO_DOCUMENT = 520103;\nexport const ALL_DIAGNOSTICS = [\n  SEMANTIC_DIAGNOSTIC_CODE,\n  USING_DEPRECATED_FIELD_CODE,\n  MISSING_FRAGMENT_CODE,\n  UNUSED_FIELD_CODE,\n  MISSING_PERSISTED_TYPE_ARG,\n  MISSING_PERSISTED_CODE_ARG,\n  MISSING_PERSISTED_DOCUMENT,\n  MISSMATCH_HASH_TO_DOCUMENT,\n];\n\nconst cache = new LRUCache<number, ts.Diagnostic[]>({\n  // how long to live in ms\n  ttl: 1000 * 60 * 15,\n  max: 5000,\n});\n\nexport function getGraphQLDiagnostics(\n  filename: string,\n  schema: SchemaRef,\n  info: ts.server.PluginCreateInfo\n): ts.Diagnostic[] | undefined {\n  const isCallExpression = info.config.templateIsCallExpression ?? true;\n\n  let source = getSource(info, filename);\n  if (!source) return undefined;\n\n  let fragments: Array<FragmentDefinitionNode> = [],\n    nodes: {\n      node: ts.StringLiteralLike | ts.TaggedTemplateExpression;\n      schema: string | null;\n    }[];\n  if (isCallExpression) {\n    const result = findAllCallExpressions(source, info);\n    fragments = result.fragments;\n    nodes = result.nodes;\n  } else {\n    nodes = findAllTaggedTemplateNodes(source).map(x => ({\n      node: x,\n      schema: null,\n    }));\n  }\n\n  const texts = nodes.map(({ node }) => {\n    if (\n      (ts.isNoSubstitutionTemplateLiteral(node) ||\n        ts.isTemplateExpression(node)) &&\n      !isCallExpression\n    ) {\n      if (ts.isTaggedTemplateExpression(node.parent)) {\n        node = node.parent;\n      } else {\n        return undefined;\n      }\n    }\n\n    return resolveTemplate(node, filename, info).combinedText;\n  });\n\n  const cacheKey = fnv1a(\n    isCallExpression\n      ? source.getText() +\n          fragments.map(x => print(x)).join('-') +\n          schema.version\n      : texts.join('-') + schema.version\n  );\n\n  let tsDiagnostics: ts.Diagnostic[];\n  if (cache.has(cacheKey)) {\n    tsDiagnostics = cache.get(cacheKey)!;\n  } else {\n    tsDiagnostics = runDiagnostics(source, { nodes, fragments }, schema, info);\n    cache.set(cacheKey, tsDiagnostics);\n  }\n\n  const shouldCheckForColocatedFragments =\n    info.config.shouldCheckForColocatedFragments ?? true;\n  let fragmentDiagnostics: ts.Diagnostic[] = [];\n\n  if (isCallExpression) {\n    const persistedCalls = findAllPersistedCallExpressions(source, info);\n    // We need to check whether the user has correctly inserted a hash,\n    // by means of providing an argument to the function and that they\n    // are establishing a reference to the document by means of the generic.\n    const persistedDiagnostics = persistedCalls\n      .map<ts.Diagnostic | null>(found => {\n        const { node: callExpression } = found;\n        if (!callExpression.typeArguments && !callExpression.arguments[1]) {\n          return {\n            category: ts.DiagnosticCategory.Warning,\n            code: MISSING_PERSISTED_TYPE_ARG,\n            file: source,\n            messageText: 'Missing generic pointing at the GraphQL document.',\n            start: callExpression.getStart(),\n            length: callExpression.getEnd() - callExpression.getStart(),\n          };\n        }\n\n        let foundNode,\n          foundFilename = filename,\n          ref,\n          start,\n          length;\n        const typeQuery =\n          callExpression.typeArguments && callExpression.typeArguments[0];\n        if (typeQuery) {\n          start = typeQuery.getStart();\n          length = typeQuery.getEnd() - typeQuery.getStart();\n\n          if (!ts.isTypeQueryNode(typeQuery)) {\n            return {\n              category: ts.DiagnosticCategory.Warning,\n              code: MISSING_PERSISTED_TYPE_ARG,\n              file: source,\n              messageText:\n                'Provided generic should be a typeQueryNode in the shape of graphql.persisted<typeof document>.',\n              start,\n              length,\n            };\n          }\n          const { node: found, filename: fileName } =\n            getDocumentReferenceFromTypeQuery(typeQuery, filename, info);\n          foundNode = found;\n          foundFilename = fileName;\n          ref = typeQuery.getText();\n        } else if (callExpression.arguments[1]) {\n          start = callExpression.arguments[1].getStart();\n          length =\n            callExpression.arguments[1].getEnd() -\n            callExpression.arguments[1].getStart();\n          if (\n            !ts.isIdentifier(callExpression.arguments[1]) &&\n            !ts.isCallExpression(callExpression.arguments[1])\n          ) {\n            return {\n              category: ts.DiagnosticCategory.Warning,\n              code: MISSING_PERSISTED_TYPE_ARG,\n              file: source,\n              messageText:\n                'Provided argument should be an identifier or invocation of \"graphql\" in the shape of graphql.persisted(hash, document).',\n              start,\n              length,\n            };\n          }\n\n          const { node: found, filename: fileName } =\n            getDocumentReferenceFromDocumentNode(\n              callExpression.arguments[1],\n              filename,\n              info\n            );\n          foundNode = found;\n          foundFilename = fileName;\n          ref = callExpression.arguments[1].getText();\n        }\n\n        if (!foundNode) {\n          return {\n            category: ts.DiagnosticCategory.Warning,\n            code: MISSING_PERSISTED_DOCUMENT,\n            file: source,\n            messageText: `Can't find reference to \"${ref}\".`,\n            start,\n            length,\n          };\n        }\n\n        const initializer = foundNode;\n        if (\n          !initializer ||\n          !ts.isCallExpression(initializer) ||\n          !initializer.arguments[0] ||\n          !ts.isStringLiteralLike(initializer.arguments[0])\n        ) {\n          // TODO: we can make this check more stringent where we also parse and resolve\n          // the accompanying template.\n          return {\n            category: ts.DiagnosticCategory.Warning,\n            code: MISSING_PERSISTED_DOCUMENT,\n            file: source,\n            messageText: `Referenced type \"${ref}\" is not a GraphQL document.`,\n            start,\n            length,\n          };\n        }\n\n        if (!callExpression.arguments[0]) {\n          // TODO: this might be covered by the API enforcing the first\n          // argument so can possibly be removed.\n          return {\n            category: ts.DiagnosticCategory.Warning,\n            code: MISSING_PERSISTED_CODE_ARG,\n            file: source,\n            messageText: `The call-expression is missing a hash for the persisted argument.`,\n            start: callExpression.arguments.pos,\n            length: callExpression.arguments.end - callExpression.arguments.pos,\n          };\n        }\n\n        const hash = callExpression.arguments[0].getText().slice(1, -1);\n        if (hash.startsWith('sha256:')) {\n          const generatedHash = generateHashForDocument(\n            info,\n            initializer.arguments[0],\n            foundFilename,\n            initializer.arguments[1] &&\n              ts.isArrayLiteralExpression(initializer.arguments[1])\n              ? initializer.arguments[1]\n              : undefined\n          );\n          if (!generatedHash) return null;\n\n          const upToDateHash = `sha256:${generatedHash}`;\n          if (upToDateHash !== hash) {\n            return {\n              category: ts.DiagnosticCategory.Warning,\n              code: MISSMATCH_HASH_TO_DOCUMENT,\n              file: source,\n              messageText: `The persisted document's hash is outdated`,\n              start: callExpression.arguments.pos,\n              length:\n                callExpression.arguments.end - callExpression.arguments.pos,\n            };\n          }\n        }\n\n        return null;\n      })\n      .filter(Boolean);\n\n    tsDiagnostics.push(...(persistedDiagnostics as ts.Diagnostic[]));\n  }\n\n  if (isCallExpression && shouldCheckForColocatedFragments) {\n    const moduleSpecifierToFragments = getColocatedFragmentNames(source, info);\n    const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n\n    const usedFragments = new Set();\n    nodes.forEach(({ node }) => {\n      try {\n        const parsed = parse(node.getText().slice(1, -1), {\n          noLocation: true,\n        });\n        visit(parsed, {\n          FragmentSpread: node => {\n            usedFragments.add(node.name.value);\n          },\n        });\n      } catch (e) {}\n    });\n\n    // check for maskFragments() calls\n    const maskFragmentsCalls = findAllMaskFragmentsCalls(source);\n    maskFragmentsCalls.forEach(call => {\n      const firstArg = call.arguments[0];\n      if (!firstArg) return;\n\n      // Handle array of fragments: maskFragments([Fragment1, Fragment2], data)\n      if (ts.isArrayLiteralExpression(firstArg)) {\n        firstArg.elements.forEach(element => {\n          if (ts.isIdentifier(element)) {\n            const fragmentDefs = unrollFragment(element, info, typeChecker);\n            fragmentDefs.forEach(def => usedFragments.add(def.name.value));\n          }\n        });\n      }\n    });\n\n    Object.keys(moduleSpecifierToFragments).forEach(moduleSpecifier => {\n      const {\n        fragments: fragmentNames,\n        start,\n        length,\n      } = moduleSpecifierToFragments[moduleSpecifier]!;\n      const missingFragments = Array.from(\n        new Set(fragmentNames.filter(x => !usedFragments.has(x)))\n      );\n      if (missingFragments.length) {\n        fragmentDiagnostics.push({\n          file: source,\n          length,\n          start,\n          category: ts.DiagnosticCategory.Warning,\n          code: MISSING_FRAGMENT_CODE,\n          messageText: `Unused co-located fragment definition(s) \"${missingFragments.join(\n            ', '\n          )}\" in ${moduleSpecifier}`,\n        });\n      }\n    });\n\n    return [...tsDiagnostics, ...fragmentDiagnostics];\n  } else {\n    return tsDiagnostics;\n  }\n}\n\nconst runDiagnostics = (\n  source: ts.SourceFile,\n  {\n    nodes,\n    fragments,\n  }: {\n    nodes: {\n      node: ts.TaggedTemplateExpression | ts.StringLiteralLike;\n      schema: string | null;\n      tadaFragmentRefs?: readonly ts.Identifier[];\n    }[];\n    fragments: FragmentDefinitionNode[];\n  },\n  schema: SchemaRef,\n  info: ts.server.PluginCreateInfo\n): ts.Diagnostic[] => {\n  const filename = source.fileName;\n  const isCallExpression = info.config.templateIsCallExpression ?? true;\n  const typeChecker = info.languageService.getProgram()?.getTypeChecker();\n\n  const diagnostics = nodes\n    .map(originalNode => {\n      let node = originalNode.node;\n      if (\n        !isCallExpression &&\n        (ts.isNoSubstitutionTemplateLiteral(node) ||\n          ts.isTemplateExpression(node))\n      ) {\n        if (ts.isTaggedTemplateExpression(node.parent)) {\n          node = node.parent;\n        } else {\n          return undefined;\n        }\n      }\n\n      const { combinedText: text, resolvedSpans } = resolveTemplate(\n        node,\n        filename,\n        info\n      );\n      const lines = text.split('\\n');\n\n      let isExpression = false;\n      if (ts.isAsExpression(node.parent)) {\n        if (ts.isExpressionStatement(node.parent.parent)) {\n          isExpression = true;\n        }\n      } else if (ts.isExpressionStatement(node.parent)) {\n        isExpression = true;\n      }\n      // When we are dealing with a plain gql statement we have to add two these can be recognised\n      // by the fact that the parent is an expressionStatement\n\n      let startingPosition =\n        node.getStart() +\n        (isCallExpression\n          ? 0\n          : (node as ts.TaggedTemplateExpression).tag.getText().length +\n            (isExpression ? 2 : 0));\n      const endPosition = startingPosition + node.getText().length;\n      let docFragments = [...fragments];\n\n      if (originalNode.tadaFragmentRefs !== undefined) {\n        const fragmentNames = new Set<string>();\n        for (const identifier of originalNode.tadaFragmentRefs) {\n          const unrolled = unrollFragment(identifier, info, typeChecker);\n          unrolled.forEach((frag: FragmentDefinitionNode) =>\n            fragmentNames.add(frag.name.value)\n          );\n        }\n        docFragments = docFragments.filter(frag =>\n          fragmentNames.has(frag.name.value)\n        );\n      }\n\n      if (isCallExpression) {\n        try {\n          const documentFragments = parse(text, {\n            noLocation: true,\n          }).definitions.filter(x => x.kind === Kind.FRAGMENT_DEFINITION);\n          docFragments = docFragments.filter(\n            x =>\n              !documentFragments.some(\n                y =>\n                  y.kind === Kind.FRAGMENT_DEFINITION &&\n                  y.name.value === x.name.value\n              )\n          );\n        } catch (e) {}\n      }\n\n      const schemaToUse =\n        originalNode.schema && schema.multi[originalNode.schema]\n          ? schema.multi[originalNode.schema]?.schema\n          : schema.current?.schema;\n\n      if (!schemaToUse) {\n        return undefined;\n      }\n\n      const clientDirectives = new Set([\n        ...BASE_CLIENT_DIRECTIVES,\n        ...(info.config.clientDirectives || []),\n      ]);\n\n      const graphQLDiagnostics = getDiagnostics(\n        text,\n        schemaToUse,\n        undefined,\n        undefined,\n        docFragments\n      )\n        .filter(diag => {\n          if (!diag.message.includes('Unknown directive')) return true;\n\n          const [message] = diag.message.split('(');\n          const matches =\n            message && /Unknown directive \"@([^)]+)\"/g.exec(message);\n          if (!matches) return true;\n          const directiveName = matches[1];\n          return directiveName && !clientDirectives.has(directiveName);\n        })\n        .map(x => {\n          const { start, end } = x.range;\n\n          // We add the start.line to account for newline characters which are\n          // split out\n          let startChar = startingPosition + start.line;\n          for (let i = 0; i <= start.line && i < lines.length; i++) {\n            if (i === start.line) startChar += start.character;\n            else if (lines[i]) startChar += lines[i]!.length;\n          }\n\n          let endChar = startingPosition + end.line;\n          for (let i = 0; i <= end.line && i < lines.length; i++) {\n            if (i === end.line) endChar += end.character;\n            else if (lines[i]) endChar += lines[i]!.length;\n          }\n\n          const locatedInFragment = resolvedSpans.find(x => {\n            const newEnd = x.new.start + x.new.length;\n            return startChar >= x.new.start && endChar <= newEnd;\n          });\n\n          if (!!locatedInFragment) {\n            return {\n              ...x,\n              start: locatedInFragment.original.start,\n              length: locatedInFragment.original.length,\n            };\n          } else {\n            if (startChar > endPosition) {\n              // we have to calculate the added length and fix this\n              const addedCharacters = resolvedSpans\n                .filter(x => x.new.start + x.new.length < startChar)\n                .reduce(\n                  (acc, span) => acc + (span.new.length - span.original.length),\n                  0\n                );\n              startChar = startChar - addedCharacters;\n              endChar = endChar - addedCharacters;\n              return {\n                ...x,\n                start: startChar + 1,\n                length: endChar - startChar,\n              };\n            } else {\n              return {\n                ...x,\n                start: startChar + 1,\n                length: endChar - startChar,\n              };\n            }\n          }\n        })\n        .filter(x => x.start + x.length <= endPosition);\n\n      return graphQLDiagnostics;\n    })\n    .flat()\n    .filter(Boolean) as Array<Diagnostic & { length: number; start: number }>;\n\n  const tsDiagnostics = diagnostics.map(\n    diag =>\n      ({\n        file: source,\n        length: diag.length,\n        start: diag.start,\n        category:\n          diag.severity === 2\n            ? ts.DiagnosticCategory.Warning\n            : ts.DiagnosticCategory.Error,\n        code:\n          typeof diag.code === 'number'\n            ? diag.code\n            : diag.severity === 2\n            ? USING_DEPRECATED_FIELD_CODE\n            : SEMANTIC_DIAGNOSTIC_CODE,\n        messageText: diag.message.split('\\n')[0],\n      } as ts.Diagnostic)\n  );\n\n  if (isCallExpression) {\n    const usageDiagnostics =\n      checkFieldUsageInFile(\n        source,\n        nodes.map(x => x.node) as ts.NoSubstitutionTemplateLiteral[],\n        info\n      ) || [];\n\n    if (!usageDiagnostics) return tsDiagnostics;\n\n    return [...tsDiagnostics, ...usageDiagnostics];\n  } else {\n    return tsDiagnostics;\n  }\n};\n"],"names":["ts","init","modules","typescript","CharacterStream","constructor","sourceText","this","_start","_pos","getStartOfToken","getCurrentPosition","eol","_sourceText","length","sol","peek","charAt","next","char","eat","pattern","_testNextCharacter","eatWhile","match","isMatched","didEat","eatSpace","skipToEnd","skipTo","position","consume","caseFold","token","RegExp","test","slice","Array","startsWith","backUp","num","column","indentation","indent","whiteSpaces","pos","charCodeAt","current","character","opt","ofRule","list","separator","isList","t","kind","style","p","value","isIgnored","ch","LexRules","Name","Punctuation","Number","String","Comment","ParseRules","Document","Definition","Kind","FRAGMENT_DEFINITION","ShortQuery","Query","word","name","Mutation","Subscription","VariableDefinitions","VariableDefinition","Variable","DefaultValue","SelectionSet","Selection","stream","AliasedField","Field","Arguments","Argument","FragmentSpread","InlineFragment","FragmentDefinition","butNot","rule","exclusions","ruleMatch","check","every","exclusion","TypeCondition","Value","NumberValue","StringValue","update","state","inBlockstring","endsWith","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Type","ListType","NonNullType","NamedType","type","_a","prevState","Directive","DirectiveDef","InterfaceDef","Implements","DirectiveLocation","SchemaDef","OperationTypeDef","ScalarDef","ObjectTypeDef","FieldDef","ArgumentsDef","InputValueDef","UnionDef","UnionMember","EnumDef","EnumValueDef","InputDef","ExtendDef","ExtensionDefinition","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","onlineParser","options","eatWhitespace","lexRules","parseRules","editorConfig","startState","initialState","level","step","needsSeparator","pushRule","DOCUMENT","getToken","popRule","needsAdvance","advanceRule","tabSize","indentLevel","Math","floor","lex","kinds","Object","keys","i","SpecialParseRules","backupState","assign","undefined","levels","concat","at","expected","call","unsuccessful","to","from","Invalid","rules","ruleKind","TypeError","successful","isArray","Range","start","end","containsPosition","line","setStart","Position","setEnd","lessThanOrEqualTo","setLine","setCharacter","specifiedSDLRules","LoneSchemaDefinitionRule","UniqueOperationTypesRule","UniqueTypeNamesRule","UniqueEnumValueNamesRule","UniqueFieldDefinitionNamesRule","UniqueDirectiveNamesRule","KnownTypeNamesRule","KnownDirectivesRule","UniqueDirectivesPerLocationRule","PossibleTypeExtensionsRule","UniqueArgumentNamesRule","UniqueInputFieldNamesRule","SEVERITY","DIAGNOSTIC_SEVERITY","SEVERITY_Error","SEVERITY_Warning","SEVERITY_Information","SEVERITY_Hint","invariant","condition","message","Error","getDiagnostics","query","schema","customRules","isRelayCompatMode","externalFragments","ast","fragments","reduce","acc","node","print","enhancedQuery","parse","error","GraphQLError","range","getRange","location","queryText","parser","lines","split","_b","locations","severity","source","validateQuery","validationErrorAnnotations","validateWithCustomRules","isSchemaDocument","specifiedRules","filter","NoUnusedFragmentsRule","ExecutableDefinitionsRule","KnownFragmentNamesRule","prototype","push","apply","validate","includes","nodes","DIRECTIVE","flatMap","annotations","deprecationWarningAnnotations","NoDeprecatedCustomRule","Warning","highlightedNodes","entries","highlightNode","variable","loc","highlightLoc","getLocation","e","templates","Set","isIIFE","isCallExpression","arguments","isFunctionExpression","expression","isArrowFunction","asteriskToken","modifiers","isGraphQLFunctionIdentifier","isIdentifier","has","escapedText","isTadaGraphQLFunction","checker","isLeftHandSideExpression","getTypeAtLocation","getProperty","isTadaGraphQLCall","isStringLiteralLike","isTadaPersistedCall","isPropertyAccessExpression","isGraphQLCall","isGraphQLTag","isTaggedTemplateExpression","tag","getSchemaName","typeChecker","getChildAt","brandTypeSymbol","brand","getTypeOfSymbol","isUnionOrIntersection","found","types","find","x","isStringLiteral","isValueDeclaration","SyntaxKind","BinaryExpression","ArrowFunction","BindingElement","ClassDeclaration","ClassExpression","ClassStaticBlockDeclaration","Constructor","EnumDeclaration","EnumMember","ExportAssignment","FunctionDeclaration","FunctionExpression","GetAccessor","JsxAttribute","MethodDeclaration","Parameter","PropertyAssignment","PropertyDeclaration","SetAccessor","ShorthandPropertyAssignment","VariableDeclaration","getValueOfValueDeclaration","initializer","isAssignmentOperator","EqualsToken","BarBarEqualsToken","AmpersandAmpersandEqualsToken","QuestionQuestionEqualsToken","operatorToken","right","objectAssignmentInitializer","climbPastPropertyOrElementAccess","parent","isElementAccessExpression","argumentExpression","getNameFromPropertyName","isComputedPropertyName","isNumericLiteral","text","isPrivateIdentifier","isMemberName","idText","getDeclarationOfIdentifier","symbol","getSymbolAtLocation","declarations","flags","SymbolFlags","Alias","isNamespaceImport","aliased","getAliasedSymbol","isShorthandPropertyAssignment","shorthandSymbol","getShorthandAssignmentValueSymbol","valueDeclaration","isBindingElement","isObjectBindingPattern","propertyName","prop","isObjectLiteralElement","isObjectLiteralExpression","isJsxAttributes","getContextualType","Class","Function","isNewExpressionTarget","target","isNewExpression","declaration","isClassLike","isCallOrNewExpressionTarget","isCallOrNewExpression","isNameOfFunctionDeclaration","isFunctionLike","body","isBinaryExpression","left","getValueOfIdentifier","resolveTemplate","filename","info","combinedText","getText","resolvedSpans","templateText","template","isNoSubstitutionTemplateLiteral","templateSpans","addedCharacters","map","span","languageService","getProgram","getTypeChecker","isVariableDeclaration","identifierName","originalStart","getStart","originalRange","getSourceFile","fileName","replace","alteredSpan","identifier","original","new","isAsExpression","resolvedTemplate","JSON","Boolean","resolveTadaFragmentArray","isArrayLiteralExpression","elements","identifiers","element","getSource","program","findNode","sourceFile","getEnd","forEachChild","unrollFragment","seen","WeakSet","_unrollElement","add","resolveIdentifierToGraphQLCall","input","checks","fragmentRefs","noLocation","definitions","forEach","definition","_error","nextElement","shift","unrollTadaFragments","fragmentsArray","wip","el","findAllCallExpressions","shouldSearchFragments","result","hasTriedToFindFragments","isTadaCall","getAllFragments","tadaFragmentRefs","findAllPersistedCallExpressions","getIdentifierOfChainExpression","isSatisfiesExpression","isNonNullExpression","isParenthesizedExpression","isExpressionWithTypeArguments","isCommaListExpression","textSpan","getWidth","def","src","isVariableStatement","declarationList","properties","property","isPropertyAssignment","possibleFragment","findAllMaskFragmentsCalls","bubbleUpTemplate","isToken","isTemplateExpression","isTemplateSpan","bubbleUpCallExpression","perf","performance","now","Date","warned","PROCESS","process","emitWarning","msg","code","fn","console","AC","globalThis","AbortController","AS","AbortSignal","_onabort","aborted","addEventListener","_","warnACPolyfill","signal","abort","reason","onabort","printACPolyfillWarning","env","LRU_CACHE_IGNORE_AC_WARNING","isPosInt","n","isFinite","getUintArray","max","pow","Uint8Array","Uint16Array","Uint32Array","MAX_SAFE_INTEGER","ZeroArray","size","super","fill","Stack","static","create","HeapCls","constructing","s","heap","pop","LRUCache","maxSize","dispose","disposeAfter","fetchMethod","calculatedSize","keyMap","keyList","valList","prev","head","tail","free","disposed","sizes","starts","ttls","hasDispose","hasFetchMethod","hasDisposeAfter","unsafeExposeInternals","c","isBackgroundFetch","backgroundFetch","k","index","context","moveToTail","indexes","rindexes","isStale","ttl","ttlResolution","ttlAutopurge","updateAgeOnGet","updateAgeOnHas","allowStale","noDisposeOnSet","noUpdateTTL","maxEntrySize","sizeCalculation","noDeleteOnFetchRejection","noDeleteOnStaleGet","allowStaleOnFetchRejection","allowStaleOnFetchAbort","ignoreFetchAbort","UintArray","Map","initializeSizeTracking","initializeTTLTracking","shouldWarn","getRemainingTTL","key","Infinity","setItemTTL","setTimeout","delete","unref","updateItemAge","statusTTL","status","cachedNow","getNow","remainingTTL","get","#updateItemAge","#statusTTL","#setItemTTL","#isStale","removeItemSize","requireSize","v","addItemSize","evict","entrySize","totalCalculatedSize","_i","#addItemSize","_s","_st","#requireSize","_k","_v","isValidIndex","rentries","rkeys","values","rvalues","Symbol","iterator","getOptions","__staleWhileFetching","thisp","rforEach","purgeStale","deleted","dump","arr","entry","age","unshift","load","clear","set","setOptions","maxEntrySizeExceeded","oldVal","__abortController","oldValue","dt","task","val","hasOptions","peekOptions","ac","fetchOpts","cb","updateCache","ignoreAbort","fetchAborted","fetchError","fetchAbortIgnored","fetchResolved","fetchFail","fetchUpdated","er","allowStaleAborted","bf","returnedStale","__returned","fetchDispatched","Promise","pcall","res","rej","fmp","then","fetchRejected","b","hasOwnProperty","fetch","fetchOptions","forceRefresh","stale","staleVal","fetching","connect","FNV_PRIMES","FNV_OFFSETS","fnv1aModule","exports","fnv1a","string","hash","isUnicoded","characterCode","unescape","encodeURIComponent","bigInt","fnvPrime","BigInt","asUintN","UNUSED_FIELD_CODE","unwrapAbstractType","TypeFlags","getVariableDeclaration","isBlock","traverseArrayDestructuring","originalWip","allFields","isOmittedExpression","crawlScope","traverseDestructuring","results","_loop","binding","joined","join","traverseResult","crawlResult","arrayMethods","crawlChainedExpressions","ref","pathParts","isReduce","func","nestedResult","isFunctionDeclaration","param","parameters","scopedResult","inArrayMethod","isArrayBindingPattern","references","getReferencesAtPosition","foundRef","_ret","_loop2","isReturnStatement","arg","parts","reference","_loop3","callExpression","isSomeOrEvery","chainedResults","varRes","getColocatedFragmentNames","imports","findAllImports","statements","isImportDeclaration","importSpecifierToFragments","imp","importClause","names","getFragmentsInSource","fragment","moduleSpecifier","fragmentsEntry","namedBindings","isNamedImportBindings","callExpressions","exportedNames","getExportsOfModule","symb","isSourceFile","parsed","getPersistedCodeFixAtPosition","config","templateIsCallExpression","isVariableDeclarationList","foundNode","foundFilename","typeArguments","typeQuery","isTypeQueryNode","getDocumentReferenceFromTypeQuery","getDocumentReferenceFromDocumentNode","generateHashForDocument","existingHash","replacement","templateLiteral","referencedFragments","stripUnmaskDirectivesFromDefinition","array","indexOf","fragmentDefinition","fullText","createHash","digest","externalSource","spreads","visit","resolvedText","visited","traversedSpreads","spreadName","project","projectService","logger","exprName","isQualifiedName","documentNodeArgument","directives","directive","BASE_CLIENT_DIRECTIVES","MISSING_PERSISTED_TYPE_ARG","MISSING_PERSISTED_CODE_ARG","MISSING_PERSISTED_DOCUMENT","MISSMATCH_HASH_TO_DOCUMENT","ALL_DIAGNOSTICS","cache","getGraphQLDiagnostics","findAllTaggedTemplateNodes","texts","cacheKey","version","tsDiagnostics","runDiagnostics","shouldCheckForColocatedFragments","fragmentDiagnostics","persistedDiagnostics","category","DiagnosticCategory","file","messageText","generatedHash","moduleSpecifierToFragments","usedFragments","firstArg","fragmentNames","missingFragments","diagnostics","originalNode","isExpression","isExpressionStatement","startingPosition","endPosition","docFragments","frag","documentFragments","some","y","schemaToUse","multi","clientDirectives","graphQLDiagnostics","diag","matches","exec","directiveName","startChar","endChar","locatedInFragment","flat","usageDiagnostics","checkFieldUsageInFile","trackFieldUsage","reservedKeys","nodeText","variableDeclaration","dataType","resolvedTypeArguments","apiTypeSymbol","apiType","callSignature","getCallSignatures","getReturnType","allAccess","inProgress","allPaths","fieldToLoc","enter","alias","path","selectionSet","leave","targetNode","scopeSymbols","getSymbolsInScope","BlockScopedVariable","scopeDataSymbol","scopeSymbol","typeOfScopeSymbol","tuplePropertySymbol","dataPropertySymbol","isBindingName","unused","aggregatedUnusedFields","unusedChildren","unusedFragmentLeaf","unusedField","parentField","field","unusedFields","stack"],"mappings":";;;;IAAWA;;AACJ,SAASC,KAAKC;EACnBF,IAAKE,EAAQC;AACf;;ACkBc,MAAOC;EAKnBC,WAAAA,CAAYC;IAJJC,KAAAC,SAAS;IACTD,KAAAE,OAAO;IAORF,KAAAG,kBAAkB,MAAcH,KAAKC;IAErCD,KAAAI,qBAAqB,MAAcJ,KAAKE;IAgBxCF,KAAAK,MAAM,MAAeL,KAAKM,YAAYC,WAAWP,KAAKE;IAEtDF,KAAAQ,MAAM,MAA6B,MAAdR,KAAKE;IAE1BF,KAAAS,OAAO,MACLT,KAAKM,YAAYI,OAAOV,KAAKE,SAAS;IAGxCF,KAAAW,OAAO;MACZ,IAAMC,IAAOZ,KAAKM,YAAYI,OAAOV,KAAKE;MAC1CF,KAAKE;MACL,OAAOU;;IAGFZ,KAAAa,MAAOC;MAEZ,IADkBd,KAAKe,mBAAmBD,IAC3B;QACbd,KAAKC,SAASD,KAAKE;QACnBF,KAAKE;QACL,OAAOF,KAAKM,YAAYI,OAAOV,KAAKE,OAAO;;MAE7C;;IAGKF,KAAAgB,WAAYC;MACjB,IAAIC,IAAYlB,KAAKe,mBAAmBE;MACxC,IAAIE,KAAS;MAGb,IAAID,GAAW;QACbC,IAASD;QACTlB,KAAKC,SAASD,KAAKE;;MAGrB,OAAOgB,GAAW;QAChBlB,KAAKE;QACLgB,IAAYlB,KAAKe,mBAAmBE;QACpCE,KAAS;;MAGX,OAAOA;;IAGFnB,KAAAoB,WAAW,MAAepB,KAAKgB,SAAS;IAExChB,KAAAqB,YAAY;MACjBrB,KAAKE,OAAOF,KAAKM,YAAYC;;IAGxBP,KAAAsB,SAAUC;MACfvB,KAAKE,OAAOqB;;IAGPvB,KAAAiB,QAAQ,CACbH,GACAU,KAAsC,GACtCC,KAAuC;MAEvC,IAAIC,IAAQ;MACZ,IAAIT,IAAQ;MAEZ,IAAuB,mBAAZH,GAAsB;QAE/BG,IADc,IAAIU,OAAOb,GAASW,IAAW,MAAM,KACrCG,KACZ5B,KAAKM,YAAYuB,MAAM7B,KAAKE,MAAMF,KAAKE,OAAOY,EAAQP;QAExDmB,IAAQZ;AACT,aAAM,IAAIA,aAAmBa;QAE5BD,IAAQT,SADRA,IAAQjB,KAAKM,YAAYuB,MAAM7B,KAAKE,MAAMe,MAAMH,eACxCG,EAAQ;;MAGlB,IACW,QAATA,MACoB,mBAAZH,KACLG,aAAiBa,SAIhB9B,KAAKM,YAAYyB,WAAWd,EAAM,IAAIjB,KAAKE,QAC/C;QACA,IAAIsB,GAAS;UACXxB,KAAKC,SAASD,KAAKE;UAEnB,IAAIwB,KAASA,EAAMnB;YACjBP,KAAKE,QAAQwB,EAAMnB;;;QAGvB,OAAOU;;MAIT,QAAO;;IAGFjB,KAAAgC,SAAUC;MACfjC,KAAKE,QAAQ+B;;IAGRjC,KAAAkC,SAAS,MAAclC,KAAKE;IAE5BF,KAAAmC,cAAc;MACnB,IAAMlB,IAAQjB,KAAKM,YAAYW,MAAM;MACrC,IAAImB,IAAS;MACb,IAAInB,KAA0B,MAAjBA,EAAMV,QAAc;QAC/B,IAAM8B,IAAcpB,EAAM;QAC1B,IAAIqB,IAAM;QACV,OAAOD,EAAY9B,SAAS+B,GAAK;UAC/B,IAAoC,MAAhCD,EAAYE,WAAWD;YACzBF,KAAU;;YAEVA;;UAEFE;;;MAIJ,OAAOF;;IAGFpC,KAAAwC,UAAU,MAAcxC,KAAKM,YAAYuB,MAAM7B,KAAKC,QAAQD,KAAKE;IA7ItEF,KAAKM,cAAcP;AACrB;EAMQgB,kBAAAA,CAAmBD;IACzB,IAAM2B,IAAYzC,KAAKM,YAAYI,OAAOV,KAAKE;IAC/C,IAAIgB,KAAY;IAChB,IAAuB,mBAAZJ;MACTI,IAAYuB,MAAc3B;;MAE1BI,IACEJ,aAAmBa,SACfb,EAAQc,KAAKa,KACb3B,EAAQ2B;;IAEhB,OAAOvB;AACT;;;AChCI,SAAUwB,IAAIC;EAClB,OAAO;IAAEA;;AACX;;AAGM,SAAUC,KAAKD,GAAuBE;EAC1C,OAAO;IAAEF;IAAQG,SAAQ;IAAMD;;AACjC;;AAoBM,SAAUE,IAAEC,GAAcC;EAC9B,OAAO;IAAEA;IAAOhC,OAAQS,KAAiBA,EAAMsB,SAASA;;AAC1D;;AAGM,SAAUE,IAAEC,GAAeF;EAC/B,OAAO;IACLA,OAAOA,KAAS;IAChBhC,OAAQS,KACS,kBAAfA,EAAMsB,QAA0BtB,EAAMyB,UAAUA;;AAEtD;;ACnCO,IAAMC,YAAaC,KACjB,QAAPA,KACO,SAAPA,KACO,QAAPA,KACO,SAAPA,KACO,SAAPA,KACO,aAAPA,KACO,QAAPA;;AAKK,IAAMC,IAAW;EAEtBC,MAAM;EAGNC,aAAa;EAGbC,QAAQ;EAGRC,QACE;EAGFC,SAAS;;;AAQJ,IAAMC,IAA4C;EACvDC,UAAU,EAACjB,KAAK;EAChBkB,UAAAA,CAAWpC;IACT,QAAQA,EAAMyB;KACZ,KAAK;MACH,OAAO;;KACT,KAAK;MACH,OAAO;;KACT,KAAK;MACH,OAAO;;KACT,KAAK;MACH,OAAO;;KACT,KAAK;MACH,OAAOY,EAAKC;;KACd,KAAK;MACH,OAAO;;KACT,KAAK;MACH,OAAO;;KACT,KAAK;MACH,OAAO;;KACT,KAAK;MACH,OAAO;;KACT,KAAK;MACH,OAAO;;KACT,KAAK;MACH,OAAO;;KACT,KAAK;MACH,OAAO;;KACT,KAAK;MACH,OAAO;;KACT,KAAK;MACH,OAAO;;AAEZ;EAEDC,YAAY,EAAC;EACbC,OAAO,EACLC,KAAK,UACLzB,IAAI0B,OAAK,SACT1B,IAAI,wBACJE,KAAK,cACL;EAGFyB,UAAU,EACRF,KAAK,aACLzB,IAAI0B,OAAK,SACT1B,IAAI,wBACJE,KAAK,cACL;EAGF0B,cAAc,EACZH,KAAK,iBACLzB,IAAI0B,OAAK,SACT1B,IAAI,wBACJE,KAAK,cACL;EAGF2B,qBAAqB,EAACrB,IAAE,MAAMN,KAAK,uBAAuBM,IAAE;EAC5DsB,oBAAoB,EAAC,YAAYtB,IAAE,MAAM,QAAQR,IAAI;EACrD+B,UAAU,EAACvB,IAAE,KAAK,aAAakB,OAAK;EACpCM,cAAc,EAACxB,IAAE,MAAM;EACvByB,cAAc,EAACzB,IAAE,MAAMN,KAAK,cAAcM,IAAE;EAC5C0B,WAASA,CAAClD,GAAcmD,MACC,UAAhBnD,EAAMyB,QACT0B,EAAO5D,MAAM,2BAA0B,KACrC,mBACA,mBACF4D,EAAO5D,MAAM,kBAAiB,KAC9B,iBACA;EAGN6D,cAAc,EACZV,OAAK,aACLlB,IAAE,MACFkB,OAAK,cACL1B,IAAI,cACJE,KAAK,cACLF,IAAI;EAGNqC,OAAO,EACLX,OAAK,aACL1B,IAAI,cACJE,KAAK,cACLF,IAAI;EAGNsC,WAAW,EAAC9B,IAAE,MAAMN,KAAK,aAAaM,IAAE;EACxC+B,UAAU,EAACb,OAAK,cAAclB,IAAE,MAAM;EACtCgC,gBAAgB,EAAChC,IAAE,QAAQkB,OAAK,QAAQxB,KAAK;EAC7CuC,gBAAgB,EACdjC,IAAE,QACFR,IAAI,kBACJE,KAAK,cACL;EAGFwC,oBAAoB,EAClBjB,KAAK,aACLzB,IDnIE,SAAU2C,OAAOC,GAAYC;IACjC,IAAMC,IAAYF,EAAKrE;IACvBqE,EAAKrE,QAAQS;MACX,IAAI+D,KAAQ;MACZ,IAAID;QACFC,IAAQD,EAAU9D;;MAEpB,OACE+D,KAEAF,EAAWG,MAAMC,KAAaA,EAAU1E,UAAU0E,EAAU1E,MAAMS;;IAGtE,OAAO4D;AACT,GCqHQD,CAAOjB,OAAK,QAAQ,EAACD,KAAK,WAC9B,iBACAvB,KAAK,cACL;EAGFgD,eAAe,EAACzB,KAAK,OAAO;EAE5B0B,KAAAA,CAAMnE;IACJ,QAAQA,EAAMsB;KACZ,KAAK;MACH,OAAO;;KACT,KAAK;MACH,OAAO;;KACT,KAAK;MACH,QAAQtB,EAAMyB;OACZ,KAAK;QACH,OAAO;;OACT,KAAK;QACH,OAAO;;OACT,KAAK;QACH,OAAO;;OACT,KAAK;QACH,OAAO;;MAGX,OAAO;;KACT,KAAK;MACH,QAAQzB,EAAMyB;OACZ,KAAK;OACL,KAAK;QACH,OAAO;;MAGX,IAAoB,WAAhBzB,EAAMyB;QACR,OAAO;;MAET,OAAO;;AAEZ;EACD2C,aAAa,EAAC/C,IAAE,UAAU;EAC1BgD,aAAa,EACX;IACE9C,OAAO;IACPhC,OAAQS,KAAgC,aAAfA,EAAMsB;IAC/BgD,MAAAA,CAAOC,GAAcvE;MACnB,IAAIA,EAAMyB,MAAMpB,WAAW;QACzBkE,EAAMC,iBAAiBxE,EAAMyB,MAAMtB,MAAM,GAAGsE,SAAS;;AAEzD;;EAGJC,cAAc,EAACrD,IAAE,QAAQ;EACzBsD,WAAW,EAACtD,IAAE,QAAQ;EACtBuD,WAAW,EAAClC,OAAK;EACjBmC,WAAW,EAACrD,IAAE,MAAMN,KAAK,UAAUM,IAAE;EACrCsD,aAAa,EAACtD,IAAE,MAAMN,KAAK,gBAAgBM,IAAE;EAC7CuD,aAAa,EAACrC,OAAK,cAAclB,IAAE,MAAM;EACzCwD,MAAKhF,KACoB,QAAhBA,EAAMyB,QAAgB,aAAa;EAG5CwD,UAAU,EAACzD,IAAE,MAAM,QAAQA,IAAE,MAAMR,IAAIQ,IAAE;EACzC0D,aAAa,EAAC,aAAalE,IAAIQ,IAAE;EACjC2D,WAAW,EAsIb,SAASC,OAAK7D;IACZ,OAAO;MACLA;MACAhC,OAAQS,KAAgC,WAAfA,EAAMsB;MAC/BgD,MAAAA,CAAOC,GAAcvE;;QACnB,IAAmBqF,UAAfA,IAAAd,EAAMe,mBAASD,MAAAA,SAAAA,IAAAA,EAAEC,WAAW;UAC9Bf,EAAM7B,OAAO1C,EAAMyB;UACnB8C,EAAMe,UAAUA,UAAUF,OAAOpF,EAAMyB;;AAE3C;;AAEJ,GAjJc2D,CAAK;EACjBG,WAAW,EAAC/D,IAAE,KAAK,SAASkB,OAAK,SAAS1B,IAAI;EAC9CwE,cAAc,EACZ/C,KAAK,cACLjB,IAAE,KAAK,SACPkB,OAAK,SACL1B,IAAI,iBACJyB,KAAK,OACLvB,KAAK,qBAAqBM,IAAE;EAE9BiE,cAAc,EACZhD,KAAK,cACLC,OAAK,SACL1B,IAAI,eACJE,KAAK,cACLM,IAAE,MACFN,KAAK,aACLM,IAAE;EAEJkE,YAAY,EAACjD,KAAK,eAAevB,KAAK,aAAaM,IAAE;EACrDmE,mBAAmB,EAACjD,OAAK;EAEzBkD,WAAW,EACTnD,KAAK,WACLvB,KAAK,cACLM,IAAE,MACFN,KAAK,qBACLM,IAAE;EAGJqE,kBAAkB,EAACnD,OAAK,YAAYlB,IAAE,MAAMkB,OAAK;EACjDoD,WAAW,EAACrD,KAAK,WAAWC,OAAK,SAASxB,KAAK;EAC/C6E,eAAe,EACbtD,KAAK,SACLC,OAAK,SACL1B,IAAI,eACJE,KAAK,cACLM,IAAE,MACFN,KAAK,aACLM,IAAE;EAGJwE,UAAU,EACRtD,OAAK,aACL1B,IAAI,iBACJQ,IAAE,MACF,QACAN,KAAK;EAGP+E,cAAc,EAACzE,IAAE,MAAMN,KAAK,kBAAkBM,IAAE;EAChD0E,eAAe,EACbxD,OAAK,cACLlB,IAAE,MACF,QACAR,IAAI,iBACJE,KAAK;EAGPiF,UAAU,EACR1D,KAAK,UACLC,OAAK,SACLxB,KAAK,cACLM,IAAE,MACFN,KAAK,eAAeM,IAAE;EAGxB4E,aAAa,EAAC;EACdC,SAAS,EACP5D,KAAK,SACLC,OAAK,SACLxB,KAAK,cACLM,IAAE,MACFN,KAAK,iBACLM,IAAE;EAGJ8E,cAAc,EAAC5D,OAAK,aAAaxB,KAAK;EACtCqF,UAAU,EACR9D,KAAK,UACLC,OAAK,SACLxB,KAAK,cACLM,IAAE,MACFN,KAAK,kBACLM,IAAE;EAEJgF,WAAW,EAAC/D,KAAK,WAAW;EAC5BgE,mBAAAA,CAAoBzG;IAClB,QAAQA,EAAMyB;KACZ,KAAK;MACH,OAAOY,EAAKqE;;KACd,KAAK;MACH,OAAOrE,EAAKsE;;KACd,KAAK;MACH,OAAOtE,EAAKuE;;KACd,KAAK;MACH,OAAOvE,EAAKwE;;KACd,KAAK;MACH,OAAOxE,EAAKyE;;KACd,KAAK;MACH,OAAOzE,EAAK0E;;KACd,KAAK;MACH,OAAO1E,EAAK2E;;AAEjB;EACD,CAAC3E,EAAKqE,mBAAmB,EAAC;EAC1B,CAACrE,EAAKsE,wBAAwB,EAAC;EAC/B,CAACtE,EAAKuE,wBAAwB,EAAC;EAC/B,CAACvE,EAAKwE,2BAA2B,EAAC;EAClC,CAACxE,EAAKyE,uBAAuB,EAAC;EAC9B,CAACzE,EAAK0E,sBAAsB,EAAC;EAC7B,CAAC1E,EAAK2E,8BAA8B,EAAC;;;AAIvC,SAASvE,KAAKhB;EACZ,OAAO;IACLF,OAAO;IACPhC,OAAQS,KAAgC,WAAfA,EAAMsB,QAAmBtB,EAAMyB,UAAUA;;AAEtE;;AAGA,SAASiB,OAAKnB;EACZ,OAAO;IACLA;IACAhC,OAAQS,KAAgC,WAAfA,EAAMsB;IAC/BgD,MAAAA,CAAOC,GAAcvE;MACnBuE,EAAM7B,OAAO1C,EAAMyB;AACrB;;AAEJ;;ACpTc,SAAUwF,aACtBC,IAAyB;EACvBC,eAAehE,KAAUA,EAAO7D,SAASoC;EACzC0F,UAAUxF;EACVyF,YAAYnF;EACZoF,cAAc,CAAA;;EAMhB,OAAO;IACLC,UAAAA;MACE,IAAMC,IAAe;QACnBC,OAAO;QACPC,MAAM;QACNhF,MAAM;QACNpB,MAAM;QACN8D,MAAM;QACNxB,MAAM;QACN+D,iBAAgB;QAChBrC,WAAW;;MAGbsC,SAASV,EAAQG,YAAYG,GAAcnF,EAAKwF;MAChD,OAAOL;AACR;IACDxH,OAAKA,CAACmD,GAAyBoB,MAMnC,SAASuD,SACP3E,GACAoB,GACA2C;;MAEA,IAAI3C,EAAMC,eAAe;QAEvB,IAAIrB,EAAO5D,MAAM,UAAU;UACzBgF,EAAMC,iBAAgB;UACtB,OAAO;;QAETrB,EAAOxD;QACP,OAAO;;MAGT,KAAMyH,UAAEA,GAAQC,YAAEA,GAAUF,eAAEA,GAAaG,cAAEA,KAAiBJ;MAE9D,IAAI3C,EAAMX,QAA8B,MAAtBW,EAAMX,KAAK/E;QAC3BkJ,QAAQxD;aACH,IAAIA,EAAMyD,cAAc;QAC7BzD,EAAMyD,gBAAe;QACrBC,YAAY1D,IAAO;;MAIrB,IAAIpB,EAAOrE,OAAO;QAChB,IAAMoJ,KAAUZ,iBAAY,IAAZA,EAAcY,YAAW;QACzC3D,EAAM4D,cAAcC,KAAKC,MAAMlF,EAAO1C,gBAAgByH;;MAIxD,IAAIf,EAAchE;QAChB,OAAO;;MAIT,IAAMnD,IAuOR,SAASsI,IACPlB,GACAjE;QAEA,IAAMoF,IAAQC,OAAOC,KAAKrB;QAC1B,KAAK,IAAIsB,IAAI,GAAGA,IAAIH,EAAM1J,QAAQ6J,KAAK;UAGrC,IAAMnJ,IAAQ4D,EAAO5D,MAAM6H,EAASmB,EAAMG;UAC1C,IAAInJ,KAASA,aAAiBa;YAC5B,OAAO;cAAEkB,MAAMiH,EAAMG;cAAIjH,OAAOlC,EAAM;;;;AAG5C,OApPgB+I,CAAIlB,GAAUjE;MAG5B,KAAKnD,GAAO;QAEV,KADyBmD,EAAO5D,MAAM;UAIpC4D,EAAO5D,MAAM;;QAEfqI,SAASe,GAAmBpE,GAAO;QACnC,OAAO;;MAIT,IAAmB,cAAfvE,EAAMsB,MAAoB;QAC5BsG,SAASe,GAAmBpE,GAAO;QACnC,OAAO;;MAIT,IAAMqE,IAAcC,OAAO,CAAE,GAAEtE;MAG/B,IAAmB,kBAAfvE,EAAMsB;QACR,IAAI,SAASpB,KAAKF,EAAMyB;UACtB,SAA0BqH,MAAtBvE,EAAM4D;YAER5D,EAAMwE,UAAUxE,EAAMwE,UAAU,IAAIC,OAAOzE,EAAM4D,cAAc;;eAE5D,IAAI,UAAUjI,KAAKF,EAAMyB,QAAQ;UAItC,IAAMsH,IAAUxE,EAAMwE,UAAUxE,EAAMwE,UAAU,IAAI5I,MAAM,IAAI;UAG9D,IACEoE,EAAM4D,eACNY,EAAOlK,SAAS,KAChBkK,EAAOE,IAAI,KAAM1E,EAAM4D;YAEvB5D,EAAM4D,cAAcY,EAAOE,IAAI;;;;MAKrC,OAAO1E,EAAMX,MAAM;QAGjB,IAAIsF,IACoB,qBAAf3E,EAAMX,OACM,MAAfW,EAAMmD,OACJnD,EAAMX,KAAK5D,GAAOmD,KAClB,OACFoB,EAAMX,KAAKW,EAAMmD;QAGvB,IAAInD,EAAMoD;UACRuB,IAAWA,iBAAAA,IAAAA,EAAU/H;;QAGvB,IAAI+H,GAAU;UAEZ,IAAIA,EAASjI;YACXiI,IAAWA,EAASjI;;UAItB,IAAwB,mBAAbiI,GAAuB;YAChCtB,SAASP,GAAY9C,GAAO2E;YAC5B;;UAIF,IAAkB7D,UAAdA,IAAA6D,EAAS3J,eAAK8F,MAAAA,SAAAA,IAAAA,EAAA8D,KAAAD,GAAGlJ,IAAQ;YAC3B,IAAIkJ,EAAS5E;cACX4E,EAAS5E,OAAOC,GAAOvE;;YAMzB,IAAmB,kBAAfA,EAAMsB;cACR2G,YAAY1D,IAAO;;cAEnBA,EAAMyD,gBAAe;;YAGvB,OAAOkB,EAAS3H;;;QAGpB6H,aAAa7E;;MAIfsE,OAAOtE,GAAOqE;MACdhB,SAASe,GAAmBpE,GAAO;MACnC,OAAO;AACT,KA5IauD,CAAS3E,GAAQoB,GAAO2C;;AAGrC;;AA4IA,SAAS2B,OAAOQ,GAAYC;EAC1B,IAAMb,IAAOD,OAAOC,KAAKa;EACzB,KAAK,IAAIZ,IAAI,GAAGA,IAAID,EAAK5J,QAAQ6J;IAG/BW,EAAGZ,EAAKC,MAAMY,EAAKb,EAAKC;;EAE1B,OAAOW;AACT;;AAGA,IAAMV,IAAoB;EACxBY,SAAS;EACTtH,SAAS;;;AAIX,SAAS2F,SACP4B,GACAjF,GACAkF;EAEA,KAAKD,EAAMC;IACT,MAAM,IAAIC,UAAU,mBAAmBD;;EAEzClF,EAAMe,YAASkD,OAAAK,OAAA,CAAA,GAAQtE;EACvBA,EAAMjD,OAAOmI;EACblF,EAAM7B,OAAO;EACb6B,EAAMa,OAAO;EACbb,EAAMX,OAAO4F,EAAMC;EACnBlF,EAAMmD,OAAO;EACbnD,EAAMoD,kBAAiB;AACzB;;AAGA,SAASI,QAAQxD;EAEf,KAAKA,EAAMe;IACT;;EAEFf,EAAMjD,OAAOiD,EAAMe,UAAUhE;EAC7BiD,EAAM7B,OAAO6B,EAAMe,UAAU5C;EAC7B6B,EAAMa,OAAOb,EAAMe,UAAUF;EAC7Bb,EAAMX,OAAOW,EAAMe,UAAU1B;EAC7BW,EAAMmD,OAAOnD,EAAMe,UAAUoC;EAC7BnD,EAAMoD,iBAAiBpD,EAAMe,UAAUqC;EACvCpD,EAAMe,YAAYf,EAAMe,UAAUA;AACpC;;AAGA,SAAS2C,YAAY1D,GAAcoF;;EAGjC,IAAIvI,OAAOmD,MAAUA,EAAMX,MAAM;IAG/B,IAAM8D,IAAOnD,EAAMX,KAAKW,EAAMmD;IAC9B,IAAIA,EAAKvG,WAAW;MAClB,KAAMA,WAAEA,KAAcuG;MACtBnD,EAAMoD,kBAAkBpD,EAAMoD;MAE9B,KAAKpD,EAAMoD,kBAAkBxG,EAAUF;QACrC;;;IAIJ,IAAI0I;MACF;;;EAMJpF,EAAMoD,kBAAiB;EACvBpD,EAAMmD;EAGN,OACEnD,EAAMX,UACJxD,MAAMwJ,QAAQrF,EAAMX,SAASW,EAAMmD,OAAOnD,EAAMX,KAAK/E,SACvD;IACAkJ,QAAQxD;IAER,IAAIA,EAAMX;MAER,IAAIxC,OAAOmD;QAGT,IAAcc,UAAVA,IAAAd,EAAMX,cAAIyB,MAAAA,SAAAA,IAAAA,EAAGd,EAAMmD,MAAMvG;UAC3BoD,EAAMoD,kBAAkBpD,EAAMoD;;aAE3B;QACLpD,EAAMoD,kBAAiB;QACvBpD,EAAMmD;;;;AAId;;AAEA,SAAStG,OAAOmD;EACd,IAAMmD,IACJtH,MAAMwJ,QAAQrF,EAAMX,SACc,mBAA3BW,EAAMX,KAAKW,EAAMmD,SACvBnD,EAAMX,KAAKW,EAAMmD;EAEpB,OAAOA,KAAQA,EAAKtG;AACtB;;AAGA,SAASgI,aAAa7E;EAGpB,OACEA,EAAMX,UAGJxD,MAAMwJ,QAAQrF,EAAMX,UAASW,EAAMX,KAAKW,EAAMmD,MAAMzG;IAEtD8G,QAAQxD;;EAKV,IAAIA,EAAMX;IACRqE,YAAY1D,IAAO;;AAEvB;;;;;;ACvUM,MAAOsF;EAGXzL,WAAAA,CAAY0L,GAAkBC;IAa9BzL,KAAA0L,mBAAoBnK;MAClB,IAAIvB,KAAKwL,MAAMG,SAASpK,EAASoK;QAC/B,OAAO3L,KAAKwL,MAAM/I,aAAalB,EAASkB;;MAE1C,IAAIzC,KAAKyL,IAAIE,SAASpK,EAASoK;QAC7B,OAAO3L,KAAKyL,IAAIhJ,aAAalB,EAASkB;;MAExC,OAAOzC,KAAKwL,MAAMG,QAAQpK,EAASoK,QAAQ3L,KAAKyL,IAAIE,QAAQpK,EAASoK;;IAnBrE3L,KAAKwL,QAAQA;IACbxL,KAAKyL,MAAMA;AACb;EAEAG,QAAAA,CAASD,GAAclJ;IACrBzC,KAAKwL,QAAQ,IAAIK,SAASF,GAAMlJ;AAClC;EAEAqJ,MAAAA,CAAOH,GAAclJ;IACnBzC,KAAKyL,MAAM,IAAII,SAASF,GAAMlJ;AAChC;;;AAaI,MAAOoJ;EAGX/L,WAAAA,CAAY6L,GAAclJ;IAa1BzC,KAAA+L,oBAAqBxK,KACnBvB,KAAK2L,OAAOpK,EAASoK,QACpB3L,KAAK2L,SAASpK,EAASoK,QAAQ3L,KAAKyC,aAAalB,EAASkB;IAd3DzC,KAAK2L,OAAOA;IACZ3L,KAAKyC,YAAYA;AACnB;EAEAuJ,OAAAA,CAAQL;IACN3L,KAAK2L,OAAOA;AACd;EAEAM,YAAAA,CAAaxJ;IACXzC,KAAKyC,YAAYA;AACnB;;;AChBF,IAAMyJ,IAAoB,EACxBC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GAEAC,GACAC;;AChBK,IAAMC,IACJ,SADIA,IAEF,WAFEA,IAGE,eAHFA,IAIL;;AAOD,IAAMC,IAAsB;EACjCC,CAACF,IAAiB;EAClBG,CAACH,IAAmB;EACpBI,CAACJ,IAAuB;EACxBK,CAACL,IAAgB;;;AAGnB,IAAMM,YAAYA,CAACC,GAAgBC;EACjC,KAAKD;IACH,MAAM,IAAIE,MAAMD;;;;AAId,SAAUE,eACdC,GACAC,IAA2C,MAC3CC,GACAC,GACAC;;EAEA,IAAIC,IAAM;EACV,IAAIC,IAAY;EAChB,IAAIF;IACFE,IAC+B,mBAAtBF,IACHA,IACAA,EAAkBG,OAChB,CAACC,GAAKC,MAASD,IAAME,EAAMD,KAAQ,QACnC;;EAGV,IAAME,IAAgBL,IAAY,GAAGN,QAAYM,MAAcN;EAE/D;IACEK,IAAMO,EAAMD;AACb,IAAC,OAAOE;IACP,IAAIA,aAAiBC,GAAc;MACjC,IAAMC,IA0FN,SAAUC,SAASC,GAA0BC;QACjD,IAAMC,IAASlG;QACf,IAAM1C,IAAQ4I,EAAO5F;QACrB,IAAM6F,IAAQF,EAAUG,MAAM;QAE9B1B,UACEyB,EAAMvO,UAAUoO,EAAShD,MACzB;QAGF,IAAI9G,IAAS;QAEb,KAAK,IAAIuF,IAAI,GAAGA,IAAIuE,EAAShD,MAAMvB,KAAK;UACtCvF,IAAS,IAAIhF,gBAAgBiP,EAAM1E;UACnC,QAAQvF,EAAOxE,OAAO;YAEpB,IAAc,kBADAwO,EAAOnN,MAAMmD,GAAQoB;cAEjC;;;;QAKNoH,UAAUxI,GAAQ;QAClB,IAAM8G,IAAOgD,EAAShD,OAAO;QAG7B,IAAMH,IAAQ3G,EAAO1E;QAGrB,IAAMsL,IAAM5G,EAAOzE;QACnB,OAAO,IAAImL,MAAM,IAAIM,SAASF,GAAMH,IAAQ,IAAIK,SAASF,GAAMF;AACjE,OAzHoBiD,CACQM,UAApBA,IAAejI,UAAfA,IAAAwH,EAAMU,mBAASlI,MAAAA,SAAAA,IAAAA,EAAG,YAAEiI,MAAAA,IAAAA,IAAI;QAAErD,MAAM;QAAGzJ,QAAQ;SAC3CmM;MAGF,OAAO,EACL;QACEa,UAAUlC,EAAoBQ;QAC9BD,SAASgB,EAAMhB;QACf4B,QAAQ;QACRV;;;IAIN,MAAMF;;EAGR,OAGI,SAAUa,cACdrB,GACAJ,IAA2C,MAC3CC,GACAC;IAGA,KAAKF;MACH,OAAO;;IAGT,IAAM0B,IDxDF,SAAUC,wBACd3B,GACAI,GACAH,GACAC,GACA0B;MAEA,IAAMrE,IAAQsE,EAAeC,OAAOnK;QAIlC,IAAIA,MAASoK,KAAyBpK,MAASqK;UAC7C,QAAO;;QAET,IAAI9B,KAAqBvI,MAASsK;UAChC,QAAO;;QAET,QAAO;;MAGT,IAAIhC;QACF9L,MAAM+N,UAAUC,KAAKC,MAAM7E,GAAO0C;;MAEpC,IAAI2B;QACFzN,MAAM+N,UAAUC,KAAKC,MAAM7E,GAAOgB;;MAGpC,OADe8D,EAASrC,GAAQI,GAAK7C,GACvBuE,OAAOlB;QACnB,IAAIA,EAAMhB,QAAQ0C,SAAS,wBAAwB1B,EAAM2B,OAAO;UAC9D,IAAM/B,IAAOI,EAAM2B,MAAM;UACzB,IAAI/B,KAAQA,EAAKnL,SAASe,EAAKoM,WAAW;YACxC,IAAM/L,IAAO+J,EAAK/J,KAAKjB;YACvB,IAAa,gBAATiB,KAAiC,0BAATA;cAC1B,QAAO;;;;QAIb,QAAO;;AAEX,KCiBqCkL,CACjC3B,GACAI,GACAH,GACAC,GACAuC,QAAQ7B,KACR8B,YAAY9B,GAAOvB,EAAoBQ,OAAO;IAIhD,IAAM8C,IAAgCN,EAASrC,GAAQI,GAAK,EAC1DwC,KACCH,QAAQ7B,KACT8B,YAAY9B,GAAOvB,EAAoBwD,SAAS;IAElD,OAAOnB,EAA2B3E,OAAO4F;AAC3C,GA9BSlB,CAAcrB,GAAKJ,GAAQC,GAAaC;AACjD;;AA+BA,SAASwC,YACP9B,GACAW,GACApI;EAEA,KAAKyH,EAAM2B;IACT,OAAO;;EAET,IAAMO,IAAiC;EACvC,KAAK,KAAOrG,GAAG+D,MAASI,EAAM2B,MAAMQ,WAAW;IAC7C,IAAMC,IACU,eAAdxC,EAAKnL,QAAuB,UAAUmL,UAAsB3D,MAAd2D,EAAK/J,OAC/C+J,EAAK/J,OACL,cAAc+J,UAA0B3D,MAAlB2D,EAAKyC,WAC3BzC,EAAKyC,WACLzC;IACN,IAAIwC,GAAe;MACjBtD,UACEkB,EAAMU,WACN;MAKF,IAAM4B,IAAMtC,EAAMU,UAAU7E;MAC5B,IAAM0G,IAAeC,YAAYJ;MACjC,IAAMlF,IAAMoF,EAAI3O,UAAU4O,EAAarF,MAAMqF,EAAatF;MAC1DiF,EAAiBX,KAAK;QACpBX,QAAQ,YAAYrI;QACpByG,SAASgB,EAAMhB;QACf2B;QACAT,OAAO,IAAIlD,MACT,IAAIM,SAASgF,EAAIlF,OAAO,GAAGkF,EAAI3O,SAAS,IACxC,IAAI2J,SAASgF,EAAIlF,OAAO,GAAGF;;;;EAKnC,OAAOgF;AACT;;AA0CA,SAASM,YAAY5C;EAEnB,IAAMQ,IADiBR,EACS0C;EAChCxD,UAAUsB,GAAU;EAGpB,OAAOA;AACT;;AC3NA,IAAAqC,IAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVO,IAAMC,IAAY,IAAIC,IAAI,EAAC,OAAO;;ACIlC,IAAMC,SAAUhD,KACrB1O,EAAG2R,iBAAiBjD,MACM,MAA1BA,EAAKkD,UAAU9Q,WACdd,EAAG6R,qBAAqBnD,EAAKoD,eAC5B9R,EAAG+R,gBAAgBrD,EAAKoD,iBACzBpD,EAAKoD,WAAWE,kBAChBtD,EAAKoD,WAAWG,WAAWnR;;AAGvB,IAAMoR,8BACXxD,KAEA1O,EAAGmS,aAAazD,MAAS8C,EAAUY,IAAI1D,EAAK2D;;AAGvC,IAAMC,wBAAwBA,CACnC5D,GACA6D;EAEA,KAAKvS,EAAGwS,yBAAyB9D;IAAO,QAAO;;EAC/C,IAAMrH,IAAOkL,GAASE,kBAAkB/D;EAGxC,OACU,QAARrH,KAC8B,QAA9BA,EAAKqL,YAAY,aACgB,QAAjCrL,EAAKqL,YAAY;;;AAKd,IAAMC,oBAAoBA,CAC/BjE,GACA6D;EAIA,KAAKvS,EAAG2R,iBAAiBjD;IACvB,QAAO;SACF,IAAIA,EAAKkD,UAAU9Q,SAAS,KAAK4N,EAAKkD,UAAU9Q,SAAS;IAC9D,QAAO;SACF,KAAKd,EAAG4S,oBAAoBlE,EAAKkD,UAAU;IAChD,QAAO;;EAET,OAAOW,IAAUD,sBAAsB5D,EAAKoD,YAAYS,MAAW;;;AAI9D,IAAMM,sBAAsBA,CACjCnE,GACA6D;EAEA,KAAK7D;IACH,QAAO;SACF,KAAK1O,EAAG2R,iBAAiBjD;IAC9B,QAAO;SACF,KAAK1O,EAAG8S,2BAA2BpE,EAAKoD;IAC7C,QAAO;SACF,KACJ9R,EAAGmS,aAAazD,EAAKoD,WAAWnN,SACI,gBAArC+J,EAAKoD,WAAWnN,KAAK0N;IAErB,QAAO;SACF,IAAIH,4BAA4BxD,EAAKoD,WAAWA;IACrD,QAAO;;IAEP,OAAOQ,sBAAsB5D,EAAKoD,WAAWA,YAAYS;;;;IAUhDQ,gBAAgBA,CAC3BrE,GACA6D,MAGEvS,EAAG2R,iBAAiBjD,MACpBA,EAAKkD,UAAU9Q,UAAU,KACzB4N,EAAKkD,UAAU9Q,UAAU,MACxBoR,4BAA4BxD,EAAKoD,eAChCa,kBAAkBjE,GAAM6D;;IAKjBS,eACXtE,KAEA1O,EAAGiT,2BAA2BvE,MAASwD,4BAA4BxD,EAAKwE;;AAGnE,IAAMC,gBAAgBA,CAC3BzE,GACA0E,GACAP,KAAsB;EAEtB,KAAKO;IAAa,OAAO;;EACzB,IAAM/L,IAAO+L,EAAYX,kBAGvBI,IAAsBnE,EAAK2E,WAAW,GAAGA,WAAW,KAAK3E,EAAKoD;EAEhE,IAAIzK,GAAM;IACR,IAAMiM,IAAkBjM,EAAKqL,YAAY;IACzC,IAAIY,GAAiB;MACnB,IAAMC,IAAQH,EAAYI,gBAAgBF;MAC1C,IAAIC,EAAME,yBAAyB;QACjC,IAAMC,IAAQH,EAAMI,MAAMC,KAAKC,KAAKA,EAAEC;QACtC,OAAOJ,KAASA,EAAMI,oBAAoBJ,EAAMhQ,QAAQ;AAC1D,aAAO,IAAI6P,EAAMO;QACf,OAAOP,EAAM7P;;AAEjB;AACF;EACA,OAAO;;;AC3EF,SAASqQ,mBAAmBrF;EACjC,QAAQA,EAAKnL;GACX,KAAKvD,EAAGgU,WAAWC;GACnB,KAAKjU,EAAGgU,WAAWE;GACnB,KAAKlU,EAAGgU,WAAWG;GACnB,KAAKnU,EAAGgU,WAAWI;GACnB,KAAKpU,EAAGgU,WAAWK;GACnB,KAAKrU,EAAGgU,WAAWM;GACnB,KAAKtU,EAAGgU,WAAWO;GACnB,KAAKvU,EAAGgU,WAAWQ;GACnB,KAAKxU,EAAGgU,WAAWS;GACnB,KAAKzU,EAAGgU,WAAWU;GACnB,KAAK1U,EAAGgU,WAAWW;GACnB,KAAK3U,EAAGgU,WAAWY;GACnB,KAAK5U,EAAGgU,WAAWa;GACnB,KAAK7U,EAAGgU,WAAWc;GACnB,KAAK9U,EAAGgU,WAAWe;GACnB,KAAK/U,EAAGgU,WAAWgB;GACnB,KAAKhV,EAAGgU,WAAWiB;GACnB,KAAKjV,EAAGgU,WAAWkB;GACnB,KAAKlV,EAAGgU,WAAWmB;GACnB,KAAKnV,EAAGgU,WAAWoB;GACnB,KAAKpV,EAAGgU,WAAWqB;IACjB,QAAO;;GACT;IACE,QAAO;;AAEb;;AAgBO,SAASC,2BACd5G;EAEA,QAAQA,EAAKnL;GACX,KAAKvD,EAAGgU,WAAWK;GACnB,KAAKrU,EAAGgU,WAAWI;GACnB,KAAKpU,EAAGgU,WAAWE;GACnB,KAAKlU,EAAGgU,WAAWM;GACnB,KAAKtU,EAAGgU,WAAWO;GACnB,KAAKvU,EAAGgU,WAAWQ;GACnB,KAAKxU,EAAGgU,WAAWW;GACnB,KAAK3U,EAAGgU,WAAWY;GACnB,KAAK5U,EAAGgU,WAAWa;GACnB,KAAK7U,EAAGgU,WAAWmB;GACnB,KAAKnV,EAAGgU,WAAWe;IACjB,OAAOrG;;GACT,KAAK1O,EAAGgU,WAAWG;GACnB,KAAKnU,EAAGgU,WAAWS;GACnB,KAAKzU,EAAGgU,WAAWc;GACnB,KAAK9U,EAAGgU,WAAWgB;GACnB,KAAKhV,EAAGgU,WAAWiB;GACnB,KAAKjV,EAAGgU,WAAWkB;GACnB,KAAKlV,EAAGgU,WAAWqB;IACjB,OAAO3G,EAAK6G;;GACd,KAAKvV,EAAGgU,WAAWU;IACjB,OAAOhG,EAAKoD;;GACd,KAAK9R,EAAGgU,WAAWC;IACjB,OAxCN,SAASuB,qBAAqBvT;MAC5B,QAAQA,EAAMsB;OACZ,KAAKvD,EAAGgU,WAAWyB;OACnB,KAAKzV,EAAGgU,WAAW0B;OACnB,KAAK1V,EAAGgU,WAAW2B;OACnB,KAAK3V,EAAGgU,WAAW4B;QACjB,QAAO;;OACT;QACE,QAAO;;AAEb,KA8BaJ,CAAqB9G,EAAKmH,iBAAiBnH,EAAKoH,aAAQ/K;;GACjE,KAAK/K,EAAGgU,WAAWoB;IACjB,OAAO1G,EAAKqH;;GACd;IACE;;AAEN;;AAGA,SAASC,iCAAiCtH;EACxC,IACEA,EAAKuH,UACLjW,EAAG8S,2BAA2BpE,EAAKuH,WACnCvH,EAAKuH,OAAOtR,SAAS+J;IAErB,OAAOA,EAAKuH;SACP,IACLvH,EAAKuH,UACLjW,EAAGkW,0BAA0BxH,EAAKuH,WAClCvH,EAAKuH,OAAOE,uBAAuBzH;IAEnC,OAAOA,EAAKuH;;IAEZ,OAAOvH;;AAEX;;AA2BA,SAAS0H,wBAAwBzR;EAC/B,IAAI3E,EAAGqW,uBAAuB1R;IAC5B,OAAO3E,EAAG4S,oBAAoBjO,EAAKmN,eACjC9R,EAAGsW,iBAAiB3R,EAAKmN,cACvBnN,EAAKmN,WAAWyE,YAChBxL;SACC,IAAI/K,EAAGwW,oBAAoB7R,MAAS3E,EAAGyW,aAAa9R;IACzD,OAAO3E,EAAG0W,OAAO/R;;IAEjB,OAAOA,EAAK4R;;AAEhB;;AAWO,SAASI,2BACdjI,GACA6D;EAGA,IAAIqE,IAASrE,EAAQsE,oBAAoBnI;EACzC,IACEkI,GAAQE,eAAe,MACvBF,EAAOG,QAAQ/W,EAAGgX,YAAYC,UAC7BvI,EAAKuH,WAAWW,GAAQE,eAAe,OACrC9W,EAAGkX,kBAAkBN,EAAOE,aAAa,MAC5C;IAEA,IAAMK,IAAU5E,EAAQ6E,iBAAiBR;IACzC,IAAIO,EAAQL;MAAcF,IAASO;;AACrC;EAEA,IAAIP,KAAU5W,EAAGqX,8BAA8B3I,EAAKuH,SAAS;IAG3D,IAAMqB,IAAkB/E,EAAQgF,kCAC9BX,EAAOY;IAET,IAAIF;MAAiBV,IAASU;;AAChC,SAAO,IACLtX,EAAGyX,iBAAiB/I,EAAKuH,WACzBjW,EAAG0X,uBAAuBhJ,EAAKuH,OAAOA,WACtCvH,OAAUA,EAAKuH,OAAO0B,gBAAgBjJ,EAAKuH,OAAOtR,OAClD;IAGA,IAAMA,IAAOyR,wBAAwB1H;IACrC,IAAMkJ,IAAOjT,IACT4N,EAAQE,kBAAkB/D,EAAKuH,OAAOA,QAAQvD,YAAY/N,UAC1DoG;IACJ,IAAI6M;MAAMhB,IAASgB;;AACrB,SAAO,IACL5X,EAAG6X,uBAAuBnJ,EAAKuH,YAC9BjW,EAAG8X,0BAA0BpJ,EAAKuH,OAAOA,WACxCjW,EAAG+X,gBAAgBrJ,EAAKuH,OAAOA,YACjCvH,EAAKuH,OAAOtR,SAAS+J,GACrB;IAGA,IAAM/J,IAAOyR,wBAAwB1H;IACrC,IAAMkJ,IAAOjT,IACT4N,EAAQyF,kBAAkBtJ,EAAKuH,OAAOA,SAASvD,YAAY/N,UAC3DoG;IACJ,IAAI6M;MAAMhB,IAASgB;;AACrB;EAEA,IAAIhB,KAAUA,EAAOE,cAAchW,QAAQ;IACzC,IACE8V,EAAOG,QAAQ/W,EAAGgX,YAAYiB,WAC5BrB,EAAOG,SAAS/W,EAAGgX,YAAYkB,WAAWlY,EAAGgX,YAAYhS,cApGjE,SAASmT,sBAAsBzJ;MAC7B,IAAM0J,IAASpC,iCAAiCtH,GAAMuH;MACtD,OAAOjW,EAAGqY,gBAAgBD,MAAWA,EAAOtG,eAAepD;AAC7D,KAkGMyJ,CAAsBzJ;MAItB,KAAK,IAAM4J,KAAe1B,EAAOE;QAC/B,IAAI9W,EAAGuY,YAAYD;UAAc,OAAOA;;;WAErC,IAtGX,SAASE,4BACP9J;MAEA,IAAM0J,IAASpC,iCAAiCtH,GAAMuH;MACtD,OAAOjW,EAAGyY,sBAAsBL,MAAWA,EAAOtG,eAAepD;AACnE,KAkGM8J,CAA4B9J,MA/FlC,SAASgK,4BAA4BhK;MACnC,OACE1O,EAAGmS,aAAazD,MAChBA,EAAKuH,UACLjW,EAAG2Y,eAAejK,EAAKuH,WACvBvH,EAAKuH,OAAOtR,SAAS+J;AAEzB,KAyFMgK,CAA4BhK;MAI5B,KAAK,IAAM4J,KAAe1B,EAAOE;QAC/B,IACE9W,EAAG2Y,eAAeL,MACfA,EAA2CM,QAC9C7E,mBAAmBuE;UAEnB,OAAOA;;;;IAOb,IACE1B,EAAOY,oBACPxX,EAAG8S,2BAA2B8D,EAAOY,mBACrC;MACA,IAAMvB,IAASW,EAAOY,iBAAiBvB;MACvC,IACEA,KACAjW,EAAG6Y,mBAAmB5C,MACtBA,EAAO6C,SAASlC,EAAOY;QAEvB,OAAOvB;;AAEX;IAEA,IACEW,EAAOY,oBACPzD,mBAAmB6C,EAAOY;MAK1B,OAAOZ,EAAOY;;IAOhB,KAAK,IAAMc,KAAe1B,EAAOE;MAE/B,IAAI/C,mBAAmBuE;QAAc,OAAOA;;;AAEhD;EAEA;AACF;;AAGO,SAASS,qBACdrK,GACA6D;EAEA,OAAOvS,EAAGmS,aAAazD,IAAO;IAC5B,IAAM4J,IAAc3B,2BAA2BjI,GAAM6D;IACrD,KAAK+F;MACH;WACK;MACL,IAAM5U,IAAQ4R,2BAA2BgD;MACzC,IAAI5U,KAAS1D,EAAGmS,aAAazO,MAAUA,MAAUgL;QAG/CA,IAAOhL;;QAEP,OAAOA;;AAEX;AACF;AACF;;ACzTO,SAASsV,gBACdtK,GACAuK,GACAC;EAEA,IAAIlZ,EAAG4S,oBAAoBlE;IACzB,OAAO;MAAEyK,cAAczK,EAAK0K,UAAUhX,MAAM,IAAI;MAAIiX,eAAe;;;EAGrE,IAAIC,IAAe5K,EAAK6K,SAASH,UAAUhX,MAAM,IAAI;EACrD,IACEpC,EAAGwZ,gCAAgC9K,EAAK6K,aACD,MAAvC7K,EAAK6K,SAASE,cAAc3Y;IAE5B,OAAO;MAAEqY,cAAcG;MAAcD,eAAe;;;EAGtD,IAAIK,IAAkB;EACtB,IAAML,IAAgB3K,EAAK6K,SAASE,cACjCE,IAAIC;IACH,IAAI5Z,EAAGmS,aAAayH,EAAK9H,aAAa;MACpC,IAAMsB,IAAc8F,EAAKW,gBAAgBC,cAAcC;MACvD,KAAK3G;QAAa;;MAElB,IAAMkF,IAAc3B,2BAClBiD,EAAK9H,YACLsB;MAEF,KAAKkF;QAAa;;MAElB,IAAMrC,IAASqC;MACf,IAAItY,EAAGga,sBAAsB/D,IAAS;QACpC,IAAMgE,IAAiBL,EAAK9H,WAAWO;QACvC,IAAM3O,IAAQ4R,2BAA2BW;QACzC,KAAKvS;UAAO;;QAGZ,IAAMwW,IAAgBN,EAAK9H,WAAWqI,aAAa;QACnD,IAAMC,IAAgB;UACpBrO,OAAOmO;UAEPpZ,QAAQ8Y,EAAK9H,WAAW9F,MAAMkO,IAAgB;;QAGhD,IAAIla,EAAGiT,2BAA2BvP,IAAQ;UACxC,IAAM6S,IAAOyC,gBACXtV,GACAuS,EAAOoE,gBAAgBC,UACvBpB;UAEFI,IAAeA,EAAaiB,QAC1B,OAAOX,EAAK9H,WAAWO,cAAc,KACrCkE,EAAK4C;UAGP,IAAMqB,IAAc;YAClBnL,OAAOkH,EAAK4C,aAAa7J,MAAM,MAAMxO;YACrC2Z,YAAYR;YACZS,UAAUN;YACVO,KAAK;cACH5O,OAAOqO,EAAcrO,QAAQ2N;cAC7B5Y,QAAQyV,EAAK4C,aAAarY;;;UAG9B4Y,KAAmBnD,EAAK4C,aAAarY,SAASsZ,EAActZ;UAC5D,OAAO0Z;AACT,eAAO,IACLxa,EAAG4a,eAAelX,MAClB1D,EAAGiT,2BAA2BvP,EAAMoO,aACpC;UACA,IAAMyE,IAAOyC,gBACXtV,EAAMoO,YACNmE,EAAOoE,gBAAgBC,UACvBpB;UAEFI,IAAeA,EAAaiB,QAC1B,OAAOX,EAAK9H,WAAWO,cAAc,KACrCkE,EAAK4C;UAEP,IAAMqB,IAAc;YAClBnL,OAAOkH,EAAK4C,aAAa7J,MAAM,MAAMxO;YACrC2Z,YAAYR;YACZS,UAAUN;YACVO,KAAK;cACH5O,OAAOqO,EAAcrO,QAAQ2N;cAC7B5Y,QAAQyV,EAAK4C,aAAarY;;;UAG9B4Y,KAAmBnD,EAAK4C,aAAarY,SAASsZ,EAActZ;UAC5D,OAAO0Z;AACT,eAAO,IACLxa,EAAG4a,eAAelX,MAClB1D,EAAG4a,eAAelX,EAAMoO,eACxB9R,EAAG8X,0BAA0BpU,EAAMoO,WAAWA,aAC9C;UAEA,IAAM+I,IAAmBlM,MADPmM,KAAKjM,MAAMnL,EAAMoO,WAAWA,WAAWsH;UAEzDE,IAAeA,EAAaiB,QAC1B,OAAOX,EAAK9H,WAAWO,cAAc,KACrCwI;UAEF,IAAML,IAAc;YAClBnL,OAAOwL,EAAiBvL,MAAM,MAAMxO;YACpC2Z,YAAYR;YACZS,UAAUN;YACVO,KAAK;cACH5O,OAAOqO,EAAcrO,QAAQ2N;cAC7B5Y,QAAQ+Z,EAAiB/Z;;;UAG7B4Y,KAAmBmB,EAAiB/Z,SAASsZ,EAActZ;UAC3D,OAAO0Z;AACT;QAEA;AACF;AACF;IAEA;KAEDxK,OAAO+K;EAEV,OAAO;IAAE5B,cAAcG;IAAcD;;AACvC;;AAEO,IAAM2B,2BACXtM;EAEA,KAAKA;IAAM;;EAEX,OAAO1O,EAAG4a,eAAelM;IAAOA,IAAOA,EAAKoD;;EAC5C,KAAK9R,EAAGib,yBAAyBvM;IAAO;;EAExC,IAAIA,EAAKwM,SAASjV,MAAMjG,EAAGmS;IAAe,OAAOzD,EAAKwM;;EACtD,IAAMC,IAA+B;EACrC,KAAK,IAAIC,KAAW1M,EAAKwM,UAAU;IACjC,OAAOlb,EAAG8S,2BAA2BsI;MAAUA,IAAUA,EAAQzW;;IACjE,IAAI3E,EAAGmS,aAAaiJ;MAAUD,EAAY9K,KAAK+K;;AACjD;EACA,OAAOD;;;AChJF,SAASE,UAAUnC,GAAkCD;EAC1D,IAAMqC,IAAUpC,EAAKW,gBAAgBC;EACrC,KAAKwB;IAAS;;EAEd,IAAM5L,IAAS4L,EAAQjB,cAAcpB;EACrC,KAAKvJ;IAAQ;;EAEb,OAAOA;AACT;;AAEO,SAAS6L,SACdC,GACA1Z;EAOA,OALA,SAAS8R,KAAKlF;IACZ,IAAI5M,KAAY4M,EAAKyL,cAAcrY,IAAW4M,EAAK+M;MACjD,OAAOzb,EAAG0b,aAAahN,GAAMkF,SAASlF;;AAE1C,GACOkF,CAAK4H;AACd;;AAsCO,SAASG,eACdP,GACAlC,GACA3G;EAEA,IAAMhE,IAAsC;EAC5C,IAAM2M,IAA4B,EAACE;EACnC,IAAMQ,IAAO,IAAIC;EAEjB,IAAMC,iBAAkBV;IACtB,IAAIQ,EAAKxJ,IAAIgJ;MAAU;;IACvBQ,EAAKG,IAAIX;IAET,IAAM1M,IA3BV,SAASsN,+BACPC,GACA/C,GACA3G;MAEA,KAAKA;QAAS,OAAO;;MAErB,IAAM7O,IAAQqV,qBAAqBkD,GAAO1J;MAC1C,KAAK7O;QAAO,OAAO;;MAGnB,OAAOwY,cAAqBxY,GAAO6O,KAAW7O,IAAQ;AACxD,KAeiBsY,CAA+BZ,GAASlC,GAAM3G;IAC3D,KAAK7D;MAAM;;IAEX,IAAMyN,IAAenB,yBAAyBtM,EAAKkD,UAAU;IAC7D,IAAIuK;MAAcjB,EAAS7K,QAAQ8L;;IAEnC;MAEiBtN,EADFH,EAAKkD,UAAU,GACFwH,UAAUhX,MAAM,IAAI,IAAI;QAAEga,aAAY;SACzDC,YAAYC,QAAQC;QACzB,IAAwB,yBAApBA,EAAWhZ;UACbgL,EAAU8B,KAAKkM;;;AAGpB,MAAC,OAAOC,IACP;;EAIJ,IAAIC;EACJ,YAA4C1R,OAApC0R,IAAcvB,EAASwB;IAC7BZ,eAAeW;;EACjB,OAAOlO;AACT;;AAEO,SAASoO,oBACdC,GACAC,GACA3D;EAEA,IAAM9F,IAAc8F,EAAKW,gBAAgBC,cAAcC;EACvD6C,EAAe1B,SAASoB,QAAQlB;IAC9B,IAAIpb,EAAGmS,aAAaiJ;MAClByB,EAAIxM,QAAQsL,eAAeP,GAASlC,GAAM9F;WACrC,IAAIpT,EAAG8S,2BAA2BsI,IAAU;MACjD,IAAI0B,IAAK1B;MACT,OAAOpb,EAAG8S,2BAA2BgK,EAAGhL;QAAagL,IAAKA,EAAGhL;;MAC7D,IAAI9R,EAAGmS,aAAa2K,EAAGnY;QACrBkY,EAAIxM,QAAQsL,eAAemB,EAAGnY,MAAMuU,GAAM9F;;AAE9C;;EAGF,OAAOyJ;AACT;;AAEO,SAASE,uBACdvB,GACAtC,GACA8D,KAAiC;EAUjC,IAAM5J,IAAc8F,EAAKW,gBAAgBC,cAAcC;EACvD,IAAMkD,IAID;EACL,IAAI1O,IAA2C;EAC/C,IAAI2O,IAA0BF,KAAwB,KAAQ;GAE9D,SAASpJ,KAAKlF;IACZ,KAAK1O,EAAG2R,iBAAiBjD,MAASwN,OAAcxN;MAC9C,OAAO1O,EAAG0b,aAAahN,GAAMkF;;IAK/B,KAAKsI,cAAqBxN,GAAM0E;MAC9B,OAAOpT,EAAG0b,aAAahN,GAAMkF;;IAG/B,IAAMjP,IAAOuX,cAAqBxN,GAAM0E;IACxC,IAAMmD,IAAO7H,EAAKkD,UAAU;IAC5B,IAAMuK,IAAenB,yBAAyBtM,EAAKkD,UAAU;IAC7D,IAAMuL,IAAajB,kBAAyBxN,GAAM0E;IAElD,KAAK8J,MAA4Bf;MAE/B,KAAKgB,GAAY;QACfD,KAA0B;QAC1B3O,EAAU8B,QAAQ+M,gBAAgB1O,GAAMwK;AAC1C;WACK,IAAIiD;MACT,KAAK,IAAM1B,KAAc0B;QACvB5N,EAAU8B,QAAQsL,eAAelB,GAAYvB,GAAM9F;;;IAIvD,IAAImD,KAAQvW,EAAG4S,oBAAoB2D;MACjC0G,EAAO5M,KAAK;QACV3B,MAAM6H;QACNrI,QAAQvJ;QACR0Y,kBAAkBF,SACGpS,MAAjBoR,IACE,KACAA,SACFpR;;;AAGV,GACA6I,CAAK4H;EACL,OAAO;IAAE/K,OAAOwM;IAAQ1O;;AAC1B;;AAUO,SAAS+O,gCACd9B,GACAtC;EAEA,IAAM+D,IAEF;EACJ,IAAM7J,IAAc8F,GAAMW,gBAAgBC,cAAcC;GACxD,SAASnG,KAAKlF;IACZ,KAAK1O,EAAG2R,iBAAiBjD,MAASwN,OAAcxN;MAC9C,OAAO1O,EAAG0b,aAAahN,GAAMkF;;IAG/B,KAAKsI,oBAA2BxN,GAAM0E;MACpC;WACK,IAAI8F,GAAM;MACf,IAAMvU,IAAOuX,cAAqBxN,GAAM0E,IAAa;MACrD6J,EAAO5M,KAAK;QAAE3B;QAAMR,QAAQvJ;;AAC9B;MACEsY,EAAO5M,KAAK3B;;AAEhB,GACAkF,CAAK4H;EACL,OAAOyB;AACT;;AAEO,SAASG,gBACd1O,GACAwK;EAEA,IAAI3K,IAA2C;EAE/C,IAAM6E,IAAc8F,EAAKW,gBAAgBC,cAAcC;EACvD,KAAK/Z,EAAG2R,iBAAiBjD;IACvB,OAAOH;;EAGT,IAAM4N,IAAenB,yBAAyBtM,EAAKkD,UAAU;EAC7D,IAAIuK,GAAc;IAChB,IAAM/I,IAAc8F,EAAKW,gBAAgBC,cAAcC;IACvD,KAAK,IAAMU,KAAc0B;MACvB5N,EAAU8B,QAAQsL,eAAelB,GAAYvB,GAAM9F;;IAErD,OAAO7E;AACR,SAAM,IAAI2N,kBAAyBxN,GAAM0E;IACxC,OAAO7E;;EAGT,KAAK6E;IAAa,OAAO7E;;EAEzB,IAAMkM,IFgFD,SAAS8C,+BACd7O;IAEA,IAAI0J,IAAoC1J;IACxC,OAAO0J;MACL,IAAIpY,EAAG8S,2BAA2BsF;QAChCA,IAASA,EAAOzT;aACX,IACL3E,EAAG4a,eAAexC,MAClBpY,EAAGwd,sBAAsBpF,MACzBpY,EAAGyd,oBAAoBrF,MACvBpY,EAAG0d,0BAA0BtF,MAC7BpY,EAAG2d,8BAA8BvF;QAEjCA,IAASA,EAAOtG;aACX,IAAI9R,EAAG4d,sBAAsBxF;QAClCA,IAASA,EAAO8C,SAAS9C,EAAO8C,SAASpa,SAAS;aAC7C,IAAId,EAAGmS,aAAaiG;QACzB,OAAOA;;QAEP;;;AAGN,GEvGqBmF,CAA+B7O,EAAKoD;EACvD,KAAK2I;IAAY,OAAOlM;;EAExB,IAAM+J,IAAc3B,2BAA2B8D,GAAYrH;EAC3D,KAAKkF;IAAa,OAAO/J;;EAEzB,IAAMiN,IAAalD,EAAY+B;EAC/B,KAAKmB;IAAY,OAAOjN;;EAExB,IAAM8N,IAAc,EAClB;IACE/B,UAAUkB,EAAWlB;IACrBuD,UAAU;MACR9R,OAAOuM,EAAY6B;MACnBrZ,QAAQwX,EAAYwF;;;EAI1B,KAAKzB,MAAgBA,EAAYvb;IAAQ,OAAOyN;;EAEhD,IAAMwP,IAAM1B,EAAY;EACxB,KAAK0B;IAAK,OAAOxP;;EACjB,IAAMyP,IAAM3C,UAAUnC,GAAM6E,EAAIzD;EAChC,KAAK0D;IAAK,OAAOzP;;EAEjBvO,EAAG0b,aAAasC,GAAKtP;IACnB,IACE1O,EAAGie,oBAAoBvP,MACvBA,EAAKwP,mBACLxP,EAAKwP,gBAAgBpH,aAAa,MACsB,gBAAxDpI,EAAKwP,gBAAgBpH,aAAa,GAAGnS,KAAKyU,WAC1C;MACA,KAAOd,KAAe5J,EAAKwP,gBAAgBpH;MAC3C,IACEwB,EAAY/C,eACZvV,EAAG8X,0BAA0BQ,EAAY/C;QAEzC+C,EAAY/C,YAAY4I,WAAW7B,QAAQ8B;UACzC,IACEpe,EAAGqe,qBAAqBD,MACxBpe,EAAG8T,gBAAgBsK,EAASzZ;YAE5B;cACE,IAAM2Z,IAAmBxD,KAAKjM,MAC5B,GAAGuP,EAASzZ,KAAKyU,UAAUmB,QAAQ,MAAM;cAG3C,IACE+D,EAAiB9N,SAAS,gBAC1B8N,EAAiB9N,SAAS,SAC1B;gBACe3B,EAAMyP,GAAkB;kBACrClC,aAAY;mBAEPC,YAAYC,QAAQC;kBACzB,IAAwB,yBAApBA,EAAWhZ;oBACbgL,EAAU8B,KAAKkM;;;AAGrB;AACF,cAAE,OAAOhL,IAAS;;;;AAI1B;;EAGF,OAAOhD;AACT;;AAQO,SAASgQ,0BACd/C;EAEA,IAAMyB,IAAmC;GAEzC,SAASrJ,KAAKlF;IACZ,IH/MFA;MAEA,KAAK1O,EAAG2R,iBAAiBjD;QAAO,QAAO;;MACvC,KAAK1O,EAAGmS,aAAazD,EAAKoD;QAAa,QAAO;;MAE9C,OAAuC,oBAAhCpD,EAAKoD,WAAWO;MG0MjB6J,CAA2BxN;MAC7BuO,EAAO5M,KAAK3B;;IAEd1O,EAAG0b,aAAahN,GAAMkF;AACxB,GACAA,CAAK4H;EACL,OAAOyB;AACT;;AAEO,SAASuB,iBAAiB9P;EAC/B,OACE1O,EAAGwZ,gCAAgC9K,MACnC1O,EAAGye,QAAQ/P,MACX1O,EAAG0e,qBAAqBhQ,MACxB1O,EAAG2e,eAAejQ;IAElBA,IAAOA,EAAKuH;;EAGd,OAAOvH;AACT;;AAEO,SAASkQ,uBAAuBlQ;EACrC,OACE1O,EAAG4S,oBAAoBlE,MACvB1O,EAAGye,QAAQ/P,MACX1O,EAAG0e,qBAAqBhQ,MACxB1O,EAAG2e,eAAejQ;IAElBA,IAAOA,EAAKuH;;EAGd,OAAOvH;AACT;;AC1WA,IAAMmQ,IACmB,mBAAhBC,eACPA,eAC2B,qBAApBA,YAAYC,MACfD,cACAE;;AAEN,IAAMC,KAAS,IAAIxN;;AAMnB,IAAMyN,KACe,mBAAZC,WAA0BA,UAAUA,UAAU;;AAIvD,IAAMC,cAAcA,CAClBC,GACAhY,GACAiY,GACAC;EAE+B,qBAAxBL,GAAQE,cACXF,GAAQE,YAAYC,GAAKhY,GAAMiY,GAAMC,KACrCC,QAAQ1Q,MAAM,IAAIwQ,MAASjY,MAASgY;;;AAG1C,IAAII,KAAKC,WAAWC;;AACpB,IAAIC,KAAKF,WAAWG;;AAGpB,SAAkB,MAAPJ,IAAoB;EAE7BG,KAAK,MAAMC;IAETC,SAAqC;IAErCC,SAAmB;IACnBC,gBAAAA,CAAiBC,GAAWV;MAC1Bhf,KAAKuf,SAASzP,KAAKkP;AACrB;;EAGFE,KAAK,MAAME;IACTtf,WAAAA;MACE6f;AACF;IACAC,OAAS,IAAIP;IACbQ,KAAAA,CAAMC;MACJ,IAAI9f,KAAK4f,OAAOJ;QAAS;;MAEzBxf,KAAK4f,OAAOE,SAASA;MAErB9f,KAAK4f,OAAOJ,WAAU;MAEtB,KAAK,IAAMR,KAAMhf,KAAK4f,OAAOL;QAC3BP,EAAGc;;MAEL9f,KAAK4f,OAAOG,UAAUD;AACxB;;EAEF,IAAIE,KAC2C,QAA7CrB,GAAQsB,KAAKC;EACf,IAAMP,iBAAiBA;IACrB,KAAKK;MAAwB;;IAC7BA,MAAyB;IACzBnB,YACE,oaAOA,uBACA,WACAc;;;;AAYN,IAAMQ,WAAYC,KAChBA,KAAKA,MAAMtW,KAAKC,MAAMqW,MAAMA,IAAI,KAAKC,SAASD;;AAchD,IAAME,eAAgBC,MACnBJ,SAASI,KACN,OACAA,KAAOzW,KAAK0W,IAAI,GAAG,KACnBC,aACAF,KAAOzW,KAAK0W,IAAI,GAAG,MACnBE,cACAH,KAAOzW,KAAK0W,IAAI,GAAG,MACnBG,cACAJ,KAAO9c,OAAOmd,mBACdC,YACA;;AAGN,MAAMA,kBAAkB/e;EACtBhC,WAAAA,CAAYghB;IACVC,MAAMD;IACN9gB,KAAKghB,KAAK;AACZ;;;AAIF,MAAMC;EAIJC,WAAgC;EAChC,aAAOC,CAAOZ;IACZ,IAAMa,IAAUd,aAAaC;IAC7B,KAAKa;MAAS,OAAO;;IACrBH,OAAMI,KAAgB;IACtB,IAAMC,IAAI,IAAIL,MAAMV,GAAKa;IACzBH,OAAMI,KAAgB;IACtB,OAAOC;AACT;EACAxhB,WAAAA,CACEygB,GACAa;IAGA,KAAKH,OAAMI;MACT,MAAM,IAAIjW,UAAU;;IAGtBpL,KAAKuhB,OAAO,IAAIH,EAAQb;IACxBvgB,KAAKO,SAAS;AAChB;EACAuP,IAAAA,CAAKsQ;IACHpgB,KAAKuhB,KAAKvhB,KAAKO,YAAY6f;AAC7B;EACAoB,GAAAA;IACE,OAAOxhB,KAAKuhB,OAAOvhB,KAAKO;AAC1B;;;AAwoBI,MAAOkhB;EAIFlB;EACAmB;EACAC;EACAC;EACAC;EAkETf;EACAgB;EACAC;EACAC;EACAC;EACAthB;EACAuhB;EACAC;EACAC;EACAC;EACAC;EACAC;EACAC;EACAC;EAEAC;EACAC;EACAC;EAWA,4BAAOC,CAILC;IACA,OAAO;MAELN,QAAQM,GAAEN;MACVC,MAAMK,GAAEL;MACRF,OAAOO,GAAEP;MACTR,QAAQe,GAAEf;MACVC,SAASc,GAAEd;MACXC,SAASa,GAAEb;MACXthB,MAAMmiB,GAAEniB;MACRuhB,MAAMY,GAAEZ;MACR,QAAIC;QACF,OAAOW,GAAEX;AACV;MACD,QAAIC;QACF,OAAOU,GAAEV;AACV;MACDC,MAAMS,GAAET;MAERU,mBAAoB7f,KAAW4f,GAAEC,EAAmB7f;MACpD8f,iBAAiBA,CACfC,GACAC,GACAta,GACAua,MAEAL,GAAEE,EACAC,GACAC,GACAta,GACAua;MAEJC,YAAaF,KACXJ,GAAEM,EAAYF;MAChBG,SAAUza,KACRka,GAAEO,EAASza;MACb0a,UAAW1a,KACTka,GAAEQ,EAAU1a;MACd2a,SAAUL,KACRJ,GAAES,EAASL;;AAEjB;EAOA,OAAI3C;IACF,OAAOvgB,MAAKugB;AACd;EAIA,WAAImB;IACF,OAAO1hB,MAAK0hB;AACd;EAIA,kBAAII;IACF,OAAO9hB,MAAK8hB;AACd;EAIA,QAAIhB;IACF,OAAO9gB,MAAK8gB;AACd;EAIA,eAAIe;IACF,OAAO7hB,MAAK6hB;AACd;EAIA,WAAIF;IACF,OAAO3hB,MAAK2hB;AACd;EAIA,gBAAIC;IACF,OAAO5hB,MAAK4hB;AACd;EAEA9hB,WAAAA,CACE8I;IAEA,KAAM2X,KACJA,IAAM,GAACiD,KACPA,GAAGC,eACHA,IAAgB,GAACC,cACjBA,GAAYC,gBACZA,GAAcC,gBACdA,GAAcC,YACdA,GAAUlC,SACVA,GAAOC,cACPA,GAAYkC,gBACZA,GAAcC,aACdA,GAAWrC,SACXA,IAAU,GAACsC,cACXA,IAAe,GAACC,iBAChBA,GAAepC,aACfA,GAAWqC,0BACXA,GAAwBC,oBACxBA,GAAkBC,4BAClBA,GAA0BC,wBAC1BA,GAAsBC,kBACtBA,KACE1b;IAEJ,IAAY,MAAR2X,MAAcJ,SAASI;MACzB,MAAM,IAAInV,UAAU;;IAGtB,IAAMmZ,IAAYhE,IAAMD,aAAaC,KAAOze;IAC5C,KAAKyiB;MACH,MAAM,IAAI/W,MAAM,wBAAwB+S;;IAG1CvgB,MAAKugB,IAAOA;IACZvgB,MAAK0hB,IAAWA;IAChB1hB,KAAKgkB,eAAeA,KAAgBhkB,MAAK0hB;IACzC1hB,KAAKikB,kBAAkBA;IACvB,IAAIjkB,KAAKikB,iBAAiB;MACxB,KAAKjkB,MAAK0hB,MAAa1hB,KAAKgkB;QAC1B,MAAM,IAAI5Y,UACR;;MAGJ,IAAoC,qBAAzBpL,KAAKikB;QACd,MAAM,IAAI7Y,UAAU;;;IAIxB,SACkBZ,MAAhBqX,KACuB,qBAAhBA;MAEP,MAAM,IAAIzW,UACR;;IAGJpL,MAAK6hB,IAAeA;IACpB7hB,MAAK2iB,MAAoBd;IAEzB7hB,MAAK+hB,IAAU,IAAIyC;IACnBxkB,MAAKgiB,IAAW,IAAIlgB,MAAMye,GAAKS,UAAKxW;IACpCxK,MAAKiiB,IAAW,IAAIngB,MAAMye,GAAKS,UAAKxW;IACpCxK,MAAKW,IAAQ,IAAI4jB,EAAUhE;IAC3BvgB,MAAKkiB,IAAQ,IAAIqC,EAAUhE;IAC3BvgB,MAAKmiB,IAAQ;IACbniB,MAAKoiB,IAAQ;IACbpiB,MAAKqiB,IAAQpB,MAAME,OAAOZ;IAC1BvgB,MAAK8gB,IAAQ;IACb9gB,MAAK8hB,IAAkB;IAEvB,IAAuB,qBAAZH;MACT3hB,MAAK2hB,IAAWA;;IAElB,IAA4B,qBAAjBC,GAA6B;MACtC5hB,MAAK4hB,IAAgBA;MACrB5hB,MAAKsiB,IAAY;WACZ;MACLtiB,MAAK4hB,SAAgBpX;MACrBxK,MAAKsiB,SAAY9X;;IAEnBxK,MAAK0iB,MAAgB1iB,MAAK2hB;IAC1B3hB,MAAK4iB,MAAqB5iB,MAAK4hB;IAE/B5hB,KAAK8jB,mBAAmBA;IACxB9jB,KAAK+jB,gBAAgBA;IACrB/jB,KAAKkkB,6BAA6BA;IAClClkB,KAAKokB,+BAA+BA;IACpCpkB,KAAKqkB,2BAA2BA;IAChCrkB,KAAKskB,qBAAqBA;IAG1B,IAA0B,MAAtBtkB,KAAKgkB,cAAoB;MAC3B,IAAsB,MAAlBhkB,MAAK0hB;QACP,KAAKvB,SAASngB,MAAK0hB;UACjB,MAAM,IAAItW,UACR;;;MAIN,KAAK+U,SAASngB,KAAKgkB;QACjB,MAAM,IAAI5Y,UACR;;MAGJpL,MAAKykB;;IAGPzkB,KAAK6jB,eAAeA;IACpB7jB,KAAKmkB,uBAAuBA;IAC5BnkB,KAAK2jB,mBAAmBA;IACxB3jB,KAAK4jB,mBAAmBA;IACxB5jB,KAAKyjB,gBACHtD,SAASsD,MAAoC,MAAlBA,IACvBA,IACA;IACNzjB,KAAK0jB,iBAAiBA;IACtB1jB,KAAKwjB,MAAMA,KAAO;IAClB,IAAIxjB,KAAKwjB,KAAK;MACZ,KAAKrD,SAASngB,KAAKwjB;QACjB,MAAM,IAAIpY,UACR;;MAGJpL,MAAK0kB;;IAIP,IAAkB,MAAd1kB,MAAKugB,KAA2B,MAAbvgB,KAAKwjB,OAA+B,MAAlBxjB,MAAK0hB;MAC5C,MAAM,IAAItW,UACR;;IAGJ,KAAKpL,KAAK0jB,iBAAiB1jB,MAAKugB,MAASvgB,MAAK0hB,GAAU;MACtD,IAAM3C,IAAO;MACb,IA3hCcA,OAAkBL,GAAO7M,IAAIkN,GA2hCvC4F,CAAW5F,IAAO;QACpBL,GAAOlD,IAAIuD;QAIXF,YAFE,iGAEe,yBAAyBE,GAAM0C;;;AAGtD;EAKAmD,eAAAA,CAAgBC;IACd,OAAO7kB,MAAK+hB,EAAQlQ,IAAIgT,KAAOC,QAAW;AAC5C;EAEA,EAAAJ;IACE,IAAMjC,IAAO,IAAI5B,UAAU7gB,MAAKugB;IAChC,IAAMiC,IAAS,IAAI3B,UAAU7gB,MAAKugB;IAClCvgB,MAAKyiB,IAAQA;IACbziB,MAAKwiB,IAAUA;IAEfxiB,MAAK+kB,IAAc,CAAC7B,GAAOM,GAAKhY,IAAQ8S,EAAKE;MAC3CgE,EAAOU,KAAiB,MAARM,IAAYhY,IAAQ;MACpCiX,EAAKS,KAASM;MACd,IAAY,MAARA,KAAaxjB,KAAK0jB,cAAc;QAClC,IAAM3gB,IAAIiiB,WAAW;UACnB,IAAIhlB,MAAKujB,EAASL;YAChBljB,KAAKilB,OAAOjlB,MAAKgiB,EAASkB;;WAE3BM,IAAM;QAGT,IAAIzgB,EAAEmiB;UACJniB,EAAEmiB;;;;IAMRllB,MAAKmlB,IAAiBjC;MACpBV,EAAOU,KAAyB,MAAhBT,EAAKS,KAAe5E,EAAKE,QAAQ;;IAGnDxe,MAAKolB,IAAa,CAACC,GAAQnC;MACzB,IAAIT,EAAKS,IAAQ;QACf,IAAMM,IAAMf,EAAKS;QACjB,IAAM1X,IAAQgX,EAAOU;QACrBmC,EAAO7B,MAAMA;QACb6B,EAAO7Z,QAAQA;QACf6Z,EAAO7G,MAAM8G,KAAaC;QAE1BF,EAAOG,eAAehC,KADV6B,EAAO7G,MAAMhT;;;IAO7B,IAAI8Z,IAAY;IAChB,IAAMC,SAASA;MACb,IAAMnF,IAAI9B,EAAKE;MACf,IAAIxe,KAAKyjB,gBAAgB,GAAG;QAC1B6B,IAAYlF;QACZ,IAAMrd,IAAIiiB,WACR,MAAOM,IAAY,GACnBtlB,KAAKyjB;QAIP,IAAI1gB,EAAEmiB;UACJniB,EAAEmiB;;;MAIN,OAAO9E;;IAGTpgB,KAAK4kB,kBAAkBC;MACrB,IAAM3B,IAAQljB,MAAK+hB,EAAQ0D,IAAIZ;MAC/B,SAAcra,MAAV0Y;QACF,OAAO;;MAET,IAAMM,IAAMf,EAAKS;MACjB,IAAM1X,IAAQgX,EAAOU;MACrB,IAAY,MAARM,KAAuB,MAAVhY;QACf,OAAOsZ;;MAGT,OAAOtB,MADM8B,KAAaC,YAAY/Z;;IAIxCxL,MAAKujB,IAAWL,KAEI,MAAhBT,EAAKS,MACa,MAAlBV,EAAOU,OACNoC,KAAaC,YAAY/C,EAAOU,KAAST,EAAKS;AAGrD;EAGAiC,GAAyCO;EACzCN,GACEO;EACFZ,GAMYa;EAGZrC,GAAsCsC,OAAM;EAE5C,EAAApB;IACE,IAAMlC,IAAQ,IAAI1B,UAAU7gB,MAAKugB;IACjCvgB,MAAK8hB,IAAkB;IACvB9hB,MAAKuiB,IAASA;IACdviB,MAAK8lB,IAAkB5C;MACrBljB,MAAK8hB,KAAmBS,EAAMW;MAC9BX,EAAMW,KAAS;;IAEjBljB,MAAK+lB,IAAe,CAAC9C,GAAG+C,GAAGlF,GAAMmD;MAG/B,IAAIjkB,MAAK+iB,EAAmBiD;QAC1B,OAAO;;MAET,KAAK7F,SAASW;QACZ,IAAImD,GAAiB;UACnB,IAA+B,qBAApBA;YACT,MAAM,IAAI7Y,UAAU;;UAEtB0V,IAAOmD,EAAgB+B,GAAG/C;UAC1B,KAAK9C,SAASW;YACZ,MAAM,IAAI1V,UACR;;;UAIJ,MAAM,IAAIA,UACR;;;MAMN,OAAO0V;;IAET9gB,MAAKimB,IAAe,CAClB/C,GACApC,GACAuE;MAEA9C,EAAMW,KAASpC;MACf,IAAI9gB,MAAK0hB,GAAU;QACjB,IAAMA,IAAU1hB,MAAK0hB,IAAWa,EAAMW;QACtC,OAAOljB,MAAK8hB,IAAkBJ;UAC5B1hB,MAAKkmB,GAAO;;;MAGhBlmB,MAAK8hB,KAAmBS,EAAMW;MAC9B,IAAImC,GAAQ;QACVA,EAAOc,YAAYrF;QACnBuE,EAAOe,sBAAsBpmB,MAAK8hB;;;AAGxC;EAEAgE,GAA0CO;EAC1CJ,GAIYK,CAACD,GAAIE,GAAIC;EACrBT,GAKqBU,CACnBC,GACAC,GACA7F,GACAmD;IAEA,IAAInD,KAAQmD;MACV,MAAM,IAAI7Y,UACR;;IAGJ,OAAO;;EAGT,IAACiY,EAASQ,YAAEA,IAAa7jB,KAAK6jB,cAAe;IAC3C,IAAI7jB,MAAK8gB;MACP,KAAK,IAAI1W,IAAIpK,MAAKoiB,GAAO,KAAQ;QAC/B,KAAKpiB,MAAK4mB,EAAcxc;UACtB;;QAEF,IAAIyZ,MAAe7jB,MAAKujB,EAASnZ;gBACzBA;;QAER,IAAIA,MAAMpK,MAAKmiB;UACb;;UAEA/X,IAAIpK,MAAKkiB,EAAM9X;;;;AAIvB;EAEA,IAACkZ,EAAUO,YAAEA,IAAa7jB,KAAK6jB,cAAe;IAC5C,IAAI7jB,MAAK8gB;MACP,KAAK,IAAI1W,IAAIpK,MAAKmiB,GAAO,KAAQ;QAC/B,KAAKniB,MAAK4mB,EAAcxc;UACtB;;QAEF,IAAIyZ,MAAe7jB,MAAKujB,EAASnZ;gBACzBA;;QAER,IAAIA,MAAMpK,MAAKoiB;UACb;;UAEAhY,IAAIpK,MAAKW,EAAMyJ;;;;AAIvB;EAEA,EAAAwc,CAAc1D;IACZ,YACY1Y,MAAV0Y,KACAljB,MAAK+hB,EAAQ0D,IAAIzlB,MAAKgiB,EAASkB,QAAiBA;AAEpD;EAMA,SAACxS;IACC,KAAK,IAAMtG,KAAKpK,MAAKqjB;MACnB,SACuB7Y,MAArBxK,MAAKiiB,EAAS7X,WACOI,MAArBxK,MAAKgiB,EAAS5X,OACbpK,MAAK+iB,EAAmB/iB,MAAKiiB,EAAS7X;cAEjC,EAACpK,MAAKgiB,EAAS5X,IAAIpK,MAAKiiB,EAAS7X;;;AAG7C;EAQA,UAACyc;IACC,KAAK,IAAMzc,KAAKpK,MAAKsjB;MACnB,SACuB9Y,MAArBxK,MAAKiiB,EAAS7X,WACOI,MAArBxK,MAAKgiB,EAAS5X,OACbpK,MAAK+iB,EAAmB/iB,MAAKiiB,EAAS7X;cAEjC,EAACpK,MAAKgiB,EAAS5X,IAAIpK,MAAKiiB,EAAS7X;;;AAG7C;EAMA,MAACD;IACC,KAAK,IAAMC,KAAKpK,MAAKqjB,KAAY;MAC/B,IAAMJ,IAAIjjB,MAAKgiB,EAAS5X;MACxB,SACQI,MAANyY,MACCjjB,MAAK+iB,EAAmB/iB,MAAKiiB,EAAS7X;cAEjC6Y;;;AAGZ;EAQA,OAAC6D;IACC,KAAK,IAAM1c,KAAKpK,MAAKsjB,KAAa;MAChC,IAAML,IAAIjjB,MAAKgiB,EAAS5X;MACxB,SACQI,MAANyY,MACCjjB,MAAK+iB,EAAmB/iB,MAAKiiB,EAAS7X;cAEjC6Y;;;AAGZ;EAMA,QAAC8D;IACC,KAAK,IAAM3c,KAAKpK,MAAKqjB,KAAY;MAE/B,SACQ7Y,MAFExK,MAAKiiB,EAAS7X,OAGrBpK,MAAK+iB,EAAmB/iB,MAAKiiB,EAAS7X;cAEjCpK,MAAKiiB,EAAS7X;;;AAG1B;EAQA,SAAC4c;IACC,KAAK,IAAM5c,KAAKpK,MAAKsjB,KAAa;MAEhC,SACQ9Y,MAFExK,MAAKiiB,EAAS7X,OAGrBpK,MAAK+iB,EAAmB/iB,MAAKiiB,EAAS7X;cAEjCpK,MAAKiiB,EAAS7X;;;AAG1B;EAMA,CAAC6c,OAAOC;IACN,OAAOlnB,KAAK0Q;AACd;EAMA2C,IAAAA,CACE2L,GACAmI,IAA4C;IAE5C,KAAK,IAAM/c,KAAKpK,MAAKqjB,KAAY;MAC/B,IAAM2C,IAAIhmB,MAAKiiB,EAAS7X;MACxB,IAAMjH,IAAQnD,MAAK+iB,EAAmBiD,KAClCA,EAAEoB,uBACFpB;MACJ,SAAcxb,MAAVrH;QAAqB;;MACzB,IAAI6b,EAAG7b,GAAOnD,MAAKgiB,EAAS5X,IAASpK;QACnC,OAAOA,KAAKylB,IAAIzlB,MAAKgiB,EAAS5X,IAAS+c;;;AAG7C;EAQApL,OAAAA,CACEiD,GACAqI,IAAarnB;IAEb,KAAK,IAAMoK,KAAKpK,MAAKqjB,KAAY;MAC/B,IAAM2C,IAAIhmB,MAAKiiB,EAAS7X;MACxB,IAAMjH,IAAQnD,MAAK+iB,EAAmBiD,KAClCA,EAAEoB,uBACFpB;MACJ,SAAcxb,MAAVrH;QAAqB;;MACzB6b,EAAGnU,KAAKwc,GAAOlkB,GAAOnD,MAAKgiB,EAAS5X,IAASpK;;AAEjD;EAMAsnB,QAAAA,CACEtI,GACAqI,IAAarnB;IAEb,KAAK,IAAMoK,KAAKpK,MAAKsjB,KAAa;MAChC,IAAM0C,IAAIhmB,MAAKiiB,EAAS7X;MACxB,IAAMjH,IAAQnD,MAAK+iB,EAAmBiD,KAClCA,EAAEoB,uBACFpB;MACJ,SAAcxb,MAAVrH;QAAqB;;MACzB6b,EAAGnU,KAAKwc,GAAOlkB,GAAOnD,MAAKgiB,EAAS5X,IAASpK;;AAEjD;EAMAunB,UAAAA;IACE,IAAIC,KAAU;IACd,KAAK,IAAMpd,KAAKpK,MAAKsjB,EAAU;MAAEO,aAAY;;MAC3C,IAAI7jB,MAAKujB,EAASnZ,IAAI;QACpBpK,KAAKilB,OAAOjlB,MAAKgiB,EAAS5X;QAC1Bod,KAAU;;;IAGd,OAAOA;AACT;EAMAC,IAAAA;IACE,IAAMC,IAAgC;IACtC,KAAK,IAAMtd,KAAKpK,MAAKqjB,EAAS;MAAEQ,aAAY;QAAS;MACnD,IAAMgB,IAAM7kB,MAAKgiB,EAAS5X;MAC1B,IAAM4b,IAAIhmB,MAAKiiB,EAAS7X;MACxB,IAAMjH,IAAuBnD,MAAK+iB,EAAmBiD,KACjDA,EAAEoB,uBACFpB;MACJ,SAAcxb,MAAVrH,UAA+BqH,MAARqa;QAAmB;;MAC9C,IAAM8C,IAA2B;QAAExkB;;MACnC,IAAInD,MAAKyiB,KAASziB,MAAKwiB,GAAS;QAC9BmF,EAAMnE,MAAMxjB,MAAKyiB,EAAMrY;QAGvB,IAAMwd,IAAMtJ,EAAKE,QAAQxe,MAAKwiB,EAAQpY;QACtCud,EAAMnc,QAAQ1B,KAAKC,MAAM0U,KAAKD,QAAQoJ;;MAExC,IAAI5nB,MAAKuiB;QACPoF,EAAM7G,OAAO9gB,MAAKuiB,EAAOnY;;MAE3Bsd,EAAIG,QAAQ,EAAChD,GAAK8C;;IAEpB,OAAOD;AACT;EAOAI,IAAAA,CAAKJ;IACH1nB,KAAK+nB;IACL,KAAK,KAAOlD,GAAK8C,MAAUD,GAAK;MAC9B,IAAIC,EAAMnc,OAAO;QAOf,IAAMoc,IAAMnJ,KAAKD,QAAQmJ,EAAMnc;QAC/Bmc,EAAMnc,QAAQ8S,EAAKE,QAAQoJ;;MAE7B5nB,KAAKgoB,IAAInD,GAAK8C,EAAMxkB,OAAOwkB;;AAE/B;EAQAK,GAAAA,CACE/E,GACA+C,GACAiC,IAA4C,CAAA;IAE5C,SAAUzd,MAANwb,GAAiB;MACnBhmB,KAAKilB,OAAOhC;MACZ,OAAOjjB;;IAET,KAAMwjB,KACJA,IAAMxjB,KAAKwjB,KAAGhY,OACdA,GAAKsY,gBACLA,IAAiB9jB,KAAK8jB,gBAAcG,iBACpCA,IAAkBjkB,KAAKikB,iBAAeoB,QACtCA,KACE4C;IACJ,KAAIlE,aAAEA,IAAc/jB,KAAK+jB,eAAgBkE;IAEzC,IAAMnH,IAAO9gB,MAAK+lB,EAChB9C,GACA+C,GACAiC,EAAWnH,QAAQ,GACnBmD;IAIF,IAAIjkB,KAAKgkB,gBAAgBlD,IAAO9gB,KAAKgkB,cAAc;MACjD,IAAIqB,GAAQ;QACVA,EAAO2C,MAAM;QACb3C,EAAO6C,wBAAuB;;MAGhCloB,KAAKilB,OAAOhC;MACZ,OAAOjjB;;IAET,IAAIkjB,IAAuB,MAAfljB,MAAK8gB,SAActW,IAAYxK,MAAK+hB,EAAQ0D,IAAIxC;IAC5D,SAAczY,MAAV0Y,GAAqB;MAEvBA,IACiB,MAAfljB,MAAK8gB,IACD9gB,MAAKoiB,IACiB,MAAtBpiB,MAAKqiB,EAAM9hB,SACXP,MAAKqiB,EAAMb,QACXxhB,MAAK8gB,MAAU9gB,MAAKugB,IACpBvgB,MAAKkmB,GAAO,KACZlmB,MAAK8gB;MAEX9gB,MAAKgiB,EAASkB,KAASD;MACvBjjB,MAAKiiB,EAASiB,KAAS8C;MACvBhmB,MAAK+hB,EAAQiG,IAAI/E,GAAGC;MACpBljB,MAAKW,EAAMX,MAAKoiB,KAASc;MACzBljB,MAAKkiB,EAAMgB,KAASljB,MAAKoiB;MACzBpiB,MAAKoiB,IAAQc;MACbljB,MAAK8gB;MACL9gB,MAAKimB,EAAa/C,GAAOpC,GAAMuE;MAC/B,IAAIA;QAAQA,EAAO2C,MAAM;;MACzBjE,KAAc;WACT;MAEL/jB,MAAKojB,EAAYF;MACjB,IAAMiF,IAASnoB,MAAKiiB,EAASiB;MAC7B,IAAI8C,MAAMmC,GAAQ;QAChB,IAAInoB,MAAK2iB,KAAmB3iB,MAAK+iB,EAAmBoF,IAAS;UAC3DA,EAAOC,kBAAkBvI,MAAM,IAAIrS,MAAM;UACzC,KAAQ4Z,sBAAsB9F,KAAM6G;UACpC,SAAU3d,MAAN8W,MAAoBwC,GAAgB;YACtC,IAAI9jB,MAAK0iB;cACP1iB,MAAK2hB,IAAWL,GAAQ2B,GAAG;;YAE7B,IAAIjjB,MAAK4iB;cACP5iB,MAAKsiB,GAAWxS,KAAK,EAACwR,GAAQ2B,GAAG;;;eAGhC,KAAKa,GAAgB;UAC1B,IAAI9jB,MAAK0iB;YACP1iB,MAAK2hB,IAAWwG,GAAalF,GAAG;;UAElC,IAAIjjB,MAAK4iB;YACP5iB,MAAKsiB,GAAWxS,KAAK,EAACqY,GAAalF,GAAG;;;QAG1CjjB,MAAK8lB,EAAgB5C;QACrBljB,MAAKimB,EAAa/C,GAAOpC,GAAMuE;QAC/BrlB,MAAKiiB,EAASiB,KAAS8C;QACvB,IAAIX,GAAQ;UACVA,EAAO2C,MAAM;UACb,IAAMK,IACJF,KAAUnoB,MAAK+iB,EAAmBoF,KAC9BA,EAAOf,uBACPe;UACN,SAAiB3d,MAAb6d;YAAwBhD,EAAOgD,WAAWA;;;AAEjD,aAAM,IAAIhD;QACTA,EAAO2C,MAAM;;;IAGjB,IAAY,MAARxE,MAAcxjB,MAAKyiB;MACrBziB,MAAK0kB;;IAEP,IAAI1kB,MAAKyiB,GAAO;MACd,KAAKsB;QACH/jB,MAAK+kB,EAAY7B,GAAOM,GAAKhY;;MAE/B,IAAI6Z;QAAQrlB,MAAKolB,EAAWC,GAAQnC;;;IAEtC,KAAKY,KAAkB9jB,MAAK4iB,KAAoB5iB,MAAKsiB,GAAW;MAC9D,IAAMgG,IAAKtoB,MAAKsiB;MAChB,IAAIiG;MACJ,OAAQA,IAAOD,GAAInM;QACjBnc,MAAK4hB,OAAmB2G;;;IAG5B,OAAOvoB;AACT;EAMAwhB,GAAAA;IACE;MACE,OAAOxhB,MAAK8gB,GAAO;QACjB,IAAM0H,IAAMxoB,MAAKiiB,EAASjiB,MAAKmiB;QAC/BniB,MAAKkmB,GAAO;QACZ,IAAIlmB,MAAK+iB,EAAmByF;UAC1B,IAAIA,EAAIpB;YACN,OAAOoB,EAAIpB;;eAER,SAAY5c,MAARge;UACT,OAAOA;;;MAGH;MACR,IAAIxoB,MAAK4iB,KAAoB5iB,MAAKsiB,GAAW;QAC3C,IAAMgG,IAAKtoB,MAAKsiB;QAChB,IAAIiG;QACJ,OAAQA,IAAOD,GAAInM;UACjBnc,MAAK4hB,OAAmB2G;;;;AAIhC;EAEA,EAAArC,CAAO7D;IACL,IAAMF,IAAOniB,MAAKmiB;IAClB,IAAMc,IAAIjjB,MAAKgiB,EAASG;IACxB,IAAM6D,IAAIhmB,MAAKiiB,EAASE;IACxB,IAAIniB,MAAK2iB,KAAmB3iB,MAAK+iB,EAAmBiD;MAClDA,EAAEoC,kBAAkBvI,MAAM,IAAIrS,MAAM;WAC/B,IAAIxN,MAAK0iB,KAAe1iB,MAAK4iB,GAAkB;MACpD,IAAI5iB,MAAK0iB;QACP1iB,MAAK2hB,IAAWqE,GAAG/C,GAAG;;MAExB,IAAIjjB,MAAK4iB;QACP5iB,MAAKsiB,GAAWxS,KAAK,EAACkW,GAAG/C,GAAG;;;IAGhCjjB,MAAK8lB,EAAgB3D;IAErB,IAAIE,GAAM;MACRriB,MAAKgiB,EAASG,UAAQ3X;MACtBxK,MAAKiiB,EAASE,UAAQ3X;MACtBxK,MAAKqiB,EAAMvS,KAAKqS;;IAElB,IAAmB,MAAfniB,MAAK8gB,GAAa;MACpB9gB,MAAKmiB,IAAQniB,MAAKoiB,IAAQ;MAC1BpiB,MAAKqiB,EAAM9hB,SAAS;;MAEpBP,MAAKmiB,IAAQniB,MAAKW,EAAMwhB;;IAE1BniB,MAAK+hB,EAAQkD,OAAOhC;IACpBjjB,MAAK8gB;IACL,OAAOqB;AACT;EAUAtQ,GAAAA,CAAIoR,GAAMwF,IAA4C;IACpD,KAAM7E,gBAAEA,IAAiB5jB,KAAK4jB,gBAAcyB,QAAEA,KAC5CoD;IACF,IAAMvF,IAAQljB,MAAK+hB,EAAQ0D,IAAIxC;IAC/B,SAAczY,MAAV0Y,GAAqB;MACvB,IAAM8C,IAAIhmB,MAAKiiB,EAASiB;MACxB,IACEljB,MAAK+iB,EAAmBiD,WACGxb,MAA3Bwb,EAAEoB;QAEF,QAAO;;MAET,KAAKpnB,MAAKujB,EAASL,IAAQ;QACzB,IAAIU;UACF5jB,MAAKmlB,EAAejC;;QAEtB,IAAImC,GAAQ;UACVA,EAAOxT,MAAM;UACb7R,MAAKolB,EAAWC,GAAQnC;;QAE1B,QAAO;AACR,aAAM,IAAImC,GAAQ;QACjBA,EAAOxT,MAAM;QACb7R,MAAKolB,EAAWC,GAAQnC;;AAE3B,WAAM,IAAImC;MACTA,EAAOxT,MAAM;;IAEf,QAAO;AACT;EASApR,IAAAA,CAAKwiB,GAAMyF,IAA8C;IACvD,KAAM7E,YAAEA,IAAa7jB,KAAK6jB,cAAe6E;IACzC,IAAMxF,IAAQljB,MAAK+hB,EAAQ0D,IAAIxC;IAC/B,SACYzY,MAAV0Y,MACCW,MAAe7jB,MAAKujB,EAASL,KAC9B;MACA,IAAM8C,IAAIhmB,MAAKiiB,EAASiB;MAExB,OAAOljB,MAAK+iB,EAAmBiD,KAAKA,EAAEoB,uBAAuBpB;;AAEjE;EAEA,EAAAhD,CACEC,GACAC,GACAta,GACAua;IAEA,IAAM6C,SAAcxb,MAAV0Y,SAAsB1Y,IAAYxK,MAAKiiB,EAASiB;IAC1D,IAAIljB,MAAK+iB,EAAmBiD;MAC1B,OAAOA;;IAGT,IAAM2C,IAAK,IAAIzJ;IACf,KAAMU,QAAEA,KAAWhX;IAEnBgX,GAAQH,iBAAiB,SAAS,MAAMkJ,EAAG9I,MAAMD,EAAOE,SAAS;MAC/DF,QAAQ+I,EAAG/I;;IAGb,IAAMgJ,IAAY;MAChBhJ,QAAQ+I,EAAG/I;MACXhX;MACAua;;IAGF,IAAM0F,KAAKA,CACT7C,GACA8C,KAAc;MAEd,KAAMtJ,SAAEA,KAAYmJ,EAAG/I;MACvB,IAAMmJ,IAAcngB,EAAQ0b,yBAA0B9Z,MAANwb;MAChD,IAAIpd,EAAQyc;QACV,IAAI7F,MAAYsJ,GAAa;UAC3BlgB,EAAQyc,OAAO2D,gBAAe;UAC9BpgB,EAAQyc,OAAO4D,aAAaN,EAAG/I,OAAOE;UACtC,IAAIiJ;YAAangB,EAAQyc,OAAO6D,qBAAoB;;;UAEpDtgB,EAAQyc,OAAO8D,iBAAgB;;;MAGnC,IAAI3J,MAAYuJ,MAAgBD;QAC9B,OAAOM,UAAUT,EAAG/I,OAAOE;;MAI7B,IAAI9f,MAAKiiB,EAASiB,OAAoBhgB;QACpC,SAAUsH,MAANwb;UACF,IAHO9iB,EAGAkkB;YACLpnB,MAAKiiB,EAASiB,KAJThgB,EAI8BkkB;;YAEnCpnB,KAAKilB,OAAOhC;;eAET;UACL,IAAIra,EAAQyc;YAAQzc,EAAQyc,OAAOgE,gBAAe;;UAClDrpB,KAAKgoB,IAAI/E,GAAG+C,GAAG4C,EAAUhgB;;;MAG7B,OAAOod;;IAWT,IAAMoD,YAAaE;MACjB,KAAM9J,SAAEA,KAAYmJ,EAAG/I;MACvB,IAAM2J,IACJ/J,KAAW5W,EAAQyb;MACrB,IAAMR,IACJ0F,KAAqB3gB,EAAQwb;MAE/B,IAAMoF,IAAKtmB;MACX,IAAIlD,MAAKiiB,EAASiB,OAAoBhgB,GAAG;QAIvC,MANe2gB,KAAcjb,EAAQsb,kCAKgB1Z,MAA5Bgf,EAAGpC;UAE1BpnB,KAAKilB,OAAOhC;eACP,KAAKsG;UAKVvpB,MAAKiiB,EAASiB,KAAkBsG,EAAGpC;;;MAGvC,IAAIvD,GAAY;QACd,IAAIjb,EAAQyc,eAAsC7a,MAA5Bgf,EAAGpC;UACvBxe,EAAQyc,OAAOoE,iBAAgB;;QAEjC,OAAOD,EAAGpC;AACX,aAAM,IAAIoC,EAAGE,eAAeF;QAC3B,MAAMF;;;IA6BV,IAAI1gB,EAAQyc;MAAQzc,EAAQyc,OAAOsE,mBAAkB;;IACrD,IAAMzmB,IAAI,IAAI0mB,QA1BAC,CACZC,GACAC;MAEA,IAAMC,IAAMhqB,MAAK6hB,IAAeoB,GAAG+C,GAAG4C;MACtC,IAAIoB,KAAOA,aAAeJ;QACxBI,EAAIC,KAAKjE,KAAK8D,OAAUtf,MAANwb,SAAkBxb,IAAYwb,IAAI+D;;MAKtDpB,EAAG/I,OAAOH,iBAAiB,SAAS;QAClC,KACG7W,EAAQ0b,oBACT1b,EAAQyb,wBACR;UACAyF,OAAItf;UAEJ,IAAI5B,EAAQyb;YACVyF,IAAM9D,KAAK6C,GAAG7C,IAAG;;;;OAOIiE,KAAKpB,IAlEtBS;MACV,IAAI1gB,EAAQyc,QAAQ;QAClBzc,EAAQyc,OAAO6E,iBAAgB;QAC/BthB,EAAQyc,OAAO4D,aAAaK;;MAE9B,OAAOF,UAAUE;;IA8DnB,IAAME,IAAyBtf,OAAOK,OAAOrH,GAAG;MAC9CklB,mBAAmBO;MACnBvB,sBAAsBpB;MACtB0D,iBAAYlf;;IAGd,SAAcA,MAAV0Y,GAAqB;MAEvBljB,KAAKgoB,IAAI/E,GAAGuG,GAAI;WAAKZ,EAAUhgB;QAASyc,aAAQ7a;;MAChD0Y,IAAQljB,MAAK+hB,EAAQ0D,IAAIxC;;MAEzBjjB,MAAKiiB,EAASiB,KAASsG;;IAEzB,OAAOA;AACT;EAEA,EAAAzG,CAAmB7f;IACjB,KAAKlD,MAAK2iB;MAAiB,QAAO;;IAClC,IAAMwH,IAAIjnB;IACV,SACIinB,KACFA,aAAaP,WACbO,EAAEC,eAAe,2BACjBD,EAAE/B,6BAA6BlJ;AAEnC;EAwCA,WAAMmL,CACJpH,GACAqH,IAAgD;IAEhD,KAAMzG,YAEJA,IAAa7jB,KAAK6jB,YAAUF,gBAC5BA,IAAiB3jB,KAAK2jB,gBAAcQ,oBACpCA,IAAqBnkB,KAAKmkB,oBAAkBX,KAE5CA,IAAMxjB,KAAKwjB,KAAGM,gBACdA,IAAiB9jB,KAAK8jB,gBAAchD,MACpCA,IAAO,GAACmD,iBACRA,IAAkBjkB,KAAKikB,iBAAeF,aACtCA,IAAc/jB,KAAK+jB,aAAWG,0BAE9BA,IAA2BlkB,KAAKkkB,0BAAwBE,4BACxDA,IAA6BpkB,KAAKokB,4BAA0BE,kBAC5DA,IAAmBtkB,KAAKskB,kBAAgBD,wBACxCA,IAAyBrkB,KAAKqkB,wBAAsBlB,SACpDA,GAAOoH,cACPA,KAAe,GAAKlF,QACpBA,GAAMzF,QACNA,KACE0K;IAEJ,KAAKtqB,MAAK2iB,GAAiB;MACzB,IAAI0C;QAAQA,EAAOgF,QAAQ;;MAC3B,OAAOrqB,KAAKylB,IAAIxC,GAAG;QACjBY;QACAF;QACAQ;QACAkB;;;IAIJ,IAAMzc,IAAU;MACdib;MACAF;MACAQ;MACAX;MACAM;MACAhD;MACAmD;MACAF;MACAG;MACAE;MACAC;MACAC;MACAe;MACAzF;;IAGF,IAAIsD,IAAQljB,MAAK+hB,EAAQ0D,IAAIxC;IAC7B,SAAczY,MAAV0Y,GAAqB;MACvB,IAAImC;QAAQA,EAAOgF,QAAQ;;MAC3B,IAAMnnB,IAAIlD,MAAKgjB,EAAiBC,GAAGC,GAAOta,GAASua;MACnD,OAAQjgB,EAAEwmB,aAAaxmB;WAClB;MAEL,IAAM8iB,IAAIhmB,MAAKiiB,EAASiB;MACxB,IAAIljB,MAAK+iB,EAAmBiD,IAAI;QAC9B,IAAMwE,IACJ3G,UAAyCrZ,MAA3Bwb,EAAEoB;QAClB,IAAI/B,GAAQ;UACVA,EAAOgF,QAAQ;UACf,IAAIG;YAAOnF,EAAOoE,iBAAgB;;;QAEpC,OAAOe,IAAQxE,EAAEoB,uBAAwBpB,EAAE0D,aAAa1D;;MAK1D,IAAMzC,IAAUvjB,MAAKujB,EAASL;MAC9B,KAAKqH,MAAiBhH,GAAS;QAC7B,IAAI8B;UAAQA,EAAOgF,QAAQ;;QAC3BrqB,MAAKojB,EAAYF;QACjB,IAAIS;UACF3jB,MAAKmlB,EAAejC;;QAEtB,IAAImC;UAAQrlB,MAAKolB,EAAWC,GAAQnC;;QACpC,OAAO8C;;MAKT,IAAM9iB,IAAIlD,MAAKgjB,EAAiBC,GAAGC,GAAOta,GAASua;MAEnD,IAAMsH,SADsCjgB,MAA3BtH,EAAEkkB,wBACUvD;MAC7B,IAAIwB,GAAQ;QACVA,EAAOgF,QAAQ9G,IAAU,UAAU;QACnC,IAAIkH,KAAYlH;UAAS8B,EAAOoE,iBAAgB;;;MAElD,OAAOgB,IAAWvnB,EAAEkkB,uBAAwBlkB,EAAEwmB,aAAaxmB;;AAE/D;EAQAuiB,GAAAA,CAAIxC,GAAMkE,IAA4C;IACpD,KAAMtD,YACJA,IAAa7jB,KAAK6jB,YAAUF,gBAC5BA,IAAiB3jB,KAAK2jB,gBAAcQ,oBACpCA,IAAqBnkB,KAAKmkB,oBAAkBkB,QAC5CA,KACE8B;IACJ,IAAMjE,IAAQljB,MAAK+hB,EAAQ0D,IAAIxC;IAC/B,SAAczY,MAAV0Y,GAAqB;MACvB,IAAM/f,IAAQnD,MAAKiiB,EAASiB;MAC5B,IAAMwH,IAAW1qB,MAAK+iB,EAAmB5f;MACzC,IAAIkiB;QAAQrlB,MAAKolB,EAAWC,GAAQnC;;MACpC,IAAIljB,MAAKujB,EAASL,IAAQ;QACxB,IAAImC;UAAQA,EAAOI,MAAM;;QAEzB,KAAKiF,GAAU;UACb,KAAKvG;YACHnkB,KAAKilB,OAAOhC;;UAEd,IAAIoC,KAAUxB;YAAYwB,EAAOoE,iBAAgB;;UACjD,OAAO5F,IAAa1gB,SAAQqH;eACvB;UACL,IACE6a,KACAxB,UAC+BrZ,MAA/BrH,EAAMikB;YAEN/B,EAAOoE,iBAAgB;;UAEzB,OAAO5F,IAAa1gB,EAAMikB,4BAAuB5c;;aAE9C;QACL,IAAI6a;UAAQA,EAAOI,MAAM;;QAMzB,IAAIiF;UACF,OAAOvnB,EAAMikB;;QAEfpnB,MAAKojB,EAAYF;QACjB,IAAIS;UACF3jB,MAAKmlB,EAAejC;;QAEtB,OAAO/f;;AAEV,WAAM,IAAIkiB;MACTA,EAAOI,MAAM;;AAEjB;EAEA,EAAAkF,CAASznB,GAAUkd;IACjBpgB,MAAKkiB,EAAM9B,KAAKld;IAChBlD,MAAKW,EAAMuC,KAAKkd;AAClB;EAEA,EAAAgD,CAAYF;IASV,IAAIA,MAAUljB,MAAKoiB,GAAO;MACxB,IAAIc,MAAUljB,MAAKmiB;QACjBniB,MAAKmiB,IAAQniB,MAAKW,EAAMuiB;;QAExBljB,MAAK2qB,EACH3qB,MAAKkiB,EAAMgB,IACXljB,MAAKW,EAAMuiB;;MAGfljB,MAAK2qB,EAAS3qB,MAAKoiB,GAAOc;MAC1BljB,MAAKoiB,IAAQc;;AAEjB;EAMA+B,OAAOhC;IACL,IAAIuE,KAAU;IACd,IAAmB,MAAfxnB,MAAK8gB,GAAa;MACpB,IAAMoC,IAAQljB,MAAK+hB,EAAQ0D,IAAIxC;MAC/B,SAAczY,MAAV0Y,GAAqB;QACvBsE,KAAU;QACV,IAAmB,MAAfxnB,MAAK8gB;UACP9gB,KAAK+nB;eACA;UACL/nB,MAAK8lB,EAAgB5C;UACrB,IAAM8C,IAAIhmB,MAAKiiB,EAASiB;UACxB,IAAIljB,MAAK+iB,EAAmBiD;YAC1BA,EAAEoC,kBAAkBvI,MAAM,IAAIrS,MAAM;iBAC/B,IAAIxN,MAAK0iB,KAAe1iB,MAAK4iB,GAAkB;YACpD,IAAI5iB,MAAK0iB;cACP1iB,MAAK2hB,IAAWqE,GAAQ/C,GAAG;;YAE7B,IAAIjjB,MAAK4iB;cACP5iB,MAAKsiB,GAAWxS,KAAK,EAACkW,GAAQ/C,GAAG;;;UAGrCjjB,MAAK+hB,EAAQkD,OAAOhC;UACpBjjB,MAAKgiB,EAASkB,UAAS1Y;UACvBxK,MAAKiiB,EAASiB,UAAS1Y;UACvB,IAAI0Y,MAAUljB,MAAKoiB;YACjBpiB,MAAKoiB,IAAQpiB,MAAKkiB,EAAMgB;iBACnB,IAAIA,MAAUljB,MAAKmiB;YACxBniB,MAAKmiB,IAAQniB,MAAKW,EAAMuiB;iBACnB;YACLljB,MAAKW,EAAMX,MAAKkiB,EAAMgB,MAAUljB,MAAKW,EAAMuiB;YAC3CljB,MAAKkiB,EAAMliB,MAAKW,EAAMuiB,MAAUljB,MAAKkiB,EAAMgB;;UAE7CljB,MAAK8gB;UACL9gB,MAAKqiB,EAAMvS,KAAKoT;;;;IAItB,IAAIljB,MAAK4iB,KAAoB5iB,MAAKsiB,GAAW/hB,QAAQ;MACnD,IAAM+nB,IAAKtoB,MAAKsiB;MAChB,IAAIiG;MACJ,OAAQA,IAAOD,GAAInM;QACjBnc,MAAK4hB,OAAmB2G;;;IAG5B,OAAOf;AACT;EAKAO,KAAAA;IACE,KAAK,IAAM7E,KAASljB,MAAKsjB,EAAU;MAAEO,aAAY;QAAS;MACxD,IAAMmC,IAAIhmB,MAAKiiB,EAASiB;MACxB,IAAIljB,MAAK+iB,EAAmBiD;QAC1BA,EAAEoC,kBAAkBvI,MAAM,IAAIrS,MAAM;aAC/B;QACL,IAAMyV,IAAIjjB,MAAKgiB,EAASkB;QACxB,IAAIljB,MAAK0iB;UACP1iB,MAAK2hB,IAAWqE,GAAQ/C,GAAQ;;QAElC,IAAIjjB,MAAK4iB;UACP5iB,MAAKsiB,GAAWxS,KAAK,EAACkW,GAAQ/C,GAAQ;;;;IAK5CjjB,MAAK+hB,EAAQgG;IACb/nB,MAAKiiB,EAASjB,UAAKxW;IACnBxK,MAAKgiB,EAAShB,UAAKxW;IACnB,IAAIxK,MAAKyiB,KAASziB,MAAKwiB,GAAS;MAC9BxiB,MAAKyiB,EAAMzB,KAAK;MAChBhhB,MAAKwiB,EAAQxB,KAAK;;IAEpB,IAAIhhB,MAAKuiB;MACPviB,MAAKuiB,EAAOvB,KAAK;;IAEnBhhB,MAAKmiB,IAAQ;IACbniB,MAAKoiB,IAAQ;IACbpiB,MAAKqiB,EAAM9hB,SAAS;IACpBP,MAAK8hB,IAAkB;IACvB9hB,MAAK8gB,IAAQ;IACb,IAAI9gB,MAAK4iB,KAAoB5iB,MAAKsiB,GAAW;MAC3C,IAAMgG,IAAKtoB,MAAKsiB;MAChB,IAAIiG;MACJ,OAAQA,IAAOD,GAAInM;QACjBnc,MAAK4hB,OAAmB2G;;;AAG9B;;;;;;;AC3wEF,IAAMqC,KAAa;EAClB,IAAI;EACJ,IAAI;EACJ,KAAK;EACL,KAAK;EACL,KAAK;EACL,MAAM;;;AAGP,IAAMC,KAAc;EACnB,IAAI;EACJ,IAAI;EACJ,KAAK;EACL,KAAK;EACL,KAAK;EACL,MAAM;;;AAsDPC,GAAAC,UAlDA,SAASC,MAAMC;EAEd,IAAIC,IAAOznB,OAAOonB,GAAY;EAC9B,IAAIM,KAAa;EAEjB,KAAK,IAAI/gB,IAAI,GAAGA,IAAI6gB,EAAO1qB,QAAQ6J,KAAK;IACvC,IAAIghB,IAAgBH,EAAO1oB,WAAW6H;IAGtC,IAAIghB,IAAgB,QAASD,GAAY;MAExCC,KADAH,IAASI,SAASC,mBAAmBL,KACd1oB,WAAW6H;MAClC+gB,KAAa;AAChB;IAEED,KAAQE;IACRF,MAASA,KAAQ,MAAMA,KAAQ,MAAMA,KAAQ,MAAMA,KAAQ,MAAMA,KAAQ;AAC3E;EAEC,OAAOA,MAAS;AACjB;;AA+BAJ,GAAAC,QAAAQ,SA7BA,SAASA,OAAON,IAAQnK,MAACA,IAAO,MAAM;EACrC,KAAK8J,GAAW9J;IACf,MAAM,IAAItT,MAAM;;EAGjB,IAAI0d,IAAOL,GAAY/J;EACvB,IAAM0K,IAAWZ,GAAW9J;EAG5B,IAAIqK,KAAa;EAEjB,KAAK,IAAI/gB,IAAI,GAAGA,IAAI6gB,EAAO1qB,QAAQ6J,KAAK;IACvC,IAAIghB,IAAgBH,EAAO1oB,WAAW6H;IAGtC,IAAIghB,IAAgB,QAASD,GAAY;MAExCC,KADAH,IAASI,SAASC,mBAAmBL,KACd1oB,WAAW6H;MAClC+gB,KAAa;AAChB;IAEED,KAAQO,OAAOL;IACfF,IAAOO,OAAOC,QAAQ5K,GAAMoK,IAAOM;AACrC;EAEC,OAAON;AACR;;;;AClEO,IAAMS,KAAoB;;AAEjC,IAAMC,qBAAsB9kB,KACnBA,EAAKoM,0BACRpM,EAAKsM,MAAMC,KAAKvM,KAAQA,EAAK0P,QAAQ/W,EAAGosB,UAAU3hB,WAAWpD,IAC7DA;;AAGN,IAAMglB,yBACJtgB;EAEA,IAAI2C,IAAgB3C;EACpB,IAAM6P,IAAO,IAAInK;EACjB,OAAO/C,EAAKuH,WAAW2F,EAAKxJ,IAAI1D,IAAO;IACrCkN,EAAKG,IAAIrN;IACT,IAAI1O,EAAGssB,QAAQ5d;MACb;WACK,IAAI1O,EAAGga,sBAAuBtL,IAAOA,EAAKuH;MAC/C,OAAOvH;;AAEX;;;AAGF,IAAM6d,6BAA6BA,CACjC7d,GACA8d,GACAC,GACA/c,GACAwJ,MAEOxK,EAAKwM,SAASvK,QAAQyK;EAC3B,IAAIpb,EAAG0sB,oBAAoBtR;IAAU,OAAO;;EAE5C,IAAMyB,IAAM,KAAI2P;EAChB,OAAOxsB,EAAGmS,aAAaiJ,EAAQzW,QAC3BgoB,WAAWvR,EAAQzW,MAAMkY,GAAK4P,GAAW/c,GAAQwJ,IAAM,KACvDlZ,EAAG0X,uBAAuB0D,EAAQzW,QAClCioB,sBAAsBxR,EAAQzW,MAAMkY,GAAK4P,GAAW/c,GAAQwJ,KAC5DqT,2BAA2BnR,EAAQzW,MAAMkY,GAAK4P,GAAW/c,GAAQwJ;;;AAIzE,IAAM0T,wBAAwBA,CAC5Ble,GACA8d,GACAC,GACA/c,GACAwJ;EAEA,IAAM2T,IAAU;EAAG,IAAAC,QAAAA;IAEjB,IAAI9sB,EAAG0X,uBAAuBqV,EAAQpoB,OAAO;MAC3C,IAAMkY,IAAM,KAAI2P;MAChB,IACEO,EAAQpV,iBACP6U,EAAYhc,SAASuc,EAAQpV,aAAayB,YAC3C;QACA,IAAM4T,IAAS,KAAInQ,GAAKkQ,EAAQpV,aAAayB,YAAW6T,KAAK;QAC7D,IAAIR,EAAU7Y,KAAKC,KAAKA,EAAEvR,WAAW0qB;UACnCnQ,EAAIxM,KAAK0c,EAAQpV,aAAayB;;AAElC;MACA,IAAM8T,IAAiBN,sBACrBG,EAAQpoB,MACRkY,GACA4P,GACA/c,GACAwJ;MAGF2T,EAAQxc,QAAQ6c;AACjB,WAAM,IAAIltB,EAAGmS,aAAa4a,EAAQpoB,OAAO;MACxC,IAAMkY,IAAM,KAAI2P;MAChB,IACEO,EAAQpV,iBACP6U,EAAYhc,SAASuc,EAAQpV,aAAayB,YAC3C;QACA,IAAM4T,IAAS,KAAInQ,GAAKkQ,EAAQpV,aAAayB,YAAW6T,KAAK;QAC7D,IAAIR,EAAU7Y,KAAKC,KAAKA,EAAEvR,WAAW0qB;UACnCnQ,EAAIxM,KAAK0c,EAAQpV,aAAayB;;AAElC,aAAO;QACL,IAAM4T,IAAS,KAAInQ,GAAKkQ,EAAQpoB,KAAKyU,YAAW6T,KAAK;QACrD,IAAIR,EAAU7Y,KAAKC,KAAKA,EAAEvR,WAAW0qB;UACnCnQ,EAAIxM,KAAK0c,EAAQpoB,KAAKyU;;AAE1B;MAEA,IAAM+T,IAAcR,WAClBI,EAAQpoB,MACRkY,GACA4P,GACA/c,GACAwJ,IACA;MAGF2T,EAAQxc,QAAQ8c;AAClB;;EAhDF,KAAK,IAAMJ,KAAWre,EAAKwM;IAAQ4R;;EAmDnC,OAAOD;;;AAGT,IAAMO,KAAe,IAAI3b,IAAI,EAC3B,OACA,UACA,WACA,UACA,SACA,QACA,QACA,WACA;;AAGF,IAAM4b,0BAA0BA,CAC9BC,GACAC,GACAd,GACA/c,GACAwJ;EAKA,IAFElZ,EAAG8S,2BAA2Bwa,EAAIxb,eAClCsb,GAAahb,IAAIkb,EAAIxb,WAAWnN,KAAK4R,OACxB;IAEb,IAAMiX,IAAkC,aADvBF,EAAIxb,WACKnN,KAAK4R;IAC/B,IAAIkX,IACFH,EAAI1b,UAAU;IAEhB,IAAMyY,IAAM;IACZ,IAAIrqB,EAAG2R,iBAAiB2b,EAAIrX,OAAOA,SAAS;MAC1C,IAAMyX,IAAeL,wBACnBC,EAAIrX,OAAOA,QACXsX,GACAd,GACA/c,GACAwJ;MAEF,IAAIwU,EAAa5sB;QACfupB,EAAIha,QAAQqd;;AAEhB;IAEA,IAAID,KAAQztB,EAAGmS,aAAasb,IAAO;MAIjC,IAAM/pB,IAAQqV,qBAAqB0U,GAFnBvU,EAAKW,gBAAgBC,aAAcC;MAGnD,IACErW,MACC1D,EAAG2tB,sBAAsBjqB,MACxB1D,EAAG6R,qBAAqBnO,MACxB1D,EAAG+R,gBAAgBrO;QAErB+pB,IAAO/pB;;AAEX;IAEA,IACE+pB,MACCztB,EAAG2tB,sBAAsBF,MACxBztB,EAAG6R,qBAAqB4b,MACxBztB,EAAG+R,gBAAgB0b,KACrB;MACA,IAAMG,IAAQH,EAAKI,WAAWL,IAAW,IAAI;MAC7C,IAAII,GAAO;QACT,IAAME,IAAenB,WACnBiB,EAAMjpB,MACN4oB,GACAd,GACA/c,GACAwJ,IACA;QAGF,IAAI4U,EAAahtB;UACfupB,EAAIha,QAAQyd;;AAEhB;AACF;IAEA,OAAOzD;AACT;EAEA,OAAO;;;AAGT,IAAMsC,aAAaA,CACjBje,GACA8d,GACAC,GACA/c,GACAwJ,GACA6U;EAEA,IAAI/tB,EAAG0X,uBAAuBhJ;IAC5B,OAAOke,sBAAsBle,GAAM8d,GAAaC,GAAW/c,GAAQwJ;SAC9D,IAAIlZ,EAAGguB,sBAAsBtf;IAClC,OAAO6d,2BACL7d,GACA8d,GACAC,GACA/c,GACAwJ;;EAIJ,IAAI2T,IAAoB;EAExB,IAAMoB,IAAa/U,EAAKW,gBAAgBqU,wBACtCxe,EAAO4K,UACP5L,EAAKyL;EAGP,KAAK8T;IAAY,OAAOpB;;EAiKxB,OA5JAA,IAAUoB,EAAWtd,QAAQ2c;IAE3B,IAAIA,EAAIhT,aAAa5K,EAAO4K;MAAU,OAAO;;IAG7C,IACE5L,EAAKyL,cAAcmT,EAAIzP,SAAS9R,SAChC2C,EAAK+M,YAAY6R,EAAIzP,SAAS9R,QAAQuhB,EAAIzP,SAAS/c;MAEnD,OAAO;;IAET,IAAIqtB,IAAW5S,SAAS7L,GAAQ4d,EAAIzP,SAAS9R;IAC7C,KAAKoiB;MAAU,OAAO;;IAEtB,IAAMZ,IAAY,KAAIf;IAOtB,IAkIC4B,GAlIDC,SAAAA;MAUE,KACGN,MACA/tB,EAAGsuB,kBAAkBH,MAAanuB,EAAG+R,gBAAgBoc,KACtD;QAGA,IAAMnB,IAASO,EAAUN,KAAK;QACyC,OAAA;UAAA1G,GAAlDkG,EAAUzc,OAAO6D,KAAKA,EAAEvR,WAAW0qB,IAAS;;AAElE,aAAM,IAAIhtB,EAAGga,sBAAsBmU;QAAW,OAAA;UAAA5H,GACtCoG,WACLwB,EAASxpB,MACT4oB,GACAd,GACA/c,GACAwJ,IACA;;aAEG,IACLlZ,EAAGmS,aAAagc,OACfZ,EAAU/c,SAAS2d,EAAS5X,OAC7B;QACA,IAAMyW,IAAS,KAAIO,GAAWY,EAAS5X,OAAM0W,KAAK;QAClD,IAAIR,EAAU7Y,KAAKC,KAAKA,EAAEvR,WAAW0qB,IAAS;UAC5CO,EAAUld,KAAK8d,EAAS5X;;QAM1B,IAAIvW,EAAG2R,iBAAiBwc,EAASlY,SAAS;UACD,OAAA;YAAAsQ,GAAhB4H,EAASlY,OACVrE,UAAUjB,QAAQ4d;cACtC,IAAIC,IAAQ,KAAIjB;cAChB,IAAIkB,IAAYF;cAAI,IAAAG,SAAAA;gBAGlB,IAAM1B,IAAS,KAAIwB,GAAOC,EAAU9pB,KAAK4R,OAAM0W,KAAK;gBACpD,IAAIR,EAAU7Y,KAAKC,KAAKA,EAAEvR,WAAW0qB,IAAS;kBAC5CwB,EAAMne,KAAKoe,EAAU9pB,KAAK4R;;gBAE5BkY,IAAYA,EAAU3c;;cALxB,OAAO9R,EAAG8S,2BAA2B2b;gBAAUC;;cAQ/C,IAAI1uB,EAAGmS,aAAasc,IAAY;gBAC9B,IAAMzB,IAAS,KAAIwB,GAAOC,EAAUrV,YAAW6T,KAAK;gBACpD,IAAIR,EAAU7Y,KAAKC,KAAKA,EAAEvR,WAAW0qB,IAAS;kBAC5CwB,EAAMne,KAAKoe,EAAUrV;;AAEzB;cAEA,IAAM4T,IAASwB,EAAMvB,KAAK;cAC1B,OAAOR,EAAUzc,OAAO6D,KAAKA,EAAEvR,WAAW0qB,IAAS;;;AAEvD;AACD,aAAM,IACLhtB,EAAG8S,2BAA2Bqb,MACP,SAAvBA,EAASxpB,KAAK4R,QACdvW,EAAG2R,iBAAiBwc,EAASlY;QAE7BkY,IAAWA,EAASlY;aACf,IACLjW,EAAG8S,2BAA2Bqb,MAC9Bf,GAAahb,IAAI+b,EAASxpB,KAAK4R,SAC/BvW,EAAG2R,iBAAiBwc,EAASlY,SAC7B;QACA,IAAM0Y,IAAiBR,EAASlY;QAChC,IAAMoU,IAAM;QACZ,IAAMuE,IACmB,WAAvBT,EAASxpB,KAAK4R,QAA0C,YAAvB4X,EAASxpB,KAAK4R;QACjD,IAAMsY,IAAiBxB,wBACrBsB,GACApB,GACAd,GACA/c,GACAwJ;QAEF,IAAI2V,EAAe/tB;UACjBupB,EAAIha,QAAQwe;;QAGd,IAAI7uB,EAAGga,sBAAsB2U,EAAe1Y,YAAY2Y,GAAe;UACrE,IAAME,IAASnC,WACbgC,EAAe1Y,OAAOtR,MACtB4oB,GACAd,GACA/c,GACAwJ,IACA;UAEFmR,EAAIha,QAAQye;AACd;QAAC,OAAA;UAAAvI,GAEM8D;;AACR,aAAM,IACLrqB,EAAG8S,2BAA2Bqb,OAC7BZ,EAAU/c,SAAS2d,EAASxpB,KAAK4R,OAClC;QACA,IAAMyW,IAAS,KAAIO,GAAWY,EAASxpB,KAAK4R,OAAM0W,KAAK;QACvD,IAAIR,EAAU7Y,KAAKC,KAAKA,EAAEvR,WAAW0qB;UACnCO,EAAUld,KAAK8d,EAASxpB,KAAK4R;;AAEjC,aAAO,IACLvW,EAAGkW,0BAA0BiY,MAC7BnuB,EAAG8T,gBAAgBqa,EAAShY,wBAC3BoX,EAAU/c,SAAS2d,EAAShY,mBAAmBI,OAChD;QACA,IAAMyW,IAAS,KAAIO,GAAWY,EAAShY,mBAAmBI,OAAM0W,KAC9D;QAEF,IAAIR,EAAU7Y,KAAKC,KAAKA,EAAEvR,WAAW0qB;UACnCO,EAAUld,KAAK8d,EAAShY,mBAAmBI;;AAE/C;MAEA,IAAIvW,EAAGyd,oBAAoB0Q,EAASlY;QAClCkY,IAAWA,EAASlY,OAAOA;;QAE3BkY,IAAWA,EAASlY;;AAEvB;IAjID,OACEjW,EAAGmS,aAAagc,MAChBnuB,EAAG8S,2BAA2Bqb,MAC9BnuB,EAAGkW,0BAA0BiY,MAC7BnuB,EAAGga,sBAAsBmU,MACzBnuB,EAAG6Y,mBAAmBsV,MACtBnuB,EAAGsuB,kBAAkBH,MACrBnuB,EAAG+R,gBAAgBoc;MAAS,IAAAC,IAAAC;QAAA,OAAAD,EAAA7H;;;IA4H9B,OAAOgH,EAAUN,KAAK;;;;ACpXnB,IAAM8B,4BAA4BA,CACvCrf,GACAwJ;EAKA,IAAM8V,IJmTD,SAASC,eACdzT;IAEA,OAAOA,EAAW0T,WAAWlf,OAAOhQ,EAAGmvB;AACzC,GIvTkBF,CAAevf;EAC/B,IAAM0D,IAAc8F,EAAKW,gBAAgBC,cAAcC;EAEvD,IAAMqV,IAGF,CAAA;EAEJ,KAAKhc;IAAa,OAAOgc;;EAEzB,IAAIJ,EAAQluB;IACVkuB,EAAQ1S,QAAQ+S;MACd,KAAKA,EAAIC;QAAc;;MAEvB,IAAID,EAAIC,aAAa3qB,MAAM;QACzB,IAAM2T,IAAc3B,2BAClB0Y,EAAIC,aAAa3qB,MACjByO;QAEF,IAAIkF,GAAa;UACf,IAAMkD,IAAalD,EAAY+B;UAC/B,IAAImB,EAAWlB,SAAS9J,SAAS;YAAiB;;UAGlD,KADuBgL;YACF;;UAQrB,IAAM+T,IANqBC,qBAHJhU,GAKrBpI,GACA8F,GAG+BS,IAAI8V,KAAYA,EAAS9qB,KAAKjB;UAC/D,IAAM0hB,IAAMiK,EAAIK,gBAAgBtW;UAChC,IAAIuW,IAAiBP,EAA2BhK;UAChD,IAAImK,EAAMzuB,UAAU6uB;YAClBA,EAAephB,YAAYohB,EAAephB,UAAUtD,OAAOskB;iBACtD,IAAIA,EAAMzuB,WAAW6uB;YAC1BP,EAA2BhK,KAAOuK,IAAiB;cACjD5jB,OAAOsjB,EAAIK,gBAAgBvV;cAC3BrZ,QAAQuuB,EAAIK,gBAAgBtW,UAAUtY;cACtCyN,WAAWghB;;;AAGjB;AACF;MAEA,IACEF,EAAIC,aAAaM,iBACjB5vB,EAAGkX,kBAAkBmY,EAAIC,aAAaM,gBACtC;QACA,IAAMtX,IAAc3B,2BAClB0Y,EAAIC,aAAaM,cAAcjrB,MAC/ByO;QAEF,IAAIkF,GAAa;UACf,IAAMkD,IAAalD,EAAY+B;UAC/B,IAAImB,EAAWlB,SAAS9J,SAAS;YAAiB;;UAGlD,KADuBgL;YACF;;UAOrB,IAAM+T,IALqBC,qBAHJhU,GAKrBpI,GACA8F,GAE+BS,IAAI8V,KAAYA,EAAS9qB,KAAKjB;UAC/D,IAAM0hB,IAAMiK,EAAIK,gBAAgBtW;UAChC,IAAIuW,IAAiBP,EAA2BhK;UAChD,IAAImK,EAAMzuB,UAAU6uB;YAClBA,EAAephB,YAAYohB,EAAephB,UAAUtD,OAAOskB;iBACtD,IAAIA,EAAMzuB,WAAW6uB;YAC1BP,EAA2BhK,KAAOuK,IAAiB;cACjD5jB,OAAOsjB,EAAIK,gBAAgBvV;cAC3BrZ,QAAQuuB,EAAIK,gBAAgBtW,UAAUtY;cACtCyN,WAAWghB;;;AAGjB;AACF,aAAO,IACLF,EAAIC,aAAaM,iBACjB5vB,EAAG6vB,sBAAsBR,EAAIC,aAAaM;QAE1CP,EAAIC,aAAaM,cAAc1U,SAASoB,QAAQQ;UAC9C,IAAMrC,IAAaqC,EAAGnY,QAAQmY,EAAGnF;UACjC,KAAK8C;YAAY;;UAEjB,IAAMnC,IAAc3B,2BAClB8D,GACArH;UAEF,IAAIkF,GAAa;YACf,IAAMkD,IAAalD,EAAY+B;YAC/B,IAAImB,EAAWlB,SAAS9J,SAAS;cAAiB;;YAGlD,KADuBgL;cACF;;YAOrB,IAAM+T,IALqBC,qBAHJhU,GAKrBpI,GACA8F,GAE+BS,IAC/B8V,KAAYA,EAAS9qB,KAAKjB;YAE5B,IAAM0hB,IAAMiK,EAAIK,gBAAgBtW;YAChC,IAAIuW,IAAiBP,EAA2BhK;YAChD,IAAImK,EAAMzuB,UAAU6uB;cAClBA,EAAephB,YAAYohB,EAAephB,UAAUtD,OAAOskB;mBACtD,IAAIA,EAAMzuB,WAAW6uB;cAC1BP,EAA2BhK,KAAOuK,IAAiB;gBACjD5jB,OAAOsjB,EAAIK,gBAAgBvV;gBAC3BrZ,QAAQuuB,EAAIK,gBAAgBtW,UAAUtY;gBACtCyN,WAAWghB;;;AAGjB;;;;;EAMR,OAAOH;;;AAGT,SAASI,qBACPxR,GACA5K,GACA8F;EAEA,IAAI3K,IAA2C;EAC/C,IAAMuhB,IAAkB/S,uBAAuBiB,GAAK9E,IAAM;EAE1D,IAAMtC,IAASxD,EAAYyD,oBAAoBmH;EAC/C,KAAKpH;IAAQ,OAAO;;EAGpB,IAAMmZ,IADU3c,EAAY4c,mBAAmBpZ,GACjB+C,IAAIsW,KAAQA,EAAKtrB;EACjCmrB,EAAgBrf,MAAMT,OAAO6D;IACzC,IAAIoC,IAASpC,EAAEnF,KAAKuH;IACpB,OACEA,MACCjW,EAAGkwB,aAAaja,OAChBjW,EAAGga,sBAAsB/D;MAE1BA,IAASA,EAAOA;;IAGlB,IAAIjW,EAAGga,sBAAsB/D;MAC3B,OAAO8Z,EAAcvf,SAASyF,EAAOtR,KAAKyU;;MAE1C,QAAO;;KAILkD,QAAQ5N;IACZ,IAAM6H,IAAOyC,gBAAgBtK,EAAKA,MAAMsP,GAAc9E,GAAMC;IAC5D;MACE,IAAMgX,IAASthB,EAAM0H,GAAM;QAAE6F,aAAY;;MACzC,IAAI+T,EAAO9T,YAAYpW,MAAM4N,KAAKA,EAAEtQ,SAASe,EAAKC;QAChDgK,IAAYA,EAAUtD,OAAOklB,EAAO9T;;AAEvC,MAAC,OAAO9K;MACP;AACF;;EAGF,OAAOhD;AACT;;AC1JO,SAAS6hB,8BACdnX,GACAnX,GACAoX;EAEA,IAAMvH,IAAmBuH,EAAKmX,OAAOC,6BAA4B;EACjE,IAAMld,IAAc8F,EAAKW,gBAAgBC,cAAcC;EACvD,KAAKpI;IAAkB;;EAEvB,IAAIjC,IAAS2L,UAAUnC,GAAMD;EAC7B,KAAKvJ;IAAQ;;EAEb,IAAMhB,IAAO6M,SAAS7L,GAAQ5N;EAC9B,KAAK4M;IAAM;;EAEX,IAAIigB,IAA0BjgB;EAO9B,IAAI1O,EAAGie,oBAAoB0Q;IACzBA,IACEA,EAAezQ,gBAAgBpH,aAAalD,KAAK0E,KAE7CtY,EAAGga,sBAAsB1B,MACzBA,EAAY/C,eACZvV,EAAG2R,iBAAiB2G,EAAY/C,iBAE9B7G;SACH,IAAI1O,EAAGuwB,0BAA0B5B;IACtCA,IACEA,EAAe7X,aAAalD,KAAK0E,KAE7BtY,EAAGga,sBAAsB1B,MACzBA,EAAY/C,eACZvV,EAAG2R,iBAAiB2G,EAAY/C,iBAE9B7G;SACH,IACL1O,EAAGga,sBAAsB2U,MACzBA,EAAepZ,eACfvV,EAAG2R,iBAAiBgd,EAAepZ;IAEnCoZ,IAAiBA,EAAepZ;;IAEhC,OAAOoZ,MAAmB3uB,EAAG2R,iBAAiBgd;MAC5CA,IAAiBA,EAAe1Y;;;EAQpC,KAAKiG,oBAA2ByS,GAAgBvb;IAC9C;;EAGF,IAAIod,GACFC,IAAgBxX;EAClB,IAAI0V,EAAe+B,eAAe;IAChC,KAAOC,KAAahC,EAAe+B;IACnC,KAAKC,MAAc3wB,EAAG4wB,gBAAgBD;MAAY;;IAClD,KAAQjiB,MAAMgF,GAAOuF,UAAUqB,KAC7BuW,kCAAkCF,GAAW1X,GAAUC;IACzDsX,IAAY9c;IACZ+c,IAAgBnW;AACjB,SAAM,IAAIqU,EAAe/c,UAAU,IAAI;IACtC,KACG5R,EAAGmS,aAAawc,EAAe/c,UAAU,QACzC5R,EAAG2R,iBAAiBgd,EAAe/c,UAAU;MAE9C;;IACF,KAAQlD,MAAMgF,GAAOuF,UAAUqB,KAC7BwW,qCACEnC,EAAe/c,UAAU,IACzBqH,GACAC;IAEJsX,IAAY9c;IACZ+c,IAAgBnW;AAClB;EAEA,KAAKkW;IAAW;;EAEhB,IAAMjb,IAAcib;EACpB,MACGjb,KACAvV,EAAG2R,iBAAiB4D,MACpBA,EAAY3D,UAAU,MACtB5R,EAAG4S,oBAAoB2C,EAAY3D,UAAU;IAE9C;;EAGF,IAAM6Z,IAAOsF,wBACX7X,GACA3D,EAAY3D,UAAU,IACtB6e,GACAlb,EAAY3D,UAAU,MACpB5R,EAAGib,yBAAyB1F,EAAY3D,UAAU,MAChD2D,EAAY3D,UAAU,UACtB7G;EAEN,IAAMimB,IAAerC,EAAe/c,UAAU;EAE9C,KAAKof;IAEH,OAAO;MACLpX,MAAM;QACJ7N,OAAO4iB,EAAe/c,UAAU/O;QAChC/B,QAAQ;;MAEVmwB,aAAa,WAAWxF;;SAErB,IACLzrB,EAAG8T,gBAAgBkd,MACnBA,EAAa5X,cAAc,WAAWqS;IAGtC,OAAO;MACL7R,MAAM;QACJ7N,OAAOilB,EAAa7W;QACpBrZ,QAAQkwB,EAAahlB,MAAMglB,EAAa7W;;MAE1C8W,aAAa,WAAWxF;;SAErB,IAAIzrB,EAAGmS,aAAa6e;IAGzB,OAAO;MACLpX,MAAM;QACJ7N,OAAOilB,EAAa7W;QACpBrZ,QAAQkwB,EAAahlB,MAAMglB,EAAa7W;;MAE1C8W,aAAa,WAAWxF;;;IAG1B;;AAEJ;;AAEO,IAAMsF,0BAA0BA,CACrC7X,GACAgY,GACAT,GACAU;EAEA,IAAIA,GAAqB;IACvB,IAAM5iB,IAA2C;IACjDoO,oBAAoBwU,GAAqB5iB,GAAW2K;IACpD,IAAI3C,IAAOyC,gBACTkY,GACAT,GACAvX,GACAC;IACF,IAAMgX,IAASthB,MAAM0H;IACrB,IAAMqF,IAAO,IAAInK;IACjB,KAAK,IAAM8K,KAAc4T,EAAO9T;MAC9B,IACEE,EAAWhZ,SAASe,MACnBsX,EAAKxJ,IAAImK;QAEV6U,oCAAoC7U;;;IAIVhO,EAC3BoL,IAAI8V;MACH2B,oCAAoC3B;MACpC,OAAO9gB,MAAM8gB;OAEdzf,OAAO,CAACyf,GAAUhM,GAAO4N,MAAUA,EAAMC,QAAQ7B,OAAchM,GAE5CnH,QAAQiV;MAC5Bhb,IAAO,GAAGA,QAAWgb;;IAEvB,IAAMC,IAAW7iB,MAAME,MAAM0H;IAC7B,OAAOkb,EAAW,UAAUlrB,OAAOirB,GAAUE,OAAO;AACtD,SAAO;IACL,IAAMC,IAAiBtW,UAAUnC,GAAMuX;IACvC,KAAQliB,WAAAA,KAAcwO,uBAAuB4U,GAAgBzY;IAE7D,IAAM3C,IAAOyC,gBACXkY,GACAT,GACAvX,GACAC;IAEF,IAAMgX,IAASthB,MAAM0H;IACrB,IAAMqF,IAAO,IAAInK;IACjB,KAAK,IAAM8K,KAAc4T,EAAO9T;MAC9B,IACEE,EAAWhZ,SAASe,MACnBsX,EAAKxJ,IAAImK;QAEV6U,oCAAoC7U;;;IAIxC,IAAMqV,IAAU,IAAIngB;IACpBogB,MAAM1B,GAAQ;MACZxqB,oBAAoB+I;QAClBH,EAAU8B,KAAK3B;;MAEjBjJ,gBAAgBiJ;QACdkjB,EAAQ7V,IAAIrN,EAAK/J,KAAKjB;;;IAI1B,IAAIouB,IAAevb;IACnB,IAAMwb,IAAU,IAAItgB;IACpB,IAAMugB,IAAmB,KAAIJ;IAE7B,IAAIK;IACJ,OAAQA,IAAaD,EAAiBtV,SAAU;MAC9CqV,EAAQhW,IAAIkW;MACZ,IAAMV,IAAqBhjB,EAAUqF,KACnCC,KAAKA,EAAElP,KAAKjB,UAAUuuB;MAExB,KAAKV,GAAoB;QACvBrY,EAAKgZ,QAAQC,eAAeC,OAAOlZ,KACjC,kDAAkD+Y;QAEpD;AACF;MAEAb,oCAAoCG;MAEpCM,MAAMN,GAAoB;QACxB9rB,gBAAgBiJ;UACd,KAAKqjB,EAAQ3f,IAAI1D,EAAK/J,KAAKjB;YACzBsuB,EAAiB3hB,KAAK3B,EAAK/J,KAAKjB;;;;MAItCouB,IAAe,GAAGA,QAAmBnjB,MAAM4iB;AAC7C;IAEA,OAAOE,EAAW,UACflrB,OAAOoI,MAAME,MAAMijB,KACnBJ,OAAO;AACZ;;;AAGK,IAAMb,oCAAoCA,CAC/CF,GACA1X,GACAC;EAEA,IAAM9F,IAAc8F,EAAKW,gBAAgBC,cAAcC;EACvD,KAAK3G;IAAa,OAAO;MAAE1E,MAAM;MAAMuK;;;EAGvC,IAAIwB;EACJ,IAAIza,EAAGmS,aAAawe,EAAU0B;IAC5B5X,IAAakW,EAAU0B;SAClB,IAAIryB,EAAGsyB,gBAAgB3B,EAAU0B;IAEtC5X,IAAakW,EAAU0B,SAASvc;;EAGlC,KAAK2E;IAAY,OAAO;MAAE/L,MAAM;MAAMuK;;;EAEtC,IAAMvV,IAAQqV,qBAAqB0B,GAAYrH;EAC/C,KAAK1P,MAAUwY,cAAqBxY,GAAO0P;IACzC,OAAO;MAAE1E,MAAM;MAAMuK;;;EAGvB,OAAO;IACLvK,MAAMhL;IACNuV,UAAUvV,EAAM2W,gBAAgBC;;;;AAI7B,IAAMwW,uCAAuCA,CAClDyB,GACAtZ,GACAC;EAEA,IAAIlZ,EAAGmS,aAAaogB,IAAuB;IACzC,IAAMnf,IAAc8F,EAAKW,gBAAgBC,cAAcC;IACvD,KAAK3G;MAAa,OAAO;QAAE1E,MAAM;QAAMuK;;;IAEvC,IAAMvV,IAAQqV,qBAAqBwZ,GAAsBnf;IACzD,KAAK1P,MAAUwY,cAAqBxY,GAAO0P;MACzC,OAAO;QAAE1E,MAAM;QAAMuK;;;IAGvB,OAAO;MACLvK,MAAMhL;MACNuV,UAAUvV,EAAM2W,gBAAgBC;;AAEpC;IACE,OAAO;MAAE5L,MAAM6jB;MAAsBtZ;;;;;AAMzC,IAAMmY,sCACJ7U;EAECA,EAAgDiW,aAC/CjW,EAAWiW,YAAYxiB,OACrByiB,KAAsC,cAAzBA,EAAU9tB,KAAKjB;;;ACjTlC,IAAMgvB,KAAyB,IAAIjhB,IAAI,EACrC,YACA,UACA,UACA,WACA,aACA,oBACA,qBACA,aACA,YACA,YACA,aACA,uBACA,cACA,eACA,SACA,YACA;;AAKK,IAAMkhB,KAA6B;;AACnC,IAAMC,KAA6B;;AACnC,IAAMC,KAA6B;;AACnC,IAAMC,KAA6B;;IAC7BC,KAAkB,EANS,OACG,OFhDN,OEyDnC7G,IACAyG,IACAC,IACAC,IACAC;;AAGF,IAAME,KAAQ,IAAIhR,SAAkC;EAElD+B,KAAK;EACLjD,KAAK;;;AAGA,SAASmS,sBACdha,GACA/K,GACAgL;EAEA,IAAMvH,IAAmBuH,EAAKmX,OAAOC,6BAA4B;EAEjE,IAAI5gB,IAAS2L,UAAUnC,GAAMD;EAC7B,KAAKvJ;IAAQ;;EAEb,IACEe,GADElC,IAA2C;EAK/C,IAAIoD,GAAkB;IACpB,IAAMsL,IAASF,uBAAuBrN,GAAQwJ;IAC9C3K,IAAY0O,EAAO1O;IACnBkC,IAAQwM,EAAOxM;AACjB;IACEA,IN/DG,SAASyiB,2BACd1X;MAEA,IAAMyB,IAEF;OACJ,SAASrJ,KAAKlF;QACZ,IACEwN,aAAoBxN,MACnB1O,EAAGwZ,gCAAgC9K,MAClCwN,aAAoBxN,EAAKuH,SAC3B;UACAgH,EAAO5M,KAAK3B;UACZ;AACF;UACE1O,EAAG0b,aAAahN,GAAMkF;;AAE1B,OACAA,CAAK4H;MACL,OAAOyB;AACT,KM2CYiW,CAA2BxjB,GAAQiK,IAAI9F,MAAM;MACnDnF,MAAMmF;MACN3F,QAAQ;;;EAIZ,IAAMilB,IAAQ1iB,EAAMkJ,IAAI,EAAGjL;IACzB,KACG1O,EAAGwZ,gCAAgC9K,MAClC1O,EAAG0e,qBAAqBhQ,QACzBiD;MAED,IAAI3R,EAAGiT,2BAA2BvE,EAAKuH;QACrCvH,IAAOA,EAAKuH;;QAEZ;;;IAIJ,OAAO+C,gBAAgBtK,GAAMuK,GAAUC,GAAMC;;EAG/C,IAAMia,IAAW7H,GACf5Z,IACIjC,EAAO0J,YACL7K,EAAUoL,IAAI9F,KAAKlF,MAAMkF,IAAIoZ,KAAK,OAClC/e,EAAOmlB,UACTF,EAAMlG,KAAK,OAAO/e,EAAOmlB;EAG/B,IAAIC;EACJ,IAAIN,GAAM5gB,IAAIghB;IACZE,IAAgBN,GAAMhN,IAAIoN;SACrB;IACLE,IAAgBC,eAAe7jB,GAAQ;MAAEe;MAAOlC;OAAaL,GAAQgL;IACrE8Z,GAAMzK,IAAI6K,GAAUE;AACtB;EAEA,IAAME,IACJta,EAAKmX,OAAOmD,qCAAoC;EAClD,IAAIC,IAAuC;EAE3C,IAAI9hB,GAAkB;IAKpB,IAAM+hB,IAJiBpW,gCAAgC5N,GAAQwJ,GAK5DS,IAA0BjG;MACzB,KAAQhF,MAAMigB,KAAmBjb;MACjC,KAAKib,EAAe+B,kBAAkB/B,EAAe/c,UAAU;QAC7D,OAAO;UACL+hB,UAAU3zB,EAAG4zB,mBAAmB7iB;UAChCuO,MAAMqT;UACNkB,MAAMnkB;UACNokB,aAAa;UACb/nB,OAAO4iB,EAAexU;UACtBrZ,QAAQ6tB,EAAelT,WAAWkT,EAAexU;;;MAIrD,IAAIqW,GAEFlD,GACAvhB,GACAjL,GAHA2vB,IAAgBxX;MAIlB,IAAM0X,IACJhC,EAAe+B,iBAAiB/B,EAAe+B,cAAc;MAC/D,IAAIC,GAAW;QACb5kB,IAAQ4kB,EAAUxW;QAClBrZ,IAAS6vB,EAAUlV,WAAWkV,EAAUxW;QAExC,KAAKna,EAAG4wB,gBAAgBD;UACtB,OAAO;YACLgD,UAAU3zB,EAAG4zB,mBAAmB7iB;YAChCuO,MAAMqT;YACNkB,MAAMnkB;YACNokB,aACE;YACF/nB;YACAjL;;;QAGJ,KAAQ4N,MAAMgF,GAAOuF,UAAUqB,KAC7BuW,kCAAkCF,GAAW1X,GAAUC;QACzDsX,IAAY9c;QACZ+c,IAAgBnW;QAChBgT,IAAMqD,EAAUvX;AACjB,aAAM,IAAIuV,EAAe/c,UAAU,IAAI;QACtC7F,IAAQ4iB,EAAe/c,UAAU,GAAGuI;QACpCrZ,IACE6tB,EAAe/c,UAAU,GAAG6J,WAC5BkT,EAAe/c,UAAU,GAAGuI;QAC9B,KACGna,EAAGmS,aAAawc,EAAe/c,UAAU,QACzC5R,EAAG2R,iBAAiBgd,EAAe/c,UAAU;UAE9C,OAAO;YACL+hB,UAAU3zB,EAAG4zB,mBAAmB7iB;YAChCuO,MAAMqT;YACNkB,MAAMnkB;YACNokB,aACE;YACF/nB;YACAjL;;;QAIJ,KAAQ4N,MAAMgF,GAAOuF,UAAUqB,KAC7BwW,qCACEnC,EAAe/c,UAAU,IACzBqH,GACAC;QAEJsX,IAAY9c;QACZ+c,IAAgBnW;QAChBgT,IAAMqB,EAAe/c,UAAU,GAAGwH;AACpC;MAEA,KAAKoX;QACH,OAAO;UACLmD,UAAU3zB,EAAG4zB,mBAAmB7iB;UAChCuO,MAAMuT;UACNgB,MAAMnkB;UACNokB,aAAa,4BAA4BxG;UACzCvhB;UACAjL;;;MAIJ,IAAMyU,IAAcib;MACpB,MACGjb,KACAvV,EAAG2R,iBAAiB4D,MACpBA,EAAY3D,UAAU,MACtB5R,EAAG4S,oBAAoB2C,EAAY3D,UAAU;QAI9C,OAAO;UACL+hB,UAAU3zB,EAAG4zB,mBAAmB7iB;UAChCuO,MAAMuT;UACNgB,MAAMnkB;UACNokB,aAAa,oBAAoBxG;UACjCvhB;UACAjL;;;MAIJ,KAAK6tB,EAAe/c,UAAU;QAG5B,OAAO;UACL+hB,UAAU3zB,EAAG4zB,mBAAmB7iB;UAChCuO,MAAMsT;UACNiB,MAAMnkB;UACNokB,aAAa;UACb/nB,OAAO4iB,EAAe/c,UAAU/O;UAChC/B,QAAQ6tB,EAAe/c,UAAU5F,MAAM2iB,EAAe/c,UAAU/O;;;MAIpE,IAAM4oB,IAAOkD,EAAe/c,UAAU,GAAGwH,UAAUhX,MAAM,IAAI;MAC7D,IAAIqpB,EAAKnpB,WAAW,YAAY;QAC9B,IAAMyxB,IAAgBhD,wBACpB7X,GACA3D,EAAY3D,UAAU,IACtB6e,GACAlb,EAAY3D,UAAU,MACpB5R,EAAGib,yBAAyB1F,EAAY3D,UAAU,MAChD2D,EAAY3D,UAAU,UACtB7G;QAEN,KAAKgpB;UAAe,OAAO;;QAG3B,IADqB,UAAUA,QACVtI;UACnB,OAAO;YACLkI,UAAU3zB,EAAG4zB,mBAAmB7iB;YAChCuO,MAAMwT;YACNe,MAAMnkB;YACNokB,aAAa;YACb/nB,OAAO4iB,EAAe/c,UAAU/O;YAChC/B,QACE6tB,EAAe/c,UAAU5F,MAAM2iB,EAAe/c,UAAU/O;;;AAGhE;MAEA,OAAO;OAERmN,OAAO+K;IAEVuY,EAAcjjB,QAASqjB;AACzB;EAEA,IAAI/hB,KAAoB6hB,GAAkC;IACxD,IAAMQ,IAA6BjF,0BAA0Brf,GAAQwJ;IACrE,IAAM9F,IAAc8F,EAAKW,gBAAgBC,cAAcC;IAEvD,IAAMka,IAAgB,IAAIxiB;IAC1BhB,EAAM6L,QAAQ,EAAG5N;MACf;QACE,IAAMyhB,IAASthB,EAAMH,EAAK0K,UAAUhX,MAAM,IAAI,IAAI;UAChDga,aAAY;;QAEdyV,EAAM1B,GAAQ;UACZ1qB,gBAAgBiJ;YACdulB,EAAclY,IAAIrN,EAAK/J,KAAKjB;;;AAGlC,QAAE,OAAO6N,IAAI;;IAIYgN,0BAA0B7O,GAClC4M,QAAQlR;MACzB,IAAM8oB,IAAW9oB,EAAKwG,UAAU;MAChC,KAAKsiB;QAAU;;MAGf,IAAIl0B,EAAGib,yBAAyBiZ;QAC9BA,EAAShZ,SAASoB,QAAQlB;UACxB,IAAIpb,EAAGmS,aAAaiJ,IAAU;YACPO,eAAeP,GAASlC,GAAM9F,GACtCkJ,QAAQyB,KAAOkW,EAAclY,IAAIgC,EAAIpZ,KAAKjB;AACzD;;;;IAKN+G,OAAOC,KAAKspB,GAA4B1X,QAAQoT;MAC9C,KACEnhB,WAAW4lB,GAAapoB,OACxBA,GAAKjL,QACLA,KACEkzB,EAA2BtE;MAC/B,IAAM0E,IAAmB/xB,MAAMkJ,KAC7B,IAAIkG,IAAI0iB,EAAcnkB,OAAO6D,MAAMogB,EAAc7hB,IAAIyB;MAEvD,IAAIugB,EAAiBtzB;QACnB2yB,EAAoBpjB,KAAK;UACvBwjB,MAAMnkB;UACN5O;UACAiL;UACA4nB,UAAU3zB,EAAG4zB,mBAAmB7iB;UAChCuO,MFhV2B;UEiV3BwU,aAAa,6CAA6CM,EAAiBnH,KACzE,aACOyC;;;;IAKf,OAAO,KAAI4D,MAAkBG;AAC/B;IACE,OAAOH;;AAEX;;AAEA,IAAMC,iBAAiBA,CACrB7jB,IAEEe,UACAlC,eASFL,GACAgL;EAGA,IAAMvH,IAAmBuH,EAAKmX,OAAOC,6BAA4B;EACjE,IAAMld,IAAc8F,EAAKW,gBAAgBC,cAAcC;EAEvD,IAAMsa,IAAc5jB,EACjBkJ,IAAI2a;IACH,IAAI5lB,IAAO4lB,EAAa5lB;IACxB,KACGiD,MACA3R,EAAGwZ,gCAAgC9K,MAClC1O,EAAG0e,qBAAqBhQ;MAE1B,IAAI1O,EAAGiT,2BAA2BvE,EAAKuH;QACrCvH,IAAOA,EAAKuH;;QAEZ;;;IAIJ,KAAQkD,cAAc5C,GAAI8C,eAAEA,KAAkBL,gBAC5CtK,GACAuK,GACAC;IAEF,IAAM7J,IAAQkH,EAAKjH,MAAM;IAEzB,IAAIilB,KAAe;IACnB,IAAIv0B,EAAG4a,eAAelM,EAAKuH;MACzB,IAAIjW,EAAGw0B,sBAAsB9lB,EAAKuH,OAAOA;QACvCse,KAAe;;WAEZ,IAAIv0B,EAAGw0B,sBAAsB9lB,EAAKuH;MACvCse,KAAe;;IAKjB,IAAIE,IACF/lB,EAAKyL,cACJxI,IACG,IACCjD,EAAqCwE,IAAIkG,UAAUtY,UACnDyzB,IAAe,IAAI;IAC1B,IAAMG,IAAcD,IAAmB/lB,EAAK0K,UAAUtY;IACtD,IAAI6zB,IAAe,KAAIpmB;IAEvB,SAAsCxD,MAAlCupB,EAAajX,kBAAgC;MAC/C,IAAM8W,IAAgB,IAAI1iB;MAC1B,KAAK,IAAMgJ,KAAc6Z,EAAajX,kBAAkB;QACrC1B,eAAelB,GAAYvB,GAAM9F,GACzCkJ,QAASsY,KAChBT,EAAcpY,IAAI6Y,EAAKjwB,KAAKjB;AAEhC;MACAixB,IAAeA,EAAa3kB,OAAO4kB,KACjCT,EAAc/hB,IAAIwiB,EAAKjwB,KAAKjB;AAEhC;IAEA,IAAIiO;MACF;QACE,IAAMkjB,IAAoBhmB,EAAM0H,GAAM;UACpC6F,aAAY;WACXC,YAAYrM,OAAO6D,KAAKA,EAAEtQ,SAASe,EAAKC;QAC3CowB,IAAeA,EAAa3kB,OAC1B6D,MACGghB,EAAkBC,KACjBC,KACEA,EAAExxB,SAASe,EAAKC,uBAChBwwB,EAAEpwB,KAAKjB,UAAUmQ,EAAElP,KAAKjB;AAGlC,QAAE,OAAO6N,IAAI;;IAGf,IAAMyjB,IACJV,EAAapmB,UAAUA,EAAO+mB,MAAMX,EAAapmB,UAC7CA,EAAO+mB,MAAMX,EAAapmB,SAASA,SACnCA,EAAOnL,SAASmL;IAEtB,KAAK8mB;MACH;;IAGF,IAAME,IAAmB,IAAIzjB,IAAI,KAC5BihB,OACCxZ,EAAKmX,OAAO6E,oBAAoB;IAGtC,IAAMC,IAAqBnnB,eACzBuI,GACAye,QACAjqB,QACAA,GACA4pB,GAEC3kB,OAAOolB;MACN,KAAKA,EAAKtnB,QAAQ0C,SAAS;QAAsB,QAAO;;MAExD,KAAO1C,KAAWsnB,EAAKtnB,QAAQwB,MAAM;MACrC,IAAM+lB,IACJvnB,KAAW,gCAAgCwnB,KAAKxnB;MAClD,KAAKunB;QAAS,QAAO;;MACrB,IAAME,IAAgBF,EAAQ;MAC9B,OAAOE,MAAkBL,EAAiB9iB,IAAImjB;OAE/C5b,IAAI9F;MACH,KAAM9H,OAAEA,GAAKC,KAAEA,KAAQ6H,EAAE7E;MAIzB,IAAIwmB,IAAYf,IAAmB1oB,EAAMG;MACzC,KAAK,IAAIvB,IAAI,GAAGA,KAAKoB,EAAMG,QAAQvB,IAAI0E,EAAMvO,QAAQ6J;QACnD,IAAIA,MAAMoB,EAAMG;UAAMspB,KAAazpB,EAAM/I;eACpC,IAAIqM,EAAM1E;UAAI6qB,KAAanmB,EAAM1E,GAAI7J;;;MAG5C,IAAI20B,IAAUhB,IAAmBzoB,EAAIE;MACrC,KAAK,IAAIvB,IAAI,GAAGA,KAAKqB,EAAIE,QAAQvB,IAAI0E,EAAMvO,QAAQ6J;QACjD,IAAIA,MAAMqB,EAAIE;UAAMupB,KAAWzpB,EAAIhJ;eAC9B,IAAIqM,EAAM1E;UAAI8qB,KAAWpmB,EAAM1E,GAAI7J;;;MAG1C,IAAM40B,IAAoBrc,EAAczF,KAAKC,KAEpC2hB,KAAa3hB,EAAE8G,IAAI5O,SAAS0pB,KADpB5hB,EAAE8G,IAAI5O,QAAQ8H,EAAE8G,IAAI7Z;MAIrC,IAAM40B;QACJ,OAAO;aACF7hB;UACH9H,OAAO2pB,EAAkBhb,SAAS3O;UAClCjL,QAAQ40B,EAAkBhb,SAAS5Z;;aAGrC,IAAI00B,IAAYd,GAAa;QAE3B,IAAMhb,IAAkBL,EACrBrJ,OAAO6D,KAAKA,EAAE8G,IAAI5O,QAAQ8H,EAAE8G,IAAI7Z,SAAS00B,GACzChnB,OACC,CAACC,GAAKmL,MAASnL,KAAOmL,EAAKe,IAAI7Z,SAAS8Y,EAAKc,SAAS5Z,SACtD;QAEJ00B,KAAwB9b;QACxB+b,KAAoB/b;QACpB,OAAO;aACF7F;UACH9H,OAAOypB,IAAY;UACnB10B,QAAQ20B,IAAUD;;AAEtB;QACE,OAAO;aACF3hB;UACH9H,OAAOypB,IAAY;UACnB10B,QAAQ20B,IAAUD;;;OAKzBxlB,OAAO6D,KAAKA,EAAE9H,QAAQ8H,EAAE/S,UAAU4zB;IAErC,OAAOS;KAERQ,OACA3lB,OAAO+K;EAEV,IAAMuY,IAAgBe,EAAY1a,IAChCyb,MACG;IACCvB,MAAMnkB;IACN5O,QAAQs0B,EAAKt0B;IACbiL,OAAOqpB,EAAKrpB;IACZ4nB,UACoB,MAAlByB,EAAK3lB,WACDzP,EAAG4zB,mBAAmB7iB,UACtB/Q,EAAG4zB,mBAAmB7lB;IAC5BuR,MACuB,mBAAd8V,EAAK9V,OACR8V,EAAK9V,OACa,MAAlB8V,EAAK3lB,WAjfwB,QADH;IAqfhCqkB,aAAasB,EAAKtnB,QAAQwB,MAAM,MAAM;;EAI5C,IAAIqC,GAAkB;IACpB,IAAMikB,IH7K2BC,EACnCnmB,GACAe,GACAyI;MAEA,IAAMmb,IAA+B;MAErC,MAD8Bnb,EAAKmX,OAAOyF,mBAAmB;QACjC,OAAOzB;;MAInC,IAAM0B,IAAe,IAAItkB,IAAI,EAFA,MAAM,OAAO,iBACnByH,EAAKmX,OAAO0F,gBAAgB;MAEnD,IAAMxjB,IAAU2G,EAAKW,gBAAgBC,cAAcC;MACnD,KAAKxH;QAAS;;MAEd;QACE9B,EAAM6L,QAAQ5N;UACZ,IAAMsnB,IAAWtnB,EAAK0K;UAGtB,IAAI4c,EAASxlB,SAAS,eAAewlB,EAASxlB,SAAS;YACrD;;UAEF,IAAMylB,IAAsB5J,uBAAuB3d;UACnD,KAAKunB;YAAqB;;UAE1B,IAAIC;UAEJ,IAAM7uB,IAAOkL,EAAQE,kBAAkB/D,EAAKuH;UAI5C,IAAI,YAAY5O,GAAM;YACpB,IAAMqpB,IAAiBrpB,EACpB8uB;YACHD,IACExF,KAAiBA,EAAc5vB,SAAS,IACpC4vB,EAAc,UACd3lB;AACR;UAEA,KAAKmrB,GAAU;YACb,IAAME,IAAgB/uB,EAAKqL,YAAY;YACvC,IAAI0jB,GAAe;cACjB,IAAIC,IAAU9jB,EAAQiB,gBAAgB4iB;cACtC,IAAIE,IACFjvB,EAAKkvB,oBAAoB;cAC3B,IAAIF,EAAQ5iB;gBACV,KAAK,IAAMpM,KAAQgvB,EAAQ1iB;kBAEzB,IADA2iB,IAAgBjvB,EAAKkvB,oBAAoB,IACtB;oBACjBL,IAAWI,EAAcE;oBACzB;AACF;;;cAGJN,IAAWI,KAAiBA,EAAcE;AAC5C;AACF;UAEA,IAAMvI,IAAa/U,EAAKW,gBAAgBqU,wBACtCxe,EAAO4K,UACP2b,EAAoBtxB,KAAKwV;UAG3B,KAAK8T;YAAY;;UAEjB,IAAMwI,IAAsB;UAC5B,IAAMC,IAAuB;UAC7B,IAAMC,IAAqB;UAC3B,IAAMC,IAAa,IAAI7R;UAMvB8M,EAAMhjB,EAAMH,EAAK0K,UAAUhX,MAAM,IAAI,KAAK;YACxCkD,OAAO;cACLuxB,KAAAA,CAAMnoB;gBACJ,IAAMooB,IAAQpoB,EAAKooB,QAAQpoB,EAAKooB,MAAMpzB,QAAQgL,EAAK/J,KAAKjB;gBACxD,IAAMqzB,IAAOL,EAAW51B,SACpB,GAAG41B,EAAWzJ,KAAK,QAAQ6J,MAC3BA;gBAEJ,KAAKpoB,EAAKsoB,iBAAiBjB,EAAa3jB,IAAI1D,EAAK/J,KAAKjB,QAAQ;kBAC5DizB,EAAStmB,KAAK0mB;kBACdH,EAAWrO,IAAIwO,GAAM;oBACnBhrB,OAAO2C,EAAK/J,KAAKyM,IAAKrF;oBACtBjL,QAAQ4N,EAAK/J,KAAKyM,IAAKpF,MAAM0C,EAAK/J,KAAKyM,IAAKrF;;AAEhD,uBAAO,IAAI2C,EAAKsoB,cAAc;kBAC5BN,EAAWrmB,KAAKymB;kBAChBF,EAAWrO,IAAIwO,GAAM;oBACnBhrB,OAAO2C,EAAK/J,KAAKyM,IAAKrF;oBACtBjL,QAAQ4N,EAAK/J,KAAKyM,IAAKpF,MAAM0C,EAAK/J,KAAKyM,IAAKrF;;AAEhD;AACD;cACDkrB,KAAAA,CAAMvoB;gBACJ,IAAIA,EAAKsoB;kBACPN,EAAW3U;;AAEf;;;UAIJkM,EAAW3R,QAAQgR;YACjB,IAAIA,EAAIhT,aAAa5K,EAAO4K;cAAU;;YAEtC,IAAM4c,IAAa3b,SAAS7L,GAAQ4d,EAAIzP,SAAS9R;YACjD,KAAKmrB;cAAY;;YAEjB,IAAIA,EAAWjhB,WAAWggB;cAAqB;;YAE/C,IAAMkB,IAAe5kB,EAAQ6kB,kBAC3BF,GACAl3B,EAAGgX,YAAYqgB;YAGjB,IAAIC;YACJ,KAAK,IAAIC,KAAeJ,GAAc;cACpC,KAAKI,EAAY/f;gBAAkB;;cACnC,IAAIggB,IAAoBrL,mBACtB5Z,EAAQiB,gBAAgB+jB;cAE1B,IAAIrB,MAAasB,GAAmB;gBAClCF,IAAkBC;gBAClB;AACF;cAKA,IAAIC,EAAkBzgB,QAAQ/W,EAAGosB,UAAU3hB,QAAQ;gBACjD,IAAMgtB,IAAsBD,EAAkB9kB,YAAY;gBAC1D,IAAI+kB,GAAqB;kBACvBD,IAAoBjlB,EAAQiB,gBAAgBikB;kBAC5C,IAAIvB,MAAasB,GAAmB;oBAClCF,IAAkBC;oBAClB;AACF;AACF;gBAEA,IAAMG,IAAqBF,EAAkB9kB,YAAY;gBACzD,IAAIglB,GAAoB;kBACtBF,IAAoBrL,mBAClB5Z,EAAQiB,gBAAgBkkB;kBAE1B,IAAIxB,MAAasB,GAAmB;oBAClCF,IAAkBC;oBAClB;AACF;AACF;AACF;AACF;YAEA,IAAM/f,IAAmB8f,GAAiB9f;YAC1C,IAAI7S;YACJ,IACE6S,KACA,UAAUA,KACRA,EAAiB7S,SAClB3E,EAAGmS,aAAaqF,EAAiB7S,SAChC3E,EAAG23B,cAAcngB,EAAiB7S;cAEpCA,IAAO6S,EAAiB7S;mBACnB;cAGL,IAAMsxB,IAAsB5J,uBAAuB6K;cACnD,IAAIjB;gBAAqBtxB,IAAOsxB,EAAoBtxB;;AACtD;YAEA,IAAIA,GAAM;cACR,IAAMsY,IAAS0P,WAAWhoB,GAAM,IAAIgyB,GAAUjnB,GAAQwJ,IAAM;cAC5Dud,EAAUpmB,QAAQ4M;AACpB;;UAGF,KAAKwZ,EAAU31B;YACb;;UAGF,IAAM82B,IAASjB,EAAS3mB,OAAO6D,MAAM4iB,EAAUjmB,SAASqD;UACxD,IAAMgkB,IAAyB,IAAIpmB;UACnC,IAAMqmB,IAAiD,CAAA;UACvD,IAAMC,IAAqB,IAAItmB;UAC/BmmB,EAAOtb,QAAQ0b;YACb,IAAM1oB,IAAQ0oB,EAAY1oB,MAAM;YAChCA,EAAMyS;YACN,IAAMkW,IAAc3oB,EAAM2d,KAAK;YAG/B,IAFY2J,EAAW5Q,IAAIiS,IAElB;cACPJ,EAAuB9b,IAAIkc;cAC3B,IAAIH,EAAeG;gBACjBH,EAAeG,GAAclc,IAAIic;;gBAEjCF,EAAeG,KAAe,IAAIxmB,IAAI,EAACumB;;AAE3C;cACED,EAAmBhc,IAAIic;;;UAI3BH,EAAuBvb,QAAQ4b;YAC7B,IAAM9mB,IAAMwlB,EAAW5Q,IAAIkS;YAC3B,IAAMC,IAAeL,EAAeI;YACpC7D,EAAYhkB,KAAK;cACfwjB,MAAMnkB;cACN5O,QAAQsQ,EAAItQ;cACZiL,OAAO2C,EAAKyL,aAAa/I,EAAIrF,QAAQ;cACrC4nB,UAAU3zB,EAAG4zB,mBAAmB7iB;cAChCuO,MAAM4M;cACN4H,aAAa,YAAY,KAAIqE,IAC1Bxe,IAAI9F,KAAK,IAAIA,MACboZ,KAAK;;;UAIZ8K,EAAmBzb,QAAQ4b;YACzB,IAAM9mB,IAAMwlB,EAAW5Q,IAAIkS;YAC3B7D,EAAYhkB,KAAK;cACfwjB,MAAMnkB;cACN5O,QAAQsQ,EAAItQ;cACZiL,OAAO2C,EAAKyL,aAAa/I,EAAIrF,QAAQ;cACrC4nB,UAAU3zB,EAAG4zB,mBAAmB7iB;cAChCuO,MAAM4M;cACN4H,aAAa,SAASoE;;;;AAI7B,QAAC,OAAO3mB;QACPiO,QAAQ1Q,MAAM,iBAAiByC,EAAEzD,SAASyD,EAAE6mB;AAC9C;MAEA,OAAO/D;MG9DHwB,CACEnmB,GACAe,EAAMkJ,IAAI9F,KAAKA,EAAEnF,OACjBwK,MACG;IAEP,KAAK0c;MAAkB,OAAOtC;;IAE9B,OAAO,KAAIA,MAAkBsC;AAC/B;IACE,OAAOtC;;;;","x_google_ignoreList":[1,2,3,4,5,6,7,8,14,15]}